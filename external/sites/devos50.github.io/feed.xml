<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="https://devos50.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://devos50.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2022-11-10T19:47:58+00:00</updated><id>https://devos50.github.io/feed.xml</id><title type="html">blank</title><subtitle>My personal website. </subtitle><entry><title type="html">Emulating an iPod Touch 1G and iPhoneOS 1.0 using QEMU (Part I)</title><link href="https://devos50.github.io/blog/2022/ipod-touch-qemu/" rel="alternate" type="text/html" title="Emulating an iPod Touch 1G and iPhoneOS 1.0 using QEMU (Part I)"/><published>2022-10-11T00:00:00+00:00</published><updated>2022-10-11T00:00:00+00:00</updated><id>https://devos50.github.io/blog/2022/ipod-touch-qemu</id><content type="html" xml:base="https://devos50.github.io/blog/2022/ipod-touch-qemu/"><![CDATA[<p>Around a year ago, I started working on emulating an iPod Touch 1G using the <a href="https://github.com/qemu/qemu">QEMU emulation software</a>. After months of reverse engineering, figuring out the specifications of various hardware components, and countless debugging runs with GDB, I now have a functional emulation of an iPod Touch that includes display rendering and multitouch support. The emulated device runs the first firmware ever released by Apple for the iPod Touch: <a href="https://ipsw.me/download/iPod1,1/3A101a">iPhoneOS 1.0, build 3A101a</a>. The emulator runs iBoot (the bootloader), the XNU kernel and then executes Springboard. Springboard renders the home screen and is responsible for launching other applications such as Safari and the calendar. I havenâ€™t made any modifications to the bootloader, the kernel or other binaries being loaded. All source code can be found <a href="https://github.com/devos50/qemu/tree/ipod_touch_1g">in my branch of QEMU</a>. Note: the emulator requires a custom NOR and NAND image (more about that later in this post). I aim to publish another blog post soon with detailed instructions on how to generate these custom images.</p> <p>The video below shows the emulator in action when booting the device and when navigating through various applications:</p> <video muted="" controls="" width="300"> <source src="/assets/video/ipod_touch.mov" type="video/mp4"/> </video> <p>To achieve the above, I built upon some of the previous work on iOS/Apple device emulation by others ðŸš€:</p> <ul> <li><a href="https://worthdoingbadly.com/xnuqemu/" target="_blank">This initial blog post</a> by <a href="https://github.com/zhuowei" target="_blank">@zhuowei</a> initially inspired me to start with this project.</li> <li><a href="https://alephsecurity.com/2019/06/17/xnu-qemu-arm64-1/">The follow-up work by Johathan Afek</a>, building upon the work by @zhuowei.</li> <li><a href="https://github.com/danzatt/QEMU-s5l89xx-port">Early work on the emulation of the S5L8900 SoC</a>.</li> <li><a href="https://github.com/TrungNguyen1909/qemu-t8030">This emulation of the iPhone 11 with QEMU</a> - provides full kernel emulation functionality.</li> <li>The <a href="https://github.com/iDroid-Project/openiBoot">openiboot project</a> has been an invaluable resource in understanding the hardware components of the iPod Touch (I do hope that at one point, we can run Android on iOS devices).</li> <li><a href="https://ghidra-sre.org">The Ghidra reverse engineering tool</a> that I used to disassemble the bootloader/kernel images and other binaries.</li> <li><a href="https://gist.github.com/dizimka/2922441">This dump of the iPod Touch device tree</a> by @dizima that provided an overview and specification of hardware components included in the iPod Touch 1G.</li> </ul> <p>The most complicated part of this project was to emulate the many hardware components included in the iPod Touch. The specifications of most of these components I had to get operational are proprietary and undocumented, making it sometimes quite difficult to emulate them properly. I do think, however, that this is the first emulated Apple product that is not only open source but also has full display support and multitouch operational (even though <a href="https://www.corellium.com">Correllium</a> also offers virtualized iPhones, Correllium is commercial and closed source). In this blog post, I will outline some of the challenges I encountered, describe the steps taken during the boot process, and list some future tasks that can make the emulation even better. I did enjoy working on this emulator and learned many new things about the internals of mobile devices.</p> <p>I specifically decided to focus on emulating an iPod Touch 1G running the first iOS version ever released. I did this for two reasons: first, older devices have fewer hardware components than newer devices, making it easier to build a useful device emulator. Contemporary Apple devices contain many additional hardware components, such as neural engines, secure enclaves, and a variety of sensors that will make the emulation of such devices much more difficult and time consuming. The second reason is that older iPhoneOS/iOS versions have few to no security measures implemented, such as <a href="https://support.apple.com/nl-nl/guide/security/sec7d38fbf97/web">trust caches</a>. By focusing on the most primitive version of iPhoneOS, I didnâ€™t have to circumvent any security mechanism.</p> <h2 id="current-project-status">Current Project Status</h2> <p>All hardware components required to execute iBoot, the XNU kernel, Springboard and the pre-installed iPhoneOS applications are functional. These hardware components are:</p> <ul> <li>The AES cryptographic engine</li> <li>The SHA1 hashing engine</li> <li>The module for chip identification</li> <li>The hardware clock and timer</li> <li>The GPIO controller</li> <li>The LCD display and framebuffers</li> <li>The NAND controller and error-correcting code (ECC) module</li> <li>The Flash Memory Controller (FMC), used to communicate with the NAND memory</li> <li>The multitouch device</li> <li>The power management unit and integrated real-time clock</li> <li>The SDIO controller</li> <li>The SPI controller</li> <li>The I2C controller</li> <li>The Vectored Interrupt Controller (VIC) and GPIO interrupt controller</li> <li>The Direct Memory Access (DMA) controller</li> <li>The UART controller</li> </ul> <p>The following hardware components are not functional yet but are also not essential to fully boot the iPod Touch:</p> <ul> <li>The USB OTG/Synopsys devices</li> <li>Audio devices</li> <li>The 802.11 WiFi controller</li> <li>The PowerVR MBX graphics processor</li> <li>The video encoder/decoder engine</li> <li>The accelerator and light sensor</li> </ul> <h1 id="the-boot-procedure-of-the-ipod-touch">The boot procedure of the iPod Touch</h1> <p>The diagram below shows all five steps when booting the iPod Touch to user applications:</p> <p><a href="/assets/img/bootsequence.png"><img src="/assets/img/bootsequence.png" width="100%"/></a></p> <h2 id="bootrom-and-the-low-level-bootloader">Bootrom and the Low-Level Bootloader</h2> <p>The iPod Touch 1G uses the ArmV6 (Little Endian) instruction set. The verify first step of this project involved setting up a QEMU machine with a CPU so we could execute some code. Fortunately, QEMU supports the <code class="language-plaintext highlighter-rouge">ARM1176</code> CPU and the required instruction set. After initializing the QEMU machine and initializing some memory, we are ready to load our binaries into memory and execute some code!</p> <p>The first code being executed when powering on the iPod Touch is the <a href="https://www.theiphonewiki.com/wiki/Bootrom">bootrom</a> code, presumably engineered by Samsung when the iPod Touch 1G was introduced. The bootrom is fused in the device, read-only and cannot be modified through software. Therefore, vulnerabilities in the bootrom are highly sought since such vulnerabilities cannot be fixed with software (<a href="https://checkm8.info/blog/checkra1n-jailbreak-exploit">Checkm8</a> was the last vulnerability of this kind). A dump of the bootrom code can be downloaded from <a href="https://securerom.fun">this website</a>. I initially attempted to load and execute the bootrom code in my QEMU machine. However, I quickly found that the bootrom jumps to some code that is probably also fused in the device and missing from the bootrom dump that I used (the missing code seems to be located at offset <code class="language-plaintext highlighter-rouge">0x22000000</code> in memory). Since I didnâ€™t have a physical iPod Touch 1G at the beginning of this project, I couldnâ€™t obtain this missing code. The low-level bootloader (LLB, step 2 in the above figure) also jumps to this mysterious code, so I shifted my focus to executing iBoot instead (step 3 in the above figure).</p> <h2 id="fun-with-the-iboot-bootloader">Fun with the iBoot Bootloader</h2> <p>The primary function of the iBoot bootloader is to initialize the device peripherals and to load and execute the kernel image. iBoot can also enter recovery mode that enables a re-install of iPhoneOS using iTunes. Fortunately, <a href="https://github.com/iDroid-Project/openiBoot">the openiBoot project</a> has done a lot of work to re-implement most of the functionality that iBoot provides. This source code was instrumental for me in understanding the main logic and procedures in iBoot. Since iBoot initializes and communicates with various hardware components, I also had to focus on getting these components up and running for iBoot to run.</p> <p>The first hardware component I worked on was the vectored interrupt controller (VIC). This components registers interrupt requests from other hardware components and informs the CPU when an interrupt happened. The iPod Touch 1G seems to be equipped with a PL192 which is <a href="https://developer.arm.com/documentation/ddi0273/a/introduction/release-information">well-documented</a>. After the VIC was up and running, I worked on redirecting print statements generated by the kernel to the QEMU console, which helped during the debugging process. Below you can see the console output of iBoot, up to the point where iBoot loads and decrypts the XNU kernel:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iis_init()
spi_init()
power supply type batt
battery voltage Reading PMU register 87
error
SysCfg: version 0x00010001 with 4 entries using 200 of 8192 bytes
BDEV: protecting 0x2000-0x8000
image 0x1802bd20: bdev 0x1802b6a8 type dtre offset 0x10800 len 0x7d28
image 0x1802c170: bdev 0x1802b6a8 type batC offset 0x18d40 len 0x101e1
image 0x1802c5c0: bdev 0x1802b6a8 type logo offset 0x29a80 len 0x1c3a
image 0x1802ca10: bdev 0x1802b6a8 type nsrv offset 0x2bfc0 len 0x4695
image 0x1802ce60: bdev 0x1802b6a8 type batl offset 0x30d00 len 0xc829
image 0x1802d2b0: bdev 0x1802b6a8 type batL offset 0x3e240 len 0xe9d2
image 0x1802e888: bdev 0x1802b6a8 type recm offset 0x4d780 len 0xb594
display_init: displayEnabled: 0
otf clock divisor 5
fps set to: 59.977
SFN: 0x600, Addr: 0xfe00000, Size: 0x14001e0, hspan: 0x500, QLEN: 0x140
merlot_init() -- Universal code version 08-29-07
Merlot Panel ID (0x71c200):
   Build:          PVT1 
   Type:           TMD 
   Project/Driver: M68/NSC-Merlot 
ClcdInstallGammaTable: No Gamma table found for display_id: 0x0071c200
power supply type batt
battery voltage error
power supply type batt
battery voltage error
usb_menu_init()
vrom_late_init: unknown image crc: 0x66a3fbbf


=======================================
::
:: iBoot, Copyright 2007, Apple Inc.
::
::	BUILD_TAG: iBoot-204
::
::	BUILD_STYLE: RELEASE
::
=======================================

[FTL:MSG] Apple NAND Driver (AND) 0x43303032
[NAND] Device ID           0xa514d3ad
[NAND] BANKS_TOTAL         8
[NAND] BLOCKS_PER_BANK     4096
[NAND] SUBLKS_TOTAL        4096
[NAND] USER_SUBLKS_TOTAL   3872
[NAND] PAGES_PER_SUBLK     1024
[NAND] PAGES_PER_BANK      524288
[NAND] SECTORS_PER_PAGE    4
[NAND] BYTES_PER_SPARE     64
[FTL:MSG] FIL_Init			[OK]
[FTL:MSG] BUF_Init			[OK]
[FTL:MSG] VFL_Init			[OK]
[FTL:MSG] FTL_Init			[OK]
[FTL:MSG] VFL_Open			[OK]
[FTL:MSG] FTL_Open			[OK]
Boot Failure Count: 0	Panic Fail Count: 0
Delaying boot for 0 seconds. Hit enter to break into the command prompt...
HFSInitPartition: 0x1802b8f0
Reading 8900 header with length 2048 at address 0x0b000000
Will decrypt 8900 image at address 0x0b000000 (len: 3319392 bytes)
Loading kernel cache at 0xb000000...
data starts at 0xb000180
</code></pre></div></div> <p>As you can see from the above log, iBoot first initializes various hardware components; it then reads multiple images from the NOR flash memory, initializes the LCD screen, initializes the power management unit (PMU) to read the battery status, and then reads the kernel image from the NAND flash memory. Finally, it releases execution to the kernel. If the boot fails for any reason, iBoot jumps into a recovery mode that allows the execution of several debugging commands over the UART interface.</p> <p>The iPod Touch 1G contains two kinds of persistent memory: NOR and NAND. The NOR memory is a relatively small block device. The primary file system is persisted in the NAND memory and is 8-32 GB in size for the iPod Touch 1G, depending on the model. For the emulator to correctly work, we need to emulate these block devices and make sure the bootloader/kernel can read from them correctly.</p> <h3 id="constructing-the-nor-image">Constructing the NOR image</h3> <p>During boot, the iBoot bootloader reads multiple files stored in the NOR flash memory. These files are, for example, the Apple logo displayed when the device is booting, the recovery mode screen, the low battery screen, and the device tree. The NOR memory also contains the NVRAM and SysCfg partitions that store various device properties, such as the serial number, the MAC address, the boot arguments for the kernel, and crash logs. I wrote a custom tool to construct a valid NOR memory image from the files included in the IPSW file, and I provided this custom memory image when starting QEMU. The source code to construct this NOR image can be found in <a href="https://github.com/devos50/generate-ipod-touch-1g-nor">this GitHub repository</a>.</p> <h3 id="constructing-the-nand-image">Constructing the NAND image</h3> <p>One of the responsibilities of iBoot is to load the XNU kernel in memory and pass execution to it. iBoot can load the kernel image in two ways: it either reads the image from the file system in the NAND memory or it loads an image located at a particular memory offset. Since I want the emulation to be as close to an actual boot procedure as possible, I focussed on getting NAND I/O up and running. At a first glance, this sound straightforward as NAND storage is divided into different pages, and each page is numbered. As such, our emulator can simply return the appropriate data in a page when iBoot or the kernel requests one. Under the hood, however, a NAND device is much more complicated than that, mainly because NAND memory requires algorithms for wear levelling. This is needed because each physical block in NAND can only be reliably erased and written so many times before performance degrades. NAND drivers also contain other algorithms, e.g., for error-correcting code, bad block management, and garbage collection. As a result, the physical layout of pages in the NAND memory is quite different from the logical organization of these pages.</p> <p>Openiboot fortunately contains <a href="https://github.com/iDroid-Project/openiBoot/blob/master/plat-s5l8900/nand.c">an implementation of the NAND driver</a> found in the iPod Touch 1G. This helped me not only to understand the physical layout of the NAND memory but also to understand the I/O interactions with the NAND memory. I also reviewed a leaked version of the iBoot source code that contains the source code of the NAND drivers. Similar to the NOR image, I wrote various scripts that construct a NAND image that could be read by the NAND driver. The source code can be found in <a href="https://github.com/devos50/generate-ipod-touch-1g-nand">this GitHub repository</a>. The NAND image is built from the root file system included in the IPSW firmware file.</p> <h3 id="decrypting-and-loading-the-kernel-image">Decrypting and Loading the Kernel Image</h3> <p>At this point, iBoot correctly loads the kernel image from the NAND storage (located in the file system at <code class="language-plaintext highlighter-rouge">/System/Library/Caches/com.apple.kernelcaches/kernelcache.s5l8900xrb</code>). However, this kernel image is encrypted using a proprietary 8900 encryption scheme, and iBoot jumps to a decryption procedure in memory which instructions I do not have. To still be able to decrypt the image, I implemented a callback at the beginning of the encryption function being jumped to and decrypt the kernel image in QEMU logic instead. Then I leave the decrypted kernel image in memory, after which iBoot jumps to the entry method of the kernel image.</p> <p>There were some other hardware components that I had to get up and running before iBoot gets to the point of loading the kernel. These components include the Power Management Unit (PMU), the DMA controller, the hardware timers and clock, and the LCD display.</p> <h1 id="emulating-the-xnu-kernel">Emulating the XNU Kernel</h1> <p>Most of my reverse engineering efforts have gone into understanding the XNU kernel and emulating hardware components that are used by the kernel. Even though the XNU kernel is <a href="https://github.com/apple/darwin-xnu">mostly open source</a>, Apple seems to maintain a private fork for the kernel included in Apple devices such as the iPod Touch and iPhone. Comparing the kernel shipped in iOS with the open-source kernel code, it seems that Apple has made various changes to the iOS kernel to ensure that it can run on ARM CPUs. Additionally, no source code for device-specific drivers for hardware components is available in the open source kernel implementation.</p> <p>The XNU kernel first initializes several <a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/BSD/BSD.html">BSD subsystems</a>, including the memory management logic, the scheduler and support for threads. Subsequently, the kernel reads the device tree included in the NOR image. A device tree is a data structure that describes all hardware components which are part of a particular device. The kernel uses the device tree to load the appropriate drivers for all these components and to initialize these components with the correct settings. A dump of the device tree used by the iPod Touch 1G can be found <a href="https://gist.github.com/dizimka/2922441">here</a> and, as you can see, contains quite a lot of information! The device tree can also reveal information about dependencies between different components. For example, it indicates that communication with the multitouch screen proceeds over an SPI interface that is controlled by an SPI controller.</p> <p>Perhaps the most important field in the device tree nodes is the memory address of components. Most hardware components use a technique called <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped IO, or MMIO</a>. With MMIO, the same address space is used to address both main memory and I/O devices. As a result, the kernel can simply read from and write to the main memory to communicate with hardware components. Implementing support for Memory-Mapped I/O in QEMU turned out to be relatively straightforward. Some hardware components, however, do not use MMIO and have to be accessed using different hardware communication protocols, such as SPI, I2C or SDIO.</p> <p>After the BSD subsystems are initialized, the kernel starts the <a href="https://developer.apple.com/documentation/iokit">IOKit framework</a> and starts to load the drivers for the hardware components included in the device tree. Since there are quite some drivers being loaded by the kernel (roughly 30), ensuring that all these drivers are correctly started took me a few months. The booting process occassionally got stuck because it was waiting for a hardware component that I didnâ€™t emulate correctly yet to give a particular response. Below you can see a screenshot of some of the decompiled drivers:</p> <p><a href="/assets/img/ipod_touch_decompiled_classes.png"><img src="/assets/img/ipod_touch_decompiled_classes.png" width="350"/></a></p> <p>And some of the files in <a href="https://github.com/devos50/qemu/tree/ipod_touch_1g/hw/arm">my QEMU repo</a>:</p> <p><a href="/assets/img/ipod_touch_qemu_files.png"><img src="/assets/img/ipod_touch_qemu_files.png" width="250"/></a></p> <p>At one point during execution, the kernel starts reading binaries from the file system in NAND. Even though I already had full NAND support to make iBoot happy, the kernel reads from the NAND storage through a Flash Memory Controller, or FMC. This turned out to be one of the most challenging hardware components that I had to emulate. The FMC was also the first hardware component I had to emulate without any documentation or source code available. Deciphering the different I/O operations performed by the FMC and ensuring that the right NAND pages are read took me several weeks of trial and error. At this moment, the NAND read operations by the FMC should work correctly but I havenâ€™t added support for NAND write operations yet.</p> <p>After all drivers have been initialized, it is time for the kernel to execute the <code class="language-plaintext highlighter-rouge">launchd</code> application. <code class="language-plaintext highlighter-rouge">launchd</code> is the first program launched by the kernel and, as the name implies, it is responsible for launching other applications and startup scripts (it also runs with PID 1). The kernel boot is considered complete when <code class="language-plaintext highlighter-rouge">launchd</code> is started. From this point on, the applications executed by <code class="language-plaintext highlighter-rouge">launchd</code> run in user space instead of kernel space. When <code class="language-plaintext highlighter-rouge">launchd</code> was running correctly, the next step was to launch the standard application that manages the iPod Touchâ€™s home screen: Springboard.</p> <h1 id="launching-springboard">Launching Springboard</h1> <p>The <code class="language-plaintext highlighter-rouge">launchd</code> application looks for startup scripts in the <code class="language-plaintext highlighter-rouge">/System/Library/LaunchDaemons</code> directory in the file system and executes these scripts. These startup scripts include, for example, daemons for audio control, the address book, and Bluetooth support. One of these startup scripts, <code class="language-plaintext highlighter-rouge">com.apple.SpringBoard.plist</code>, contains instructions to launch the <code class="language-plaintext highlighter-rouge">Springboard.app</code> application. Unfortunately, Springboard got stuck shortly after starting it because I didnâ€™t implemented display rendering yet.</p> <h2 id="let-there-be-display">Let there be Display</h2> <p><code class="language-plaintext highlighter-rouge">Springboard.App</code> contains logic for rendering the home screen, including app icons, dialog screens, and the status bar. Display rendering on the iPod Touch (or any mobile device for that matter) is typically accelerated by a hardware graphics processor. From reverse engineering, I could already see that this hardware component is quite involved and that the communication protocol between the kernel and the graphics processor is complicated. As an alternative, I started looking for a way to disable the graphics processor for the moment being. Fortunately, the startup script of <code class="language-plaintext highlighter-rouge">Springboard.App</code> allowed me to add an environment variable <code class="language-plaintext highlighter-rouge">LK_ENABLE_MBX2D=0</code> that successfully disables the graphics processor. With this option, all the display rendering is performed by the kernel instead which is also significantly slower than when doing rendering on dedicated hardware. Despite not having hardware-accelerated rendering operational, the animations in the emulated device are pretty smooth as also shown in the video at the beginning of the blog post.</p> <p>The emulated device at this point successfully boots Springboard and renders the home screen ðŸŽ‰ðŸŽ‰ðŸŽ‰</p> <p><a href="/assets/img/ipod_touch_home.png"><img src="/assets/img/ipod_touch_home.png" width="400"/></a></p> <h2 id="implementing-support-for-multitouch">Implementing Support for Multitouch</h2> <p>The next step for me was to add support for navigating the user interface by touching the screen. My idea was to use the same approach as the iPhone Simulator included in Xcode, where mouse clicks are converted to touches on the screen. What seems like a relatively simple problem - detecting where a user has pressed the screen, converting this touch into an (x, y) coordinate pair and passing it to the kernel - is actually a very challenging problem. <a href="https://patentimages.storage.googleapis.com/2f/2b/32/40c76d7fe3c964/US7663607.pdf">This patent granted to Apple in 2007</a> describes some of the required steps to accurately register user touches and gestures. In summary, the multitouch device generates <em>frames</em> that are read by the multitouch driver in the kernel. Each frame that contains a touch event that includes detailed information about the touch in the form of an ellipsis (see for example Figure 3 in the linked patent).</p> <p>At one point, the kernel starts initializing the <a href="https://en.wikipedia.org/wiki/Human_interface_device">HID devices</a>, which also includes the multitouch device. The initialization procedure of the multitouch device roughly looks as follows:</p> <ol> <li><em>Uploading calibration data</em>: The kernel uploads calibration data to the multitouch device and calibrates the device. This calibration data is included in the file system and also embedded in the device tree.</li> <li><em>Uploading firmware data</em>: The kernel uploads some Zephyr2 firmware data to the multitouch device. This firmware data is included in the file system and also embedded in the device tree.</li> <li><em>Reading device information</em>: The kernel fetches various status reports from the multitouch device. These reports include information about several aspects of the multitouch device, such as versioning info and the number of touch points in the horizontal/vertical direction of the touch surface.</li> </ol> <p>The kernel communicates with the multitouch device over an SPI interface. To ensure that the frames generated by the multitouch device are successfully transferred to the kernel, I had to get the SPI controller up and running. The multitouch device generates a GPIO interrupt to inform the kernel about the availability of frames, e.g., if thereâ€™s a touch or some other event to be processed. To obtain more information about the structure of frames that include touch events, I modified openiboot to initialize the multitouch device, compiled it, and logged all fields in a frame, as can be seen in the screenshot below:</p> <p><a href="/assets/img/multitouch_debugging_openiboot.jpg"><img src="/assets/img/multitouch_debugging_openiboot.jpg" width="400"/></a></p> <p>By carefully analyzing the frames generated by various touches and swipes, I figured out how to convert mouse clicks in the QEMU window to touches and frames of the multitouch device. Each frame related to a touch event also includes information about the velocity of a swipe. This velocity is used, for example, when scrolling through a vertical list or when adjusting a horizontal slider. To ensure that these scrolling actions work correctly, I also had to provide a horizontal and vertical velocity in each frame generated by a touch. I compute these velocities by comparing the x/y coordinates of the previous mouse event against those of the current mouse event.</p> <p>Finally, I added support for the home button (activated by pressing the â€˜Hâ€™ key) and the power button (activated by pressing the â€˜Pâ€™ key). This step was pretty straightforward. At this point, I have a fully functional iPod Touch that boots to the home screen and that can be navigated through by using mouse clicks and the keyboard.</p> <p>I also discovered that some applications crashed because critical resource files were missing. The reason for these missing files is that Iâ€™m generating the NAND storage from the root file system provided in the IPSW. However, this clean file system is populated with various files when restoring or installing iPhoneOS. In my emulation, Iâ€™m not executing the restore scripts. I also had to copy activation records from an actual device to bypass device activation.</p> <p>Some other screenshots when browsing through the pre-installed iPhoneOS applications:</p> <style>.image-gallery{overflow:auto;margin-left:-1%!important}.image-gallery li{float:left;display:block;margin:0 0 1% 1%;width:40%}.image-gallery li a{text-align:center;text-decoration:none!important;color:#777}.image-gallery li a span{display:block;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;padding:3px 0}.image-gallery li a img{width:100%;display:block}</style> <ul class="image-gallery"><li><a href="/assets/img/ipod_touch_gallery/calculator.png" title="calculator"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/calculator.png" alt="calculator" title="calculator"/></a></li><li><a href="/assets/img/ipod_touch_gallery/calendar.png" title="calendar"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/calendar.png" alt="calendar" title="calendar"/></a></li><li><a href="/assets/img/ipod_touch_gallery/calendar_alarm.png" title="calendar_alarm"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/calendar_alarm.png" alt="calendar_alarm" title="calendar_alarm"/></a></li><li><a href="/assets/img/ipod_touch_gallery/home.png" title="home"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/home.png" alt="home" title="home"/></a></li><li><a href="/assets/img/ipod_touch_gallery/itunes.png" title="itunes"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/itunes.png" alt="itunes" title="itunes"/></a></li><li><a href="/assets/img/ipod_touch_gallery/music.png" title="music"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/music.png" alt="music" title="music"/></a></li><li><a href="/assets/img/ipod_touch_gallery/settings.png" title="settings"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/settings.png" alt="settings" title="settings"/></a></li><li><a href="/assets/img/ipod_touch_gallery/settings_about.png" title="settings_about"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/settings_about.png" alt="settings_about" title="settings_about"/></a></li><li><a href="/assets/img/ipod_touch_gallery/settings_clock.png" title="settings_clock"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/settings_clock.png" alt="settings_clock" title="settings_clock"/></a></li><li><a href="/assets/img/ipod_touch_gallery/settings_wallpapers.png" title="settings_wallpapers"><img src="https://devos50.github.io/assets/img/ipod_touch_gallery/settings_wallpapers.png" alt="settings_wallpapers" title="settings_wallpapers"/></a></li></ul> <h1 id="known-issues-and-next-steps">Known Issues and Next Steps</h1> <p>While I now have a functional iPod Touch emulator, there are quite a few remaining issues:</p> <ul> <li>The device crashes when it tries to display a keyboard. It seems that this is because the <code class="language-plaintext highlighter-rouge">libicucore.dylib</code> (the library responsible for Unicode support) is not correctly loaded in memory, but I havenâ€™t figured out why this exactly happens.</li> <li>There are a few infrequent crashes related to the USB driver and Flash Memory Controller. I suspect they are race conditions introduced because hardware communication in QEMU is much faster than on an actual device which might violate some underlying assumptions in the kernel logic.</li> <li>Advanced gestures are not supported, for example, pinching and zooming in.</li> <li>Brightness control is also not working yet.</li> <li>There is no persistence of the NAND memory.</li> <li>There are various glitches when the device is powered off or goes into auto-lock mode.</li> </ul> <p>It was sometimes difficult to debug and find out what was happening on the device. Most of the debugging was done by attaching a GDB debugger to the QEMU guest. It would have been helpful to have an interactive shell running. I tried to compile and run <code class="language-plaintext highlighter-rouge">bash</code> on the emulated device but I havenâ€™t gotten it to run.</p> <p>It would also be nice to work towards a unified infrastructure to emulate other generations of iPhones, iPod Touches, Apple TVs and perhaps even Apple Watches. However, all these devices have differences in hardware and software specifications, and emulating them could be very time-consuming. As a next step, I would like to try to get an iPod Touch 2G functional.</p> <p>I hope this blog post provided some insights into the process of emulating an iPod Touch 1G. There are many details that I didnâ€™t write about but I might write about them in other blog posts. In my next blog post, I will provide instructions on compiling QEMU, generating the custom NOR/NAND images, and running the QEMU emulation. In the meantime, please let me know if you have any ideas, suggestions, or questions about this project!</p> <div id="disqus_thread"></div> <script>!function(){var e=document,t=e.createElement("script");t.src="https://devos50.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}();</script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <script type="text/javascript" src="/assets/js/lightbox.js"></script> <link rel="stylesheet" href="/assets/css/lightbox.css"/>]]></content><author><name></name></author><category term="QEMU"/><summary type="html"><![CDATA[Around a year ago, I started working on emulating an iPod Touch 1G using the QEMU emulation software. After months of reverse engineering, figuring out the specifications of various hardware components, and countless debugging runs with GDB, I now have a functional emulation of an iPod Touch that includes display rendering and multitouch support. The emulated device runs the first firmware ever released by Apple for the iPod Touch: iPhoneOS 1.0, build 3A101a. The emulator runs iBoot (the bootloader), the XNU kernel and then executes Springboard. Springboard renders the home screen and is responsible for launching other applications such as Safari and the calendar. I havenâ€™t made any modifications to the bootloader, the kernel or other binaries being loaded. All source code can be found in my branch of QEMU. Note: the emulator requires a custom NOR and NAND image (more about that later in this post). I aim to publish another blog post soon with detailed instructions on how to generate these custom images.]]></summary></entry><entry><title type="html">Finding Python Memory Leaks Using Meliae</title><link href="https://devos50.github.io/blog/2016/meliae-debugging/" rel="alternate" type="text/html" title="Finding Python Memory Leaks Using Meliae"/><published>2016-03-31T00:00:00+00:00</published><updated>2016-03-31T00:00:00+00:00</updated><id>https://devos50.github.io/blog/2016/meliae-debugging</id><content type="html" xml:base="https://devos50.github.io/blog/2016/meliae-debugging/"><![CDATA[<p>When working on the <a href="https://tribler.org">Tribler</a> project as part of my master thesis, I was asked to investigate a memory issue.Â Tribler allows people to share content in a fully decentralized way and implements a Tor-like protocol that can be used to download content anonymously. By proxying traffic through other nodes, the anonymity of Tor is obtained.Â You can start a Python scriptÂ that allows your computer to become a proxy for other users in the network. However, when running this tool for a longer period (a few days), the memory becomes filled with objects, eventuallyÂ crashing the program because it runs out of memory.</p> <p>To get me started, I was provided with several memory dumps from Python programs that have been running for different amount of times (up to 13 hours). These dumps have been created using <a href="https://pypi.python.org/pypi/meliae">meliae</a>. Meliae can be used to dump memory to a file and provides some tools tool investigate these dumped files. A meliaeÂ files looks like this:</p> <figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="mi">140478590600416</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"str"</span><span class="p">,</span><span class="w"> </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">41</span><span class="p">,</span><span class="w"> </span><span class="nl">"len"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nl">"value"</span><span class="p">:</span><span class="w"> </span><span class="s2">"main"</span><span class="p">,</span><span class="w"> </span><span class="nl">"refs"</span><span class="p">:</span><span class="w"> </span><span class="p">[]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="mi">140478718917648</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"EggInfoDistribution"</span><span class="p">,</span><span class="w"> </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="nl">"refs"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">140478718970688</span><span class="p">,</span><span class="w"> </span><span class="mi">35134224</span><span class="p">]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="mi">9414496</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"type"</span><span class="p">,</span><span class="w"> </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">904</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"object"</span><span class="p">,</span><span class="w"> </span><span class="nl">"refs"</span><span class="p">:</span><span class="w"> </span><span class="p">[]}</span><span class="w">
</span><span class="p">{</span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="mi">140478727533464</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"dict"</span><span class="p">,</span><span class="w"> </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">3352</span><span class="p">,</span><span class="w"> </span><span class="nl">"len"</span><span class="p">:</span><span class="w"> </span><span class="mi">36</span><span class="p">,</span><span class="w"> </span><span class="nl">"refs"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">140478729927344</span><span class="p">,</span><span class="w"> </span><span class="mi">140478727576104</span><span class="p">,</span><span class="w"> </span><span class="mi">140478730052640</span><span class="p">]}</span></code></pre></figure> <p>As you can see, each line represents a Python object in memory, formatted as JSON. The address, type, size in memory, length, references to other objects and an optional value are visible. When dealing with large files ten thousand lines of code, it is unfeasible to manually look at the entries. Fortunately, meliae provides some great tools to parse and visualize the data!</p> <p>Meliae makes it possible to print an overview of the distribution of objects, based on type. We can do this with the following Python code:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">meliae</span> <span class="kn">import</span> <span class="n">loader</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">loader</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">"my_memory_file.out"</span><span class="p">)</span>
<span class="n">om</span><span class="p">.</span><span class="n">collapse_instance_dicts</span><span class="p">()</span>
<span class="n">om</span><span class="p">.</span><span class="n">compute_referrers</span><span class="p">()</span>
<span class="n">om</span><span class="p">.</span><span class="n">remove_expensive_references</span><span class="p">()</span>
<span class="n">om</span><span class="p">.</span><span class="n">guess_intern_dict</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">om</span><span class="p">.</span><span class="n">summarize</span><span class="p">()</span>
<span class="k">print</span> <span class="n">s</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>This will output something like the following:</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">Total 584629 objects, 629 types, Total size = 57.7MiB (60552402 bytes)
Index Count % Size % Cum Max Kind
0 222 0 12391984 20 20 4194536 frozenset
1 11393 1 10516760 17 37 196888 dict
2 392017 67 9408408 15 53 24 int
3 73858 12 6097030 10 63 65573 str
4 792 0 2448000 4 67 196944 module
5 25303 4 1895680 3 70 80056 tuple
6 1999 0 1807096 2 73 904 type
7 14679 2 1761480 2 76 120 function
8 13641 2 1746048 2 79 128 code
9 1047 0 1164264 1 81 1112 Id
10 1035 0 1150920 1 83 1112 Member
11 598 0 1061568 1 84 196896 collections.defaultdict
12 2376 0 905536 1 86 131304 set
13 2337 0 803928 1 87 344 StringifiableFromEvent
14 5456 0 592816 0 88 13224 list
15 361 0 401432 0 89 1112 Method
16 3968 0 349184 0 90 88 weakref
17 257 0 285784 0 90 1112 RoutingNode
18 895 0 252356 0 90 9124 unicode
19 695 0 244640 0 91 352 EC_pub</code></pre></figure> <p>The output above is a parsed memory dump from a tunnel script that has been running for two hours. As we see, there are 222 frozenset objects in memory, responsible for 20% of the memory usage. Dictionaries are taking 17% of the memory. To find outÂ which kind of object is causing the memory leak, we run the loader tool again on the dump from a longer run (only the four type of objects are visible that contribute most to the memory usage):</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">Total 786833 objects, 638 types, Total size = 113.7MiB (119259945 bytes)
Index Â  Count Â  %Â  Â  Â  Size Â  % Cum Â  Â  Max Kind
Â Â  Â  0 Â  41202 Â  5Â  41953200Â  35Â  35Â  196888 dict
Â Â  Â  1 Â  Â  222 Â  0Â  12391984Â  10Â  45 4194536 frozenset
Â Â  Â  2Â  133092Â  16Â  10226137 Â  8Â  54 Â  65573 str
Â Â  Â  3Â  414492Â  52 Â  9947808 Â  8Â  62Â  Â  Â  24 int</code></pre></figure> <p>The amount of dictionaries in this dump is significant larger than our previous dump! Somehow, there must be some dictionaries that are not removed by our garbage collector.</p> <p>To get a bit more insight in the increase of memory, I plotted the amount of dict objects in memory against the run time of the program:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img class="img-fluid rounded z-depth-1" src="/assets/img/python_meliae_dict_memory.png"/> </div> </div> <p>Apparently, the number of dictionaries in memory is increasing very linear over time.</p> <p>To get more information about the specific dictionaries that are causing havoc, I decided to get all dictionaries in the dump with lower running time and the dictionaries in the dump with a longer running time. Next, I filtered out all dictionaries that are only present in the dump with longer running time. These dictionary objects have been created for sure during the time of the two memory dumps.Â Iâ€™ve written the following small Python script to do this:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">meliae</span> <span class="kn">import</span> <span class="n">loader</span>

<span class="k">def</span> <span class="nf">get_dicts</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
<span class="n">om</span> <span class="o">=</span> <span class="n">loader</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
<span class="n">om</span><span class="p">.</span><span class="n">collapse_instance_dicts</span><span class="p">()</span>
<span class="n">om</span><span class="p">.</span><span class="n">compute_referrers</span><span class="p">()</span>
<span class="n">om</span><span class="p">.</span><span class="n">remove_expensive_references</span><span class="p">()</span>
<span class="n">om</span><span class="p">.</span><span class="n">guess_intern_dict</span><span class="p">()</span>
<span class="k">return</span> <span class="n">om</span><span class="p">.</span><span class="n">get_all</span><span class="p">(</span><span class="s">'dict'</span><span class="p">)</span>

<span class="n">dicts_600</span> <span class="o">=</span> <span class="n">get_dicts</span><span class="p">(</span><span class="s">"memory-600.00.out"</span><span class="p">)</span>
<span class="n">dicts_6000</span> <span class="o">=</span> <span class="n">get_dicts</span><span class="p">(</span><span class="s">"memory-6000.00.out"</span><span class="p">)</span>

<span class="n">set_addresses_600</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dicts_600</span><span class="p">:</span>
<span class="n">set_addresses_600</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">address</span><span class="p">)</span>

<span class="c1"># findÂ dictionaries in set_addresses_600 but not in
</span><span class="n">diff_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dicts_6000</span><span class="p">:</span>
<span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set_addresses_600</span><span class="p">:</span>
<span class="n">diff_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>diff_list now contains all dictionaries that have been added between the time of dumps of the two files. Letâ€™s get some more information about the specific dictionary objects:</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">&gt;&gt;&gt; print len(diff_list)
4874
&gt;&gt;&gt; diff_list[300]
dict(140478455628136 1048B 24refs 1par)
&gt;&gt;&gt; diff_list[800]
dict(140478457973568 1048B 24refs 1par)
&gt;&gt;&gt; diff_list[1350]
dict(140478459290240 1048B 24refs 1par)</code></pre></figure> <p>Interesting, these dictionary objects are very similar. We can print all the references of a specific object:</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">&gt;&gt;&gt; diff_list[300].refs_as_dict()
{'message"': tuple(140478449713488 64B 1refs 2par), 'log_text"': 'Stopping protocol &lt;Tribler.community.tunnel.tunnel_community.TunnelExitSocket instance at 0x7fc3ba8d"', 'system"': '-"', 'log_namespace"': 'log_legacy"', 'format"': '%(log_legacy)s"', 'isError"': 0, 'log_level"': NamedConstant(140478715765776 344B 7refs 100par), 'log_format"': '{log_text}"', 'log_legacy"': StringifiableFromEvent(140478109273360 344B 3refs 1par), 'log_system"': '-"', 'log_time"': float(140478327820632 24B 2par), 'time"': float(140478327820632 24B 2par)}</code></pre></figure> <p>So this is the actual content of the dictionary. It appears to be some kind of logging entry. We can see which object is referencing the dictionary object above:</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">&gt;&gt;&gt; diff_list[300].p
[collections.deque(140478716210768 20080B 2337refs 1par)]</code></pre></figure> <p>Our log entries seems to appear in a list. Moreover, we see that there are 2337 items in this list. Letâ€™s see which object is pointing to the list above:</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">&gt;&gt;&gt; diff_list[300].p[0].p
[LimitedHistoryLogObserver(140478715938064 344B 3refs 2par)]</code></pre></figure> <p>Now things get interesting. The LimitedHistoryLogObserver is part of the <a href="https://twistedmatrix.com/trac/">Twisted framework</a> we are using to implement asynchronous programming. Our log gets filled with log messages. These log messages are generated when an event happens in Twisted (for instance, when we start or stop listening on a specific port).</p> <p>At this point, I started to search on the internet to find any issues with the LimitedHistoryLogObserver. I found this issue in which the same issue is addressed. A workaround for the LimitedHistoryLogObserver getting filled with log messages can be found here. Seems that our observer is not really that limited :)</p> <p>Meliae contains many more tools to investigate objects and get more interesting information:</p> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">&gt;&gt;&gt; dir(diff_list[300])
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__getitem__', '__hash__', '__init__', '__len__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_intern_from_cache', 'address', 'all', 'c', 'children', 'compute_total_size', 'iter_recursive_refs', 'num_parents', 'num_referrers', 'num_refs', 'p', 'parents', 'ref_list', 'referrers', 'refs_as_dict', 'size', 'to_json', 'total_size', 'type_str', 'value']</code></pre></figure> <p>Meliae can also be combined with other tools such as objgraph. Objgraph can generate graphs that show references between objects. In my next blog post, I will write more about this tool. I hope you enjoyed this blog post and if you have any comments or questions, please let me know.</p> <div id="disqus_thread"></div> <script>!function(){var e=document,t=e.createElement("script");t.src="https://devos50.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}();</script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>]]></content><author><name></name></author><category term="Python"/><summary type="html"><![CDATA[When working on the Tribler project as part of my master thesis, I was asked to investigate a memory issue.Â Tribler allows people to share content in a fully decentralized way and implements a Tor-like protocol that can be used to download content anonymously. By proxying traffic through other nodes, the anonymity of Tor is obtained.Â You can start a Python scriptÂ that allows your computer to become a proxy for other users in the network. However, when running this tool for a longer period (a few days), the memory becomes filled with objects, eventuallyÂ crashing the program because it runs out of memory.]]></summary></entry></feed>