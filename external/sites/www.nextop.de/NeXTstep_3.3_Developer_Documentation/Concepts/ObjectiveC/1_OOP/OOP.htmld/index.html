<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/Concepts/ObjectiveC/1_OOP/OOP.rtfd -->
<!-- Date: Sun Jun 28 19:36:26 1998 -->
<head>
<title>OOP</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Release 3.3 Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3" color="#FF00FF"><b>1</b></font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+3"><i>Object-Oriented Programming</i></font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Programming languages have traditionally divided the world into two parts--data and operations on data.&nbsp; Data is static and immutable, except as the operations may change it.&nbsp; The procedures and functions that operate on data have no lasting state of their own; they're useful only in their ability to affect data.</font>

<p><font face="Times">This division is, of course, grounded in the way computers work, so it's not one that you can easily ignore or push aside.&nbsp; Like the equally pervasive distinctions between matter and energy and between nouns and verbs, it forms the background against which we work.&nbsp; At some point, all programmers--even object-oriented programmers--must lay out the data structures that their programs will use and define the functions that will act on the data.</font>

<p><font face="Times">With a procedural programming language like C, that's about all there is to it.&nbsp; The language may offer various kinds of support for organizing data and functions, but it won't divide the world any differently.&nbsp; Functions and data structures are the basic elements of design.</font>

<p><font face="Times">Object-oriented programming doesn't so much dispute this view of the world as restructure it at a higher level.&nbsp; It groups operations and data into modular units called <i>objects</i> and lets you combine objects into structured networks to form a complete program.&nbsp; In an object-oriented programming language, objects and object interactions are the basic elements of design.</font>

<p><font face="Times">Every object has both state (data) and behavior (operations on data).&nbsp; In that, they're not much different from ordinary physical objects.&nbsp; It's easy to see how a mechanical device, such as a pocket watch or a piano, embodies both state and behavior.&nbsp; But almost anything that's designed to do a job does too.&nbsp; Even simple things with no moving parts such as an ordinary bottle combine state (how full the bottle is, whether or not it's open, how warm its contents are) with behavior (the ability to dispense its contents at various flow rates, to be opened or closed, to withstand high or low temperatures).</font>

<p><font face="Times">It's this resemblance to real things that gives objects much of their power and appeal.&nbsp; They can not only model components of real systems, but equally as well fulfill assigned roles as components in software systems.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>Interface and Implementation</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">As humans, we're constantly faced with myriad facts and impressions that we must make sense of.&nbsp; To do so, we have to abstract underlying structure away from surface details and discover the fundamental relations at work.&nbsp; Abstractions reveal causes and effects, expose patterns and frameworks, and separate what's important from what's not.&nbsp; They're at the root of understanding.</font>

<p><font face="Times">To invent programs, you need to be able to capture the same kinds of abstractions and express them in the program design.</font>

<p><font face="Times">It's the job of a programming language to help you do this.&nbsp; The language should facilitate the process of invention and design by letting you encode abstractions that reveal the way things work.&nbsp; It should let you make your ideas concrete in the code you write.&nbsp; Surface details shouldn't obscure the architecture of your program.</font>

<p><font face="Times">All programming languages provide devices that help express abstractions.&nbsp; In essence, these devices are ways of grouping implementation details, hiding them, and giving them, at least to some extent, a common interface--much as a mechanical object separates its interface from its implementation.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F14.gif" width=193 height=148></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 1</b></font><font face="Times">.&nbsp; Interface and Implementation</font>

<p><br><br>

<p><font face="Times">Looking at such a unit from the inside, as the implementor, you'd be concerned with what it's composed of and how it works. Looking at it from the outside, as the user, you're concerned only with what it is and what it does.&nbsp; You can look past the details and think solely in terms of the role that the unit plays at a higher level.</font>

<p><font face="Times">The principal units of abstraction in the C language are structures and functions.&nbsp; Both, in different ways, hide elements of the implementation:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">On the data side of the world, C structures group data elements into larger units which can then be handled as single entities. While some code must delve inside the structure and manipulate the fields separately, much of the program can regard it as a single thing--not as a collection of elements, but as what those elements taken together represent.&nbsp; One structure can include others, so a complex arrangement of information can be built from simpler layers.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">In modern C, the fields of a structure live in their own name space--that is, their names won't conflict with identically-named data elements outside the structure.&nbsp; Partitioning the program name space is essential for keeping implementation details out of the interface.&nbsp; Imagine, for example, the enormous task of assigning a different name to every piece of data in a large program and of making sure new names don't conflict with old ones.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">On the procedural side of the world, functions encapsulate behaviors that can be used repeatedly without being reimplemented.&nbsp; Data elements local to a function, like the fields within a structure, are protected within their own name space.&nbsp; Functions can reference (call) other functions, so quite complex behaviors can be built from smaller pieces.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">Functions are reusable.&nbsp; Once defined, they can be called any number of times without again considering the implementation. The most generally useful functions can be collected in libraries and reused in many different applications.&nbsp; All the user needs is the function interface, not the source code.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">However, unlike data elements, functions aren't partitioned into separate name spaces.&nbsp; Each function must have a unique name.&nbsp; Although the function may be reusable, its name is not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">C structures and functions are able to express significant abstractions, but they maintain the distinction between data and operations on data.&nbsp; In a procedural programming language, the highest units of abstraction still live on one side or the other of the data-versus-</font><br>
<font face="Times">operations divide.&nbsp; The programs you design must always reflect, at the highest level, the way the computer works.</font>

<p><font face="Times">Object-oriented programming languages don't lose any of the virtues of structures and functions.&nbsp; But they go a step further and add a unit capable of abstraction at a higher level, a unit that hides the interaction between a function and its data.</font>

<p><font face="Times">Suppose, for example, that you have a group of functions that all act on a particular data structure.&nbsp; You want to make those functions easier to use by, as far as possible, taking the structure out of the interface.&nbsp; So you supply a few additional functions to manage the data.&nbsp; All the work of manipulating the data structure--allocating it, initializing it, getting information from it, modifying values within it, keeping it up to date, and freeing it--is done through the functions.&nbsp; All the user does is call the functions and pass the structure to them.</font>

<p><font face="Times">With these changes, the structure has become an opaque token that other programmers never need to look inside.&nbsp; They can concentrate on what the functions do, not how the data is organized.&nbsp; You've taken the first step toward creating an object.</font>

<p><font face="Times">The next step is to give this idea support in the programming language and completely hide the data structure so that it doesn't even have to be passed between the functions.&nbsp; The data becomes an internal implementation detail; all that's exported to users is a functional interface.&nbsp; Because objects completely encapsulate their data (hide it), users can think of them solely in terms of their behavior.</font>

<p><font face="Times">With this step, the interface to the functions has become much simpler.&nbsp; Callers don't need to know how they're implemented (what data they use).&nbsp; It's fair now to call this an &quot;object.&quot;</font>

<p><font face="Times">The hidden data structure unites all of the functions that share it.&nbsp; So an object is more than a collection of random functions; it's a bundle of related behaviors that are supported by shared data.&nbsp; To use a function that belongs to an object, you first create the object (thus giving it its internal data structure), then tell the object which function it should invoke.&nbsp; You begin to think in terms of what the object does, rather than in terms of the individual functions.</font>

<p><font face="Times">This progression from thinking about functions and data structures to thinking about object behaviors is the essence of object-oriented programming.&nbsp; It may seem unfamiliar at first, but as you gain experience with object-oriented programming, you'll find it's a more natural way to think about things.&nbsp; Everyday programming terminology is replete with analogies to real-world objects of various kinds--lists, containers, tables, controllers, even managers.&nbsp; Implementing such things as programming objects merely extends the analogy in a natural way.</font>

<p><font face="Times">A programming language can be judged by the kinds of abstractions that it enables you to encode.&nbsp; You shouldn't be distracted by extraneous matters or forced to express yourself using a vocabulary that doesn't match the reality you're trying to capture.</font>

<p><font face="Times">If, for example, you must always tend to the business of keeping the right data matched with the right procedure, you're forced at all times to be aware of the entire program at a low level of implementation.&nbsp; While you might still invent programs at a high level of abstraction, the path from imagination to implementation can become quite tenuous--and more and more difficult as programs become bigger and more complicated.</font>

<p><font face="Times">By providing another, higher level of abstraction, object-oriented programming languages give you a larger vocabulary and a richer model to program in.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>The Object Model</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The insight of object-oriented programming is to combine state and behavior--data and operations on data--in a high-level unit, an <i>object</i>, and to give it language support.&nbsp; An object is a group of related functions and a data structure that serves those functions.&nbsp; The functions are known as the object's <i>methods</i>, and the fields of its data structure are its <i>instance variables</i>.&nbsp; The methods wrap around the instance variables and hide them from the rest of the program:</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F9.gif" width=82 height=81></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 2</b></font><font face="Times">.&nbsp; An Object</font>

<p><br><br>

<p><font face="Times">Likely, if you've ever tackled any kind of difficult programming problem, your design has included groups of functions that work on a particular kind of data--implicit &quot;objects&quot; without the language support.&nbsp; Object-oriented programming makes these function groups explicit and permits you to think in terms of the group, rather than its components.&nbsp; The only way to an object's data, the only interface, is through its methods.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=132></td>

<td><font face="Helvetica"><b>Terminology</b></font>

<p><font face="Helvetica" size="-1">Object-oriented terminology varies from language to language.&nbsp; For example, in C++ methods are called &quot;member functions&quot; and instance variables are &quot;data members.&quot;&nbsp; This manual uses the terminology of Objective C, which has its basis in Smalltalk.</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">By combining both state and behavior in a single unit, an object becomes more than either alone; the whole really is greater than the sum of its parts.&nbsp; An object is a kind of self-sufficient &quot;subprogram&quot; with jurisdiction over a specific functional area.&nbsp; It can play a full-fledged modular role within a larger program design.</font>

<p><font face="Times">For example, if you were to write a program that modeled home water usage, you might invent objects to represent the various components of the water-delivery system.&nbsp; One might be a Faucet object that would have methods to start and stop the flow of water, set the rate of flow, return the amount of water consumed in a given period, and so on.&nbsp; To do this work, a Faucet object would need instance variables to keep track of whether the tap is open or shut, how much water is being used, and where the water is coming from.</font>

<p><font face="Times">Clearly, a programmatic Faucet can be smarter than a real one (it's analogous to a mechanical faucet with lots of gauges and instruments attached).&nbsp; But even a real faucet, like any system component, exhibits both state and behavior.&nbsp; To effectively model a system, you need programming units, like objects, that also combine state and behavior.</font>

<p><font face="Times">A program consists of a network of interconnected objects that call upon each other to solve a part of the puzzle.&nbsp; Each object has a specific role to play in the overall design of the program and is able to communicate with other objects.&nbsp; Objects communicate through <i>messages</i>, requests to perform a method.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F10.gif" width=210 height=195></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 3</b></font><font face="Times">.&nbsp; Object Network</font>

<p><br><br>

<p><font face="Times">The objects in the network won't all be the same.&nbsp; For example, in addition to Faucets, the program that models water usage might also have WaterPipe objects that can deliver water to the Faucets and Valve objects to regulate the flow among WaterPipes.&nbsp; There could be a Building object to coordinate a set of WaterPipes, Valves, and Faucets, some Appliance objects--corresponding to dishwashers, toilets, and washing machines--that can turn Valves on and off, and maybe some Users to work the Appliances and Faucets.&nbsp; When a Building object is asked how much water is being used, it might call upon each Faucet and Valve to report its current state.&nbsp; When a User starts up an Appliance, the Appliance will need to turn on a Valve to get the water it requires.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The Messaging Metaphor</b></font>

<p><font face="Times">Every programming paradigm comes with its own terminology and metaphors.&nbsp; None more so than object-oriented programming.&nbsp; Its jargon invites you to think about what goes on in a program from a particular perspective.</font>

<p><font face="Times">There's a tendency, for example, to think of objects as &quot;actors&quot; and to endow them with human-like intentions and abilities.&nbsp; It's tempting sometimes to talk about an object &quot;deciding&quot; what to do about a situation, &quot;asking&quot; other objects for information, &quot;introspecting&quot; about itself to get requested information, &quot;delegating&quot; responsibility to another object, or &quot;managing&quot; a process.</font>

<p><font face="Times">Rather than think in terms of functions or methods doing the work, as you would in a procedural programming language, this metaphor asks you to think of objects as &quot;performing&quot; their methods.&nbsp; Objects are not passive containers for state and behavior, but are said to be the agents of the program's activity.</font>

<p><font face="Times">This is actually a useful metaphor.&nbsp; An object is like an actor in a couple of respects:&nbsp; It has a particular role to play within the overall design of the program, and within that role it can act fairly independently of the other parts of the program.&nbsp; It interacts with other objects as they play their own roles, but is self-contained and to a certain extent can act on its own.&nbsp; Like an actor on stage, it can't stray from the script, but the role it plays it can be multi-faceted and quite complex.</font>

<p><font face="Times">The idea of objects as actors fits nicely with the principal metaphor of object-oriented programming--the idea that objects communicate through &quot;messages.&quot;&nbsp; Instead of calling a method as you would a function, you send a message to an object requesting it to perform one of its methods.</font>

<p><font face="Times">Although it can take some getting used to, this metaphor leads to a useful way of looking at methods and objects.&nbsp; It abstracts methods away from the particular data they act on and concentrates on behavior instead.&nbsp; For example, in an object-oriented programming interface, a <b>start</b> method might initiate an operation, a <b>write</b> method might archive information, and a <b>draw </b>method might produce an image.&nbsp; Exactly which operation is initiated, which information is archived, and which image is drawn isn't revealed by the method name.&nbsp; Different objects might perform these methods in different ways.</font>

<p><font face="Times">Thus, methods are a vocabulary of abstract behaviors.&nbsp; To invoke one of those behaviors, you have to make it concrete by associating the method with an object.&nbsp; This is done by naming the object as the &quot;receiver&quot; of a message.&nbsp; The object you choose as receiver will determine the exact operation that's initiated, the data that's archived, or the image that's drawn.</font>

<p><font face="Times">Since methods belong to objects, they can be invoked only through a particular receiver (the owner of the method and of the data structure the method will act on).&nbsp; Different receivers can have different implementations of the same method, so different receivers can do different things in response to the same message.&nbsp; The result of a message can't be calculated from the message or method name alone; it also depends on the object that receives the message.</font>

<p><font face="Times">By separating the message (the requested behavior) from the receiver (the owner of a method that can respond to the request), the messaging metaphor perfectly captures the idea that behaviors can be abstracted away from their particular implementations.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Classes</b></font>

<p><font face="Times">A program can have more than one object of the same kind.&nbsp; The program that models water usage, for example, might have several Faucets and WaterPipes and perhaps a handful of Appliances and Users.&nbsp; Objects of the same kind are said to belong to the same <i>class</i>.&nbsp; All members of a class are able to perform the same methods and have matching sets of instance variables. They also share a common definition; each kind of object is defined just once.</font>

<p><font face="Times">In this, objects are similar to C structures.&nbsp; Declaring a structure defines a type.&nbsp; For example, this declaration</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct key {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char *word;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int count;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">defines the <b>struct key</b> type.&nbsp; Once defined, the structure name can be used to produce any number of instances of the type:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct key&nbsp; a, b, c, d;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct key *p = malloc(sizeof(struct key) * MAXITEMS);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The declaration is a template for a kind of structure, but it doesn't create a structure that the program can use.&nbsp; It takes another step to allocate memory for an actual structure of that type, a step that can be repeated any number of times.</font>

<p><font face="Times">Similarly, defining an object creates a template for a kind of object.&nbsp; It defines a <i>class</i> of objects.&nbsp; The template can be used to produce any number of similar objects--<i>instances</i> of the class.&nbsp; For example, there would be a single definition of the Faucet class.&nbsp; Using this definition, a program could allocate as many Faucet instances as it needed.</font>

<p><font face="Times">A class definition is like a structure definition in that it lays out an arrangement of data elements (instance variables) that become part of every instance.&nbsp; Each instance has memory allocated for its own set of instance variables, which store values peculiar to the instance.</font>

<p><font face="Times">However, a class definition differs from a structure declaration in that it also includes methods that specify the behavior of class members.&nbsp; Every instance is characterized by its access to the methods defined for the class.&nbsp; Two objects with equivalent data structures but different methods would not belong to the same class.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=132></td>

<td><font face="Helvetica"><b>Access to Methods</b></font>

<p><font face="Helvetica" size="-1">It's convenient to think of methods as being part of an object, just as instance variables are.&nbsp; As in Figure 2 above, methods can be diagrammed as surrounding the object's instance variables.</font>

<p><font face="Helvetica" size="-1">But, of course, methods aren't grouped with instance variables in memory.&nbsp; Memory is allocated for the instance variables of each new object, but there's no need to allocate memory for methods.&nbsp; All an instance needs is <i>access</i> to its methods, and all instances of the same class share access to the same set of methods.&nbsp; There's only one copy of the methods in memory, no matter how many instances of the class are created.</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Modularity</b></font>

<p><font face="Times">To a C programmer, a &quot;module&quot; is nothing more than a file containing source code.&nbsp; Breaking a large (or even not-so-large) program into different files is a convenient way of splitting it into manageable pieces.&nbsp; Each piece can be worked on independently and compiled alone, then integrated with other pieces when the program is linked.&nbsp; Using the <b>static</b> storage class designator to limit the scope of names to just the files where they're declared enhances the independence of source modules.</font>

<p><font face="Times">This kind of module is a unit defined by the file system.&nbsp; It's a container for source code, not a logical unit of the language.&nbsp; What goes into the container is up to each programmer.&nbsp; You can use them to group logically related parts of the code, but you don't have to.&nbsp; Files are like the drawers of a dresser; you can put your socks in one drawer, underwear in another, and so on, or you can use another organizing scheme or simply choose to mix everything up.</font>

<p><font face="Times">Object-oriented programming languages support the use of file containers for source code, but they also add a logical module to the language--class definitions.&nbsp; As you'd expect, it's often the case that each class is defined in its own source file--logical modules are matched to container modules.</font>

<p><font face="Times">In Objective C, for example, it would be possible to define the part of the Valve class that interacts with WaterPipes in the same file that defines the WaterPipe class, thus creating a container module for WaterPipe-related code and splitting the Valve class into more than one file.&nbsp; The Valve class definition would still act as a modular unit within the construction of the program--it would still be a logical module--no matter how many files the source code was located in.</font>

<p><font face="Times">The mechanisms that make class definitions logical units of the language are discussed in some detail under &quot;Mechanisms of Abstraction&quot; below.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Reusability</b></font>

<p><font face="Times">A principal goal of object-oriented programming is to make the code you write as reusable as possible--to have it serve many different situations and applications--so that you can avoid reimplementing, even if in only slightly different form, something that's already been done.</font>

<p><font face="Times">Reusability is influenced by a variety of different factors, including:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">How reliable and bug-free the code is</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">How clear the documentation is</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">How simple and straightforward the programming interface is</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">How efficiently the code performs its tasks</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">How full the feature set is</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Clearly, these factors don't apply just to the object model.&nbsp; They can be used to judge the reusability of any code--standard C functions as well as class definitions.&nbsp; Efficient and well documented functions, for example, would be more reusable than undocumented and unreliable ones.</font>

<p><font face="Times">Nevertheless, a general comparison would show that class definitions lend themselves to reusable code in ways that functions do not.&nbsp; There are various things you can do to make functions more reusable--passing data as arguments rather than assuming specifically-named global variables, for example.&nbsp; Even so, it turns out that only a small subset of functions can be generalized beyond the applications they were originally designed for.&nbsp; Their reusability is inherently limited in at least three ways:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Function names are global variables; each function must have a unique name (except for those declared <b>static</b>).&nbsp; This makes it difficult to rely heavily on library code when building a complex system.&nbsp; The programming interface would be hard to learn and so extensive that it couldn't easily capture significant generalizations.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">Classes, on the other hand, can share programming interfaces.&nbsp; When the same naming conventions are used over and over again, a great deal of functionality can be packaged with a relatively small and easy-to-understand interface.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Functions are selected from a library one at a time.&nbsp; It's up to programmers to pick and choose the individual functions they need.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">In contrast, objects come as packages of functionality, not as individual methods and instance variables.&nbsp; They provide integrated services, so users of an object-oriented library won't get bogged down piecing together their own solutions to a problem.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Functions are typically tied to particular kinds of data structures devised for a specific program.&nbsp; The interaction between data and function is an unavoidable part of the interface.&nbsp; A function is useful only to those who agree to use the same kind of data structures it accepts as arguments.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">Because it hides its data, an object doesn't have this problem.&nbsp; This is one of the principal reasons why classes can be reused more easily than functions.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An object's data is protected and won't be touched by any other part of the program.&nbsp; Methods can therefore trust its integrity. They can be sure that external access hasn't put it in an illogical or untenable state.&nbsp; This makes an object data structure more reliable than one passed to a function, so methods can depend on it more.&nbsp; Reusable methods are consequently easier to write.</font>

<p><font face="Times">Moreover, because an object's data is hidden, a class can be reimplemented to use a different data structure without affecting its interface.&nbsp; All programs that use the class can pick up the new version without changing any source code; no reprogramming is required.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Mechanisms of Abstraction</b></font>

<p><font face="Times">To this point, objects have been introduced as units that embody higher-level abstractions and as coherent role-players within an application.&nbsp; However, they couldn't be used this way without the support of various language mechanisms.&nbsp; Two of the most important mechanisms are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Encapsulation, and</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Polymorphism.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Encapsulation keeps the implementation of an object out of its interface, and polymorphism results from giving each class its own name space.&nbsp; The following sections discuss each of these mechanisms in turn.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Encapsulation</b></font>

<p><font face="Times">To design effectively at any level of abstraction, you need to be able to leave details of implementation behind and think in terms of units that group those details under a common interface.&nbsp; For a programming unit to be truly effective, the barrier between interface and implementation must be absolute.&nbsp; The interface must <i>encapsulate</i> the implementation--hide it from other parts of the program.&nbsp; Encapsulation protects an implementation from unintended actions and inadvertent access.</font>

<p><font face="Times">In C, a function is clearly encapsulated; its implementation is inaccessible to other parts of the program and protected from whatever actions might be taken outside the body of the function.&nbsp; Method implementations are similarly encapsulated, but, more importantly, so are an object's instance variables.&nbsp; They're hidden inside the object and invisible outside it.&nbsp; The encapsulation of instance variables is sometimes also called <i>information hiding</i>.</font>

<p><font face="Times">It might seem, at first, that hiding the information in instance variables would constrain your freedom as a programmer. Actually, it gives you more room to act and frees you from constraints that might otherwise be imposed.&nbsp; If any part of an object's implementation could leak out and become accessible or a concern to other parts of the program, it would tie the hands both of the object's implementor and of those who would use the object.&nbsp; Neither could make modifications without first checking with the other.</font>

<p><font face="Times">Suppose, for example, that you're interested in the Faucet object being developed for the program that models water use and you want to incorporate it in another program you're writing.&nbsp; Once the interface to the object is decided, you don't have to be concerned as others work on it, fix bugs, and find better ways to implement it.&nbsp; You'll get the benefit of these improvements, but none of them will affect what you do in your program.&nbsp; Because you're depending solely on the interface, nothing they do can break your code.&nbsp; Your program is insulated from the object's implementation.</font>

<p><font face="Times">Moreover, although those implementing the Faucet object would be interested in how you're using the class and might try to make sure that it meet your needs, they don't have to be concerned with the way you're writing your code.&nbsp; Nothing you do can touch the implementation of the object or limit their freedom to make changes in future releases.&nbsp; The implementation is insulated from anything that you or other users of the object might do.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Polymorphism</b></font>

<p><font face="Times">This ability of different objects to respond, each in its own way, to identical messages is called <i>polymorphism</i>.</font>

<p><font face="Times">Polymorphism results from the fact that every class lives in its own name space.&nbsp; The names assigned within a class definition won't conflict with names assigned anywhere outside it.&nbsp; This is true both of the instance variables in an object's data structure and of the object's methods:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Just as the fields of a C structure are in a protected name space, so are an object's instance variables.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Method names are also protected.&nbsp; Unlike the names of C functions, method names aren't global symbols.&nbsp; The name of a method in one class can't conflict with method names in other classes; two very different classes could implement identically named methods.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Method names are part of an object's interface.&nbsp; When a message is sent requesting an object to do something, the message names the method the object should perform.&nbsp; Because different objects can have different methods with the same name, the meaning of a message must be understood relative to the particular object that receives the message.&nbsp; The same message sent to two different objects could invoke two different methods.</font>

<p><font face="Times">The main benefit of polymorphism is that it simplifies the programming interface.&nbsp; It permits conventions to be established that can be reused in class after class.&nbsp; Instead of inventing a new name for each new function you add to a program, the same names can be reused.&nbsp; The programming interface can be described as a set of abstract behaviors, quite apart from the classes that implement them.</font>

<p><font face="Times">For example, instead of defining an <b>amountConsumed</b> method for an Appliance object to report the amount of water it uses over a given period of time, an <b>amountDispensedAtFaucet</b> method for a Faucet to report virtually the same thing, and a <b>cumulativeUsage</b> method for the Building object to report the cumulative total for the whole building--requiring programmers to learn three different names for what is conceptually the same operation--each class can simply have a <b>waterUsed</b> method.</font>

<p><font face="Times">Polymorphism also permits code to be isolated in the methods of different objects rather than be gathered in a single function that enumerates all the possible cases.&nbsp; This makes the code you write more extensible and reusable.&nbsp; When a new case comes along, you don't have to reimplement existing code, but only add a new class with a new method, leaving the code that's already written alone.</font>

<p><font face="Times">For example, suppose you have code that sends a <b>draw</b> message to an object.&nbsp; Depending on the receiver, the message might produce one of two possible images.&nbsp; When you want to add a third case, you don't have to change the message or alter existing code, but merely allow another object to be assigned as the message receiver.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=132></td>

<td><font face="Helvetica"><b>Overloading</b></font>

<p><font face="Helvetica" size="-1">The terms &quot;polymorphism&quot; and &quot;argument overloading&quot; refer basically to the same thing, but from slightly different points of view. Polymorphism takes a pluralistic point of view and notes that several classes can each have a method with the same name. Argument overloading takes the point of the view of the method name and notes that it can have different effects depending on what kind of object it applies to.</font>

<p><font face="Helvetica" size="-1">Operator overloading is similar.&nbsp; It refers to the ability to turn operators of the language (such as `==' and `+' in C) into methods that can be assigned particular meanings for particular kinds of objects.&nbsp; Objective C implements polymorphism of method names, but not operator overloading.</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Inheritance</b></font>

<p><font face="Times">The easiest way to explain something new is to start with something old.&nbsp; If you want to describe what a &quot;schooner&quot; is, it helps if your listeners already know what &quot;sailboat&quot; means.&nbsp; If you want to explain how a harpsichord works, it's best if you can assume your audience has already looked inside a piano, or has seen a guitar played, or at least is familiar with the idea of a &quot;musical instrument.&quot;</font>

<p><font face="Times">The same is true if want to define a new kind of object; the description is simpler if it can start from the definition of an existing object.</font>

<p><font face="Times">With this in mind, object-oriented programming languages permit you to base a new class definition on a class already defined. The base class is called a <i>superclass</i>; the new class is its <i>subclass</i>.&nbsp; The subclass definition specifies only how it differs from the superclass; everything else is taken to be the same.</font>

<p><font face="Times">Nothing is copied from superclass to subclass.&nbsp; Instead, the two classes are connected so that the subclass <i>inherits</i> all the methods and instance variables of its superclass, much as you want your listener's understanding of &quot;schooner&quot; to inherit what they already know about sailboats.&nbsp; If the subclass definition were empty (if it didn't define any instance variables or methods of its own), the two classes would be identical (except for their names) and share the same definition.&nbsp; It would be like explaining what a &quot;fiddle&quot; is by saying that it's exactly the same as a &quot;violin.&quot;&nbsp; However, the reason for declaring a subclass isn't to generate synonyms, but to create something at least a little different from its superclass.&nbsp; You'd want to let the fiddle play bluegrass in addition to classical music.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Class Hierarchies</b></font>

<p><font face="Times">Any class can be used as a superclass for a new class definition.&nbsp; A class can simultaneously be a subclass of another class and a superclass for its own subclasses.&nbsp; Any number of classes can thus be linked in a hierarchy of inheritance.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F12.gif" width=270 height=97></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 4</b></font><font face="Times">.&nbsp; Inheritance Hierarchy</font>

<p><br><br>

<p><font face="Times">As the figure above shows, every inheritance hierarchy begins with a root class that has no superclass.&nbsp; From the root class, the hierarchy branches downward.&nbsp; Each class inherits from its superclass, and through its superclass, from all the classes above it in the hierarchy.&nbsp; Every class inherits from the root class.</font>

<p><font face="Times">Each new class is the accumulation of all the class definitions in its inheritance chain.&nbsp; In the example above, class D inherits both from C, its superclass, and the root class.&nbsp; Members of the D class will have methods and instance variables defined in all three classes--D, C, and root.</font>

<p><font face="Times">Typically, every class has just one superclass and can have an unlimited number of subclasses.&nbsp; However, in some object-oriented programming languages (though not in Objective C), a class can have more than one superclass; it can inherit through multiple sources.&nbsp; Instead of a single hierarchy that branches downward as shown in Figure 4 above, multiple inheritance lets some branches of the hierarchy (or of different hierarchies) merge.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Subclass Definitions</b></font>

<p><font face="Times">A subclass can make three kinds of changes to the definition it inherits through its superclass:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It can expand the class definition it inherits by adding new methods and instance variables.&nbsp; This is the most common reason for defining a subclass.&nbsp; Subclasses always add new methods, and new instance variables if the methods require it.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It can modify the behavior it inherits by replacing an existing method with a new version.&nbsp; This is done by simply implementing a new method with the same name as one that's inherited.&nbsp; The new version <i>overrides</i> the inherited version. (The inherited method doesn't disappear; it's still valid for the class that defined it and other classes that inherit it.)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It can refine or extend the behavior it inherits by replacing an existing method with a new version, but still retain the old version by incorporating it in the new method.&nbsp; This is done by sending a message to perform the old version in the body of the new method.&nbsp; Each class in an inheritance chain can contribute part of a method's behavior.&nbsp; In Figure 4, for example, class D might override a method defined in class C and incorporate C's version, while C's version incorporates a version defined in the root class.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Subclasses thus tend to fill out a superclass definition, making it more specific and specialized.&nbsp; They add, and sometimes replace, code rather than subtract it.&nbsp; Note that methods generally can't be disinherited and instance variables can't be removed or overridden.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Uses of Inheritance</b></font>

<p><font face="Times">The classic examples of an inheritance hierarchy are borrowed from animal and plant taxonomies.&nbsp; For example, there could a class corresponding to the Pinaceae (pine) family of trees.&nbsp; Its subclasses could be Fir, Spruce, Pine, Hemlock, Tamarack, DouglasFir, and TrueCedar, corresponding to the various genera that make up the family.&nbsp; The Pine class might have SoftPine and HardPine subclasses, with WhitePine, SugarPine, and BristleconePine as subclasses of SoftPine, and PonderosaPine, JackPine, MontereyPine, and RedPine as subclasses of HardPine.</font>

<p><font face="Times">There's rarely a reason to program a taxonomy like this, but the analogy is a good one.&nbsp; Subclasses tend to specialize a superclass or adapt it to a special purpose, much as a species specializes a genus.</font>

<p><font face="Times">Here are some typical uses of inheritance:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Reusing code.&nbsp; If two or more classes have some things in common but also differ in some ways, the common elements can be put in an a single class definition that the other classes inherit. The common code is shared and need only be implemented once.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">For example, Faucet, Valve, and WaterPipe objects, defined for the program that models water use, all need a connection to a water source and they all should be able to record the rate of flow.&nbsp; These commonalities can be encoded once, in a class that the Faucet, Valve, and WaterPipe classes inherit from.&nbsp; A Faucet can be said to be a kind of Valve, so perhaps the Faucet class would inherit most of what it is from Valve, and add very little of its own.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Setting up a protocol.&nbsp; A class can declare a number of methods that its subclasses are expected to implement.&nbsp; The class might have empty versions of the methods, or it might implement partial versions that are to be incorporated into the subclass methods.&nbsp; In either case, its declarations establish a protocol that all its subclasses must follow.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">When different classes implement similarly named methods, a program is better able to make use of polymorphism in its design.&nbsp; Setting up a protocol that subclasses must implement helps enforce these naming conventions.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Delivering generic functionality.&nbsp; One implementor can define a class that contains a lot of basic, general code to solve a problem, but doesn't fill in all the details.&nbsp; Other implementors can then create subclasses to adapt the generic class to their specific needs.&nbsp; For example, the Appliance class in the program that models water use might define a generic water-using device that subclasses would turn into specific kinds of appliances.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">Inheritance is thus both a way to make someone else's programming task easier and a way to separate levels of implementation.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Making slight modifications.&nbsp; When inheritance is used to deliver generic functionality, set up a protocol, or reuse code, a class is devised that other classes are expected to inherit from.&nbsp; But you can also use inheritance to modify classes that aren't intended as superclasses.&nbsp; Suppose, for example, that there's an object that would work well in your program, but you'd like to change one or two things that it does.&nbsp; You can make the changes in a subclass.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Previewing possibilities.&nbsp; Subclasses can also be used to factor out alternatives for&nbsp; testing purposes.&nbsp; For example, if a class is to be encoded with a particular user interface, alternative interfaces can be factored into subclasses during the design phase of the project.&nbsp; Each alternative can then be demonstrated to potential users to see which they prefer.&nbsp; When the choice is made, the selected subclass can be reintegrated into its superclass.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Dynamism</b></font>

<p><font face="Times">At one time in programming history, the question of how much memory a program would use was settled when the source code was compiled and linked.&nbsp; All the memory the program would ever need was set aside for it as it was launched.&nbsp; This memory was fixed; it could neither grow nor shrink.</font>

<p><font face="Times">In hindsight, it's evident what a serious constraint this was.&nbsp; It limited not only how programs were constructed, but what you could imagine a program doing.&nbsp; It constrained design, not just programming technique.&nbsp; Functions (like <b>malloc()</b>) that dynamically allocate memory as a program runs opened possibilities that didn't exist before.</font>

<p><font face="Times">Compile-time and link-time constraints are limiting because they force issues to be decided from information found in the programmer's source code, rather than from information obtained from the user as the program runs.</font>

<p><font face="Times">Although dynamic allocation removes one such constraint, many others, equally as limiting as static memory allocation, remain. For example, the elements that make up an application must be matched to data types at compile time.&nbsp; And the boundaries of an application are typically set at link time.&nbsp; Every part of the application must be united in a single executable file.&nbsp; New modules and new types can't be introduced as the program runs.</font>

<p><font face="Times">Object-oriented programming seeks to overcome these limitations and to make programs as dynamic and fluid as possible.&nbsp; It shifts much of the burden of decision making from compile time and link time to run time.&nbsp; The goal is to let program users decide what will happen, rather than constrain their actions artificially by the demands of the language and the needs of the compiler and linker.</font>

<p><font face="Times">Three kinds of dynamism are especially important for object-oriented design:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Dynamic typing, waiting until run time to determine the class of an object</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Dynamic binding, determining at run time what method to invoke</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Dynamic loading, adding new components to a program as it runs</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Dynamic Typing</b></font>

<p><font face="Times">The compiler typically complains if the code you write assigns a value to a type that can't accommodate it.&nbsp; You might see warnings like these:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">incompatible types in assignment</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">assignment of integer from pointer lacks a cast</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Type checking is useful, but there are times when it can interfere with the benefits you get from polymorphism, especially if the type of every object must be known to the compiler.</font>

<p><font face="Times">Suppose, for example, that you want to send an object a message to perform the <b>start</b> method.&nbsp; Like other data elements, the object is represented by a variable.&nbsp; If the variable's type (its class) must be known at compile time, it would be impossible to let run-time factors influence the decision about what kind of object should be assigned to the variable.&nbsp; If the class of the variable is fixed in source code, so is the version of <b>start</b> that the message invokes.</font>

<p><font face="Times">If, on the other hand, it's possible to wait until run time to discover the class of the variable, any kind of object could be assigned to it.&nbsp; Depending on the class of the receiver, the <b>start</b> message might invoke different versions of the method and produce very different results.</font>

<p><font face="Times">Dynamic typing thus gives substance to dynamic binding (discussed next).&nbsp; But it does more than that.&nbsp; It permits associations between objects to be determined at run time, rather than forcing them to be encoded in a static design.&nbsp; For example, a message could pass an object as an argument without declaring exactly what kind of object it is--that is, without declaring its class.&nbsp; The message receiver might then send its own messages to the object, again without ever caring about what kind of object it is. Because the receiver uses the object it's passed to do some of its work, it is in a sense customized by an object of indeterminate type (indeterminate in source code, that is, not at run time).</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Dynamic Binding</b></font>

<p><font face="Times">In standard C, you can declare a set of alternative functions, like the standard string-comparison functions,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int strcmp(const char *, const char *);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* case sensitive */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int strcasecmp(const char *, const char *);&nbsp; /* case insensitive */</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">and declare a pointer to a function that has the same return and argument types:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int (* compare)(const char *, const char *);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You can then wait until run time to determine which function to assign to the pointer,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if ( **argv == 'i' )</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">compare = strcasecmp;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">compare = strcmp;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">and call the function through the pointer:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if ( compare(s1, s2) )</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This is akin to what in object-oriented programming is called <i>dynamic binding</i>, delaying the decision of exactly which method to perform until the program is running.</font>

<p><font face="Times">Although not all object-oriented languages support it, dynamic binding can be routinely and transparently accomplished through messaging.&nbsp; You don't have to go through the indirection of declaring a pointer and assigning values to it as shown in the example above.&nbsp; You also don't have to assign each alternative procedure a different name.</font>

<p><font face="Times">Messages invoke methods indirectly.&nbsp; Every message expression must find a method implementation to &quot;call.&quot;&nbsp; To find that method, the messaging machinery must check the class of the receiver and locate its implementation of the method named in the message.&nbsp; When this is done at run time, the method is dynamically bound to the message.&nbsp; When it's done by the compiler, the method is statically bound.</font>

<p><font face="Times">Dynamic binding is possible even in the absence of dynamic typing, but it's not very interesting.&nbsp; There's little benefit in waiting until run time to match a method to a message when the class of the receiver is fixed and known to the compiler.&nbsp; The compiler could just as well find the method itself; the run-time result won't be any different.</font>

<p><font face="Times">However, if the class of the receiver is dynamically typed, there's no way for the compiler to determine which method to invoke.&nbsp; The method can be found only after the class of the receiver is resolved at run time.&nbsp; Dynamic typing thus entails dynamic binding.</font>

<p><font face="Times">Dynamic typing also makes dynamic binding interesting, for it opens the possibility that a message might have very different results depending on the class of the receiver.&nbsp; Run-time factors can influence the choice of receiver and the outcome of the message.</font>

<p><font face="Times">Dynamic typing and binding also open the possibility that the code you write can send messages to objects not yet invented.&nbsp; If object types don't have to be decided until run time, you can give others the freedom to design their own classes and name their own data types, and still have your code send messages to their objects.&nbsp; All you need to agree on are the messages, not the data types.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Dynamic binding is routine in Objective C.&nbsp; You don't need to arrange for it specially, so your design never needs to bother with what's being done when.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=132></td>

<td><font face="Helvetica"><b>Late Binding</b></font>

<p><font face="Helvetica" size="-1">Some object-oriented programming languages (notably C++) require a message receiver to be statically typed in source code, but don't require the type to be exact.&nbsp; An object can be typed to its own class or to any class that it inherits from.</font>

<p><font face="Helvetica" size="-1">The compiler therefore can't tell whether the message receiver is an instance of the class specified in the type declaration, an instance of a subclass, or an instance of some more distantly derived class.&nbsp; Since it doesn't know the exact class of the receiver, it can't know which version of the method named in the message to invoke.</font>

<p><font face="Helvetica" size="-1">In this circumstance, the choice is between treating the receiver as if it were an instance of the specified class and simply bind the method defined for that class to the message, or waiting until run time to resolve the situation.&nbsp; In C++, the decision is postponed to run time for methods (member functions) that are declared <b>virtual</b>.</font>

<p><font face="Helvetica" size="-1">This is sometimes referred to as &quot;late binding&quot; rather than &quot;dynamic binding.&quot;&nbsp; While &quot;dynamic&quot; in the sense that it happens at run time, it carries with it strict compile-time type constraints.&nbsp; As discussed here (and implemented in Objective C), &quot;dynamic binding&quot; is unconstrained.</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Dynamic Loading</b></font>

<p><font face="Times">The usual rule has been that, before a program can run, all its parts must be linked together in one file.&nbsp; When it's launched, the entire program is loaded into memory at once.</font>

<p><font face="Times">Some object-oriented programming environments overcome this constraint and allow different parts of an executable program to be kept in different files.&nbsp; The program can be launched in bits and pieces as they're needed.&nbsp; Each piece is <i>dynamically loaded </i>and linked with the rest of program as it's launched.&nbsp; User actions can determine which parts of the program are in memory and which aren't.</font>

<p><font face="Times">Only the core of a large program needs to be loaded at the start.&nbsp; Other modules can be added as the user requests their services. Modules the user doesn't request make no memory demands on the system.</font>

<p><font face="Times">Dynamic loading raises interesting possibilities.&nbsp; For example, an entire program wouldn't have to be developed at once.&nbsp; You could deliver your software in pieces and update one part of it at a time.&nbsp; You could devise a program that groups many different tools under a single interface, and load just the tools the user wants.&nbsp; The program could even offer sets of alternative tools to do the same job.&nbsp; The user would select one tool from the set and only that tool would be loaded.&nbsp; It's not hard to imagine the possibilities.&nbsp; But because dynamic loading is relatively new, it's harder to predict its eventual benefits.</font>

<p><font face="Times">Perhaps the most important current benefit of dynamic loading is that it makes applications extensible.&nbsp; You can allow others to add to and customize a program you've designed.&nbsp; All your program needs to do is provide a framework that others can fill in, then at run time find the pieces that they've implemented and load them dynamically.</font>

<p><font face="Times">For example, in the NEXTSTEP environment, Interface Builder dynamically loads custom palettes and inspectors, and the Workspace Manager</font><font size="-2"><sup><sup>TM</sup></sup></font><font face="Times">dynamically loads inspectors for particular file formats.&nbsp; Anyone can design their own custom palettes and inspectors that these applications will load and incorporate into themselves.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=132></td>

<td><font face="Helvetica"><b>Loading and Linking</b></font>

<p><font face="Helvetica" size="-1">Although it's the term commonly used, &quot;dynamic loading&quot; could just as well be called. &quot;dynamic linking.&quot;&nbsp; Programs are linked when their various parts are joined so that they can work together; they're loaded when they're read into volatile memory at launch time.&nbsp; Linking usually precedes loading.&nbsp; Dynamic loading refers to the process of separately loading new or additional parts of a program and linking them dynamically to the parts already running.</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="EPS0.gif" width=688 height=33></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The main challenge that dynamic loading faces is getting a newly loaded part of a program to work with parts already running, especially when the different parts were written by different people.&nbsp; However, much of this problem disappears in an object-oriented environment because code is organized into logical modules with a clear division between implementation and interface.&nbsp; When classes are dynamically loaded, nothing in the newly loaded code can clash with the code already in place. Each class encapsulates its implementation and has an independent name space.</font>

<p><font face="Times">In addition, dynamic typing and dynamic binding let classes designed by others fit effortlessly into the program you've designed. Once a class is dynamically loaded, it's treated no differently than any other class.&nbsp; Your code can send messages to their objects and theirs to yours.&nbsp; Neither of you has to know what classes the other has implemented.&nbsp; You need only agree on a communications protocol.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>Structuring Programs</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Object-oriented programs have two kinds of structure.&nbsp; One can be seen in the inheritance hierarchy of class definitions.&nbsp; The other is evident in the pattern of message passing as the program runs.&nbsp; These messages reveal a network of object connections.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The inheritance hierarchy explains how objects are related by type.&nbsp; For example, in the program that models water use, it might turn out that Faucets and WaterPipes are the same kind of object, except that Faucets can be turned on and off and WaterPipes can have multiple connections to other WaterPipes.&nbsp; This similarity would be captured in the program design if the Faucet and WaterPipe classes inherit from a common antecedent.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The network of object connections explains how the program works.&nbsp; For example, Appliance objects might send messages requesting water to Valves, and Valves to WaterPipes.&nbsp; WaterPipes might communicate with the Building object, and the Building object with all the Valves, Faucets, and WaterPipes, but not directly with Appliances.&nbsp; To communicate with each other in this way, objects must know about each other.&nbsp; An Appliance would need a connection to a Valve, and a Valve to a WaterPipe, and so on.&nbsp; These connection define a program structure.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Object-oriented programs are designed by laying out the network of objects with their behaviors and patterns of interaction, and by arranging the hierarchy of classes.&nbsp; There's structure both in the program's activity and in its definition.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Outlet Connections</b></font>

<p><font face="Times">Part of the task of designing an object-oriented program is to arrange the object network.&nbsp; The network doesn't have to be static; it can change dynamically as the program runs.&nbsp; Relationships between objects can be improvised as needed, and the cast of objects that play assigned roles can change from time to time.&nbsp; But there has to be a script.</font>

<p><font face="Times">Some connections can be entirely transitory.&nbsp; A message might contain an argument identifying an object, perhaps the sender of the message, that the receiver can communicate with.&nbsp; As it responds to the message, the receiver can send messages to that object, perhaps identifying itself or still another object that that object can in turn communicate with.&nbsp; Such connections are fleeting; they last only as long as the chain of messages.</font>

<p><font face="Times">But not all connections between objects can be handled on the fly.&nbsp; Some need to be recorded in program data structures.&nbsp; There are various ways to do this.&nbsp; A table might be kept of object connections, or there might be a service that identifies objects by name.&nbsp; However, the simplest way is for each object to have instance variables that keep track of the other objects it must communicate with.&nbsp; These instance variables--termed <i>outlets</i> because they record the outlets for messages--define the principal connections between objects in the program network.</font>

<p><font face="Times">Although the names of outlet instance variables are arbitrary, they generally reflect the roles that outlet objects play.&nbsp; The figure below illustrates an object with four outlets--an &quot;agent,&quot; a &quot;friend,&quot; a &quot;neighbor,&quot; and a &quot;boss.&quot;&nbsp; The objects that play these parts may change every now and then, but the roles remain the same.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F13.gif" width=331 height=233></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 5</b></font><font face="Times">.&nbsp; Outlets</font>

<p><br><br>

<p><font face="Times">Some outlets are set when the object is first initialized and may never change.&nbsp; Others might be set automatically as the consequence of other actions.&nbsp; Still other can be set freely, using methods provided just for that purpose.</font>

<p><font face="Times">However they're set, outlet instance variables reveal the structure of the application.&nbsp; They link objects into a communicating network, much as the components of a water system are linked by their physical connections or as individuals are linked by their patterns of social relations.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Extrinsic and Intrinsic Connections</b></font>

<p><font face="Times">Outlet connections can capture many different kinds of relationships between objects.&nbsp; Sometimes the connection is between objects that communicate more or less as equal partners in an application, each with its own role to play and neither dominating the other.&nbsp; For example, an Appliance object might have an outlet instance variable to keep track of the Valve it's connected to.</font>

<p><font face="Times">Sometimes one object should be seen as being part of another.&nbsp; For example, a Faucet might use a Meter object to measure the amount of water being released.&nbsp; The Meter would serve no other object and would act only under orders from the Faucet.&nbsp; It would be an intrinsic part of the Faucet, in contrast to an Appliance's extrinsic connection to a Valve.</font>

<p><font face="Times">Similarly, an object that oversees other objects might keep a list of its charges.&nbsp; A Building object, for example, might have a list of all the WaterPipes in the program.&nbsp; The WaterPipes would be considered an intrinsic part of the Building and belong to it. WaterPipes, on the other hand, might maintain extrinsic connections to each other.</font>

<p><font face="Times">Intrinsic outlets behave differently than extrinsic ones.&nbsp; When an object is freed or archived in a file on disk, the objects that its intrinsic outlets point to must be freed or archived with it.&nbsp; For example, when a Faucet is freed, its Meter is rendered useless and therefore should be freed as well.&nbsp; A Faucet that was archived without its Meter would be of little use when it was unarchived again (unless it could create a new Meter for itself).</font>

<p><font face="Times">Extrinsic outlets, on the other hand, capture the organization of the program at a higher level.&nbsp; They record connections between relatively independent program subcomponents.&nbsp; When an Appliance is freed, the Valve it was connected to still is of use and remains in place.&nbsp; When an Appliance is unarchived, it can be connected to another Valve and resume playing the same sort of role it played before.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Activating the Object Network</b></font>

<p><font face="Times">The object network is set into motion by an external stimulus.&nbsp; If you're writing an interactive application with a user interface, it will respond to user actions on the keyboard and mouse.&nbsp; A program that tries to factor very large numbers might start when you pass it a target number on the command line.&nbsp; Other programs might respond to data received over a phone line, information obtained from a database, or information about the state of a mechanical process the program monitors.</font>

<p><font face="Times">Object-oriented programs often are activated by a flow of <i>events</i>, reports of external activity of some sort.&nbsp; Applications that display the NEXTSTEP user interface are driven by events from the keyboard and mouse.&nbsp; Every touch of a key or click of the mouse generates events that the application receives and responds to.&nbsp; An object-oriented program structure (a network of objects that's prepared to respond to an external stimulus) is ideally suited for this kind of user-driven application.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Aggregation and Decomposition</b></font>

<p><font face="Times">Another part of the design task is deciding the arrangement of classes--when to add functionality to an existing class by defining a subclass and when to define an independent class.&nbsp; The problem can be clarified by imagining what would happen in the extreme case:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's possible to conceive of a program consisting of just one object.&nbsp; Since it's the only object, it can send messages only to itself.&nbsp; It therefore can't take advantage of polymorphism, or the modularity of a variety of classes, or a program design conceived as a network of interconnected objects.&nbsp; The true structure of the program would be hidden inside the class definition.&nbsp; Despite being written in an object-oriented language, there would be very little that was object-oriented about it.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">On the other hand, it's also possible to imagine a program that consists of hundreds of different kinds of objects, each with very few methods and limited functionality.&nbsp; Here, too, the structure of the program would be lost, this time in a maze of object connections.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Obviously, it's best to avoid either of these extremes, to keep objects large enough to take on a substantial role in the program but small enough to keep that role well-defined.&nbsp; The structure of the program should be easy to grasp in the pattern of object connections.</font>

<p><font face="Times">Nevertheless, the question often arises of whether to add more functionality to a class or to factor out the additional functionality and put it in an separate class definition.&nbsp; For example, a Faucet needs to keep track of how much water is being used over time. To do that, you could either implement the necessary methods in the Faucet class, or you could devise a generic Meter object to do the job, as suggested earlier.&nbsp; Each Faucet would have an outlet connecting it to a Meter, and the Meter would not interact with any object but the Faucet.</font>

<p><font face="Times">The choice often depends on your design goals.&nbsp; If the Meter object could be used in more than one situation, perhaps in another project entirely, it would increase the reusability of your code to factor the metering task into a separate class.&nbsp; If you have reason to make Faucet objects as self-contained as possible, the metering functionality could be added to the Faucet class.</font>

<p><font face="Times">It's generally better to try to for reusable code and avoid having large classes that do so many things that they can't be adapted to other situations.&nbsp; When objects are designed as components, they become that much more reusable.&nbsp; What works in one system or configuration might well work in another.</font>

<p><font face="Times">Dividing functionality between different classes doesn't necessarily complicate the programming interface.&nbsp; If the Faucet class keeps the Meter object private, the Meter interface wouldn't have to be published for users of the Faucet class; the object would be as hidden as any other intrinsic Faucet instance variable.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Models and Kits</b></font>

<p><font face="Times">Objects combine state and behavior, and so resemble things in the real world.&nbsp; Because they resemble real things, designing an object-oriented program is very much like thinking about real things--what they do, how they work, and how one thing is connected to another.</font>

<p><font face="Times">When you design an object-oriented program, you are, in effect, putting together a computer simulation of how something works. Object networks look and behave like models of real systems.&nbsp; An object-oriented program can be thought of as a model, even if there's no actual counterpart to it in the real world.</font>

<p><font face="Times">Each component of the model--each kind of object--is described in terms of its behavior and responsibilities and its interactions with other components.&nbsp; Because an object's interface lies in its methods, not its data, you can begin the design process by thinking about what a system component will do, not how it's represented in data.&nbsp; Once the behavior of an object is decided, the appropriate data structure can be chosen, but this is a matter of implementation, not the initial design.</font>

<p><font face="Times">For example, in the water-use program, you wouldn't begin by deciding what the Faucet data structure looked like, but what you wanted a Faucet to do--make a connection to a WaterPipe, be turned on and off, adjust the rate of flow, and so on.&nbsp; The design is therefore not bound from the outset by data choices.&nbsp; You can decide on the behavior first, and implement the data afterwards. Your choice of data structures can change over time without affecting the design.</font>

<p><font face="Times">Designing an object-oriented program doesn't necessarily entail writing great amounts of code.&nbsp; The reusability of class definitions means that the opportunity is great for building a program largely out of classes devised by others.&nbsp; It might even be possible to construct interesting programs entirely out of classes someone else defined.&nbsp; As the suite of class definitions grows, you have more and more reusable parts to choose from.</font>

<p><font face="Times">Reusable classes come from many sources.&nbsp; Development projects often yield reusable class definitions, and some enterprising developers have begun marketing them.&nbsp; Object-oriented programming environments typically come with class libraries.&nbsp; There are well over a hundred classes in the NEXTSTEP libraries.&nbsp; Some of these classes offer basic services (hashing, data storage, remote messaging).&nbsp; Others are more specific (user interface devices, video displays, a sound editor).</font>

<p><font face="Times">Typically, a group of library classes work together to define a partial program structure.&nbsp; These classes constitute a software kit that can be used to build a variety of different kinds of applications.&nbsp; When you use a kit, you accept the program model it provides and adapt your design to it.&nbsp; You use the kit by:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Initializing and arranging instances of kit classes,</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Defining subclasses of kit classes, and</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Defining new classes of your own to work with classes defined in the kit.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">In each of these ways, you not only adapt your program to the kit, but you also adapt the generic kit structure to the specialized purposes of your particular application.</font>

<p><font face="Times">The kit, in essence, sets up part of a object network for your program and provides part of its class hierarchy.&nbsp; Your own code completes the program model started by the kit.</font>

<p><font face="Times">Chapter 5, &quot;Programming in Objective C,&quot; has more on the NEXTSTEP software kits and how to work with them.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>Structuring the Programming Task</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Object-oriented programming not only structures programs in a new way, it also helps structure the programming task.</font>

<p><font face="Times">As software tries to do more and more, and programs become bigger and more complicated, the problem of managing the task also grows.&nbsp; There are more pieces to fit together and more people working together to build them.&nbsp; The object-oriented approach offers ways of dealing with this complexity, not just in design, but also in the organization of the work.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Collaboration</b></font>

<p><font face="Times">Complex software requires an extraordinary collaborative effort among people who must be individually creative, yet still make what they do fit exactly with what others are doing.</font>

<p><font face="Times">The sheer size of the effort and the number of people working on the same project at the same time in the same place can get in the way of the group's ability to work cooperatively towards a common goal.&nbsp; In addition, collaboration is often impeded by barriers of time, space, and organization.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Code must be maintained, improved, and used long after it's written.&nbsp; Programmers who collaborate on a project may not be working on it at the same time, so may not be in a position to talk things over and keep each other informed about details of the implementation.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Even if programmers work on the same project at the same time, they may not be located in the same place.&nbsp; This also inhibits how closely they can work together.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Programmers working in different groups with different priorities and different schedules often must collaborate on projects. Communication across organizational barriers isn't always easy to achieve.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The answer to these difficulties must grow out of the way programs are designed and written.&nbsp; It can't be imposed from the outside in the form of hierarchical management structures and strict levels of authority.&nbsp; These often get in the way of people's creativity, and become burdens in and of themselves.&nbsp; Rather, collaboration must be built into the work itself.</font>

<p><font face="Times">That's where object-oriented programming techniques can help.&nbsp; For example, the reusability of object-oriented code means that programmers can collaborate effectively even when they work on different projects at different times or are in different organizations, just by sharing their code in libraries.&nbsp; This kind of collaboration holds a great deal of promise, for it can conceivably lighten difficult tasks and bring impossible projects into the realm of possibility.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Organizing Object-Oriented Projects</b></font>

<p><font face="Times">Object-oriented programming helps restructure the programming task in ways that benefit collaboration.&nbsp; It helps eliminated the need to collaborate on low-level implementation details, while providing structures that facilitate collaboration at a higher level. Almost every feature of the object model, from the possibility of large-scale design to the increased reusability of code, has consequences for the way people work together.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Designing on a Large Scale</b></font>

<p><font face="Times">When programs are designed at a high level of abstraction, the division of labor is more easily conceived.&nbsp; It can match the division of the program on logical lines; the way a project is organized can grow out of its design.</font>

<p><font face="Times">With an object-oriented design, it's easier to keep common goals in sight, instead of losing them in the implementation, and easier for everyone to see how the piece they're working on fits into the whole.&nbsp; Their collaborative efforts are therefore more likely to be on target.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Separating the Interface from the Implementation</b></font>

<p><font face="Times">The connections between the various components of an object-oriented program are worked out early in the design process. They can be well-defined, at least for the initial phase of development, before implementation begins.</font>

<p><font face="Times">During implementation, only this interface needs to be coordinated, and most of that falls naturally out of the design.&nbsp; Since each class encapsulates its implementation and has its own name space, there's no need to coordinate implementation details. Collaboration is simpler when there are fewer coordination requirements.&nbsp; The easiest problems to manage are the ones that are avoided.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Modularizing the Work</b></font>

<p><font face="Times">The modularity of object-oriented programming means that the logical components of a large program can each be implemented separately.&nbsp; Different people can work on different classes.&nbsp; Each implementation task is isolated from the others.</font>

<p><font face="Times">This has benefits, not just for organizing the implementation, but for fixing problems later.&nbsp; Since implementations are contained within class boundaries, problems that come up are also likely to be isolated.&nbsp; It's easier to track down bugs when they're located in a well-defined part of the program.</font>

<p><font face="Times">Separating responsibilities by class also means that each part can be worked on by specialists.&nbsp; Classes can be updated periodically to optimize their performance and make the best use of new technologies.&nbsp; These updates don't have to be coordinated with other parts of the program.&nbsp; As long as the interface to an object doesn't change, improvements to its implementation can be scheduled at any time.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Keeping the Interface Simple</b></font>

<p><font face="Times">The polymorphism of object-oriented programs yields simpler programming interfaces, since the same names and conventions can be reused in any number of different classes.&nbsp; The result is less to learn, a greater shared understanding of how the whole system works, and a simpler path to cooperation and collaboration.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Making Decisions Dynamically</b></font>

<p><font face="Times">Because object-oriented programs make decisions dynamically at run time, less information needs to be supplied at compile time (in source code) to make two pieces of code work together.&nbsp; Consequently, there's less to coordinate and less to go wrong.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Inheriting Generic Code</b></font>

<p><font face="Times">Inheritance is a way of reusing code.&nbsp; If you can define your classes as specializations of more generic classes, your programming task is simplified.&nbsp; The design is simplified as well, since the inheritance hierarchy lays out the relationships between the different levels of implementation and makes them easier to understand.</font>

<p><font face="Times">Inheritance also increases the reusability and reliability of code.&nbsp; The code placed in a superclass is tested by all its subclasses. The generic class you find in a library will have been tested by other subclasses written by other developers for other applications.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>Reusing Tested Code</b></font>

<p><font face="Times">The more software you can borrow from others and incorporate in your own programs, the less you have to do yourself.&nbsp; There's more software to borrow in an object-oriented programming environment, because the code is more reusable.&nbsp; Collaboration between programmers working in different places for different organizations is enhanced, while the burden of each project is eased.</font>

<p><font face="Times">Classes and kits from an object-oriented library can make substantial contributions to your program.&nbsp; When you program with the NEXTSTEP software kits, for example, you're effectively collaborating with the programmers at NeXT; you're contracting a part of your program, often a substantial part, to them.&nbsp; You can concentrate on what you do best and leave other tasks to the library developer.&nbsp; Your projects can be prototyped faster, completed faster, with less of a collaborative challenge at your own site.</font>

<p><font face="Times">The increased reusability of object-oriented code also increases its reliability.&nbsp; A class taken from a library is likely to have found its way into a variety of different applications and situations.&nbsp; The more the code has been used, the more likely it is that problems will have been encountered and fixed.&nbsp; Bugs that would have seemed strange and hard to find in your program might already have been tracked down and eliminated.</font></td></tr>

</table>



<p>

</body>
</html>
