<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/Concepts/Pre3.0_Concepts/04_Drawing.rtfd -->
<!-- Date: Sun Jun 28 19:37:14 1998 -->
<head>
<title>04_Drawing</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Release 3.3 Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Helvetica" size="+3"><b>4</b></font></td>

<td><font face="Times" size="+3"><i>Drawing</i></font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Changes made for the current release of NeXTstep affect the information presented in this chapter.&nbsp; For details see:</b></font>

<p><img src="../../Images/sp.gif" width=19 height=1><font face="Times"><b>/NextLibrary/Documentation/NextDev/ReleaseNotes/WindowServer.rtf</b></font><br>
<img src="../../Images/sp.gif" width=19 height=1><font face="Times"><b>/NextLibrary/Documentation/NextDev/ReleaseNotes/AppKit.rtf</b></font>

<p><br><br><br>

<p><font face="Times">All of your program's visual output, whether sent to the laser printer or displayed on the screen, is generated through the PostScript language, a high-level, interpreted language with special facilities for drawing and handling graphic images, including text.&nbsp; The PostScript language has typically been used to produce high-quality images on the printed page.&nbsp; On the NeXT computer, it's also used for imaging on the screen.&nbsp; NeXT and Adobe Systems Incorporated have jointly developed the Display PostScript system, which refines the language and adapts it to the interactive requirements of the screen.</font>

<p><font face="Times">Because the NeXT computer creates both screen and printed images through the same language, the screen can display a document just as it will be printed.&nbsp; Except for differences in resolution, what you see is what you get.</font>

<p><font face="Times">Applications draw within windows--screen rectangles that can be moved, resized, and layered on top of each other--rather than directly on the screen.&nbsp; The NeXT window system is implemented as an extension to the Display PostScript system.&nbsp; At the most fundamental level, applications create and manage windows through PostScript operators.&nbsp; However, the Application Kit provides an object-oriented interface to the window system that most applications should use; the Kit handles basic window-management tasks for you.</font>

<p><font face="Times">NeXT has made other extensions to the Display PostScript system so that applications can better use the capabilities of the window system and MegaPixel Display.&nbsp; The principal additions permit compositing, drawing with partially transparent paint, and instance drawing:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Compositing builds a new image by overlaying images that were previously drawn.&nbsp; It's analogous to a photographer printing a picture from two negatives, one placed on top of the other.&nbsp; However, on the NeXT computer there are even more ways that each of the images you start with can contribute to the composite.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">All image-transferring operations, including simply copying an image from one location to another, are accomplished through compositing.&nbsp; Compositing is the only way to copy on the NeXT computer.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Compositing can achieve interesting effects when the initial images are drawn with partially transparent paint.&nbsp; In a typical compositing operation, paint that's partially transparent won't completely cover the image it's placed on top of; some of the other image will show through.&nbsp; The more transparent the paint is, the more of the other image you'll see.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">You can set the <i>coverage</i> of the paint you draw with--how transparent or opaque it is--just as you set its color or gray level.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Instance drawing puts temporary images on the screen, and removes them again, at little processing cost.&nbsp; When instance drawing is removed, the original images are automatically restored.&nbsp; Instance drawing is useful for temporarily highlighting an image, for showing an object being dragged from one location to another, and for other kinds of dynamic drawing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All operators added to the Display PostScript system by NeXT are described in detail in the <i>NeXTstep Reference, Volume 2</i>.&nbsp; The Display PostScript system is documented in four publications by Adobe Systems Incorporated--<i>PostScript Language Extensions for the Display PostScript System</i>, <i>Client Library Reference Manual</i>, <i>pswrap Reference Manual</i>, and <i>Perspective for Software Developers</i>.&nbsp; The PostScript language itself is described in the <i>PostScript Language Reference Manual</i> by Adobe Systems Incorporated, published by Addison-Wesley.&nbsp; A beginning guide to the language and a series of example graphics programs are provided in the <i>PostScript Language Tutorial and Cookbook</i>, by the same author and publisher.</font>

<p><font face="Times">This chapter discusses drawing on the NeXT computer using the Display PostScript system and its extensions.&nbsp; In addition to transparency, compositing, and instance drawing, it describes how drawing works in the NeXT window system and on the MegaPixel Display.</font>

<p><font face="Times">Later chapters--Chapters 6, &quot;Program Structure,&quot; 7, &quot;Program Dynamics,&quot; and 9, &quot;User-Interface Objects&quot;--discuss drawing in the broader context of the Application Kit.&nbsp; The Kit defines objects that draw the graphic elements of the NeXT user interface, including scrollers, switches, sliders, menus, and user-editable text; you don't need to write this PostScript code yourself.&nbsp; You can therefore focus your attention on drawing that's unique to your application.&nbsp; The drawing code you write will be integrated into the object-oriented program structure provided by the Kit, and will use the Display PostScript system and the extensions to it discussed in this chapter.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Design Philosophy</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When one imaging model is used for the printer and another for the screen, application programs must pursue two parallel lines of development.&nbsp; In addition to the extra work, it's nearly impossible to make screen and printed images match.</font>

<p><font face="Times">The NeXT computer avoids these problems by using a single imaging model, the PostScript language, for all drawing. The PostScript language is well-suited to this role because:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's device independent.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's programmable.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It provides a complete two-dimensional imaging model.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's a widely used standard on printers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Extensions to the PostScript language are the foundation for the NeXT window system.&nbsp; Drawing instructions and window management operations are both sent to the same interpreter.&nbsp; Because of this integration, you'll have fewer issues to worry about as you program your application.</font>

<p><font face="Times">Drawing on the screen has dynamic aspects that are missing when drawing for the printer:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's interactive.&nbsp; Applications must follow the user's instructions and respond graphically to the user's actions.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It changes over time.&nbsp; Applications can repeatedly reuse the same area of a window by erasing and replacing what's displayed there.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It uses a number of different windows simultaneously.&nbsp; Instead of drawing one page at a time, applications present the user with a multi-windowed interface.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These aspects present applications with both challenges and opportunities.&nbsp; One challenge is speed.&nbsp; To meet it, the Display PostScript system has been refined to respond quickly, without losing any of the original generality and power of the PostScript language.&nbsp; In a few cases, operators have been added so that common operations can be executed more efficiently.</font>

<p><font face="Times">Another challenge is programming simplicity.&nbsp; This challenge is met mainly by relieving applications of bothersome chores:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Much of your program's drawing can be done through Application Kit objects that have the ability to draw themselves.&nbsp; Common drawing operations such as scrolling, resizing, clipping, and erasing are also handled through Application Kit objects.&nbsp; In addition, the Kit has facilities that make it relatively easy to use bitmaps and icons.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Window Server handles the dynamic behavior of windows.&nbsp; It moves and resizes them in response to user actions, without your program's intervention.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Window Server provides windows with backup buffers so that it can automatically save images when a window is hidden, and automatically restore them again when the window becomes visible once more.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Buffering also makes it possible to draw into windows that never appear on-screen.&nbsp; The images that are cached in off-screen windows can then be copied to windows on-screen, using the same operators that transfer images between on-screen windows.</font>

<p><font face="Times">NeXT has adopted an advanced model for moving and combining images.&nbsp; Compositing and transparency make it possible for programs to explore new visual effects, such as slowly dissolving one image into another and building a final image out of several layers.&nbsp; With window buffering, they make animation fairly simple.&nbsp; NeXT compositing is fully compatible with color graphics, so you won't have to redesign your program for a color screen.&nbsp; Compositing is implemented as an extension to the PostScript language, but it's also possible to composite in Objective-C code using the Bitmap object of the Application Kit.</font>

<p><font face="Times">To help applications provide immediate feedback to users, NeXT has also augmented the PostScript language with instance drawing.&nbsp; Images that are drawn in this mode are temporary; when they're removed, the original image reappears.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>The Screen</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The first part of this section briefly covers some background terminology.&nbsp; The parts that follow introduce drawing on the NeXT MegaPixel Display.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Pixels, Halftones, and Rectangular Coordinates</b></font>

<p><font face="Times">Images on the screen are formed from tiny picture elements, or <i>pixels</i>, arranged in a rectangular grid of columns and rows that fill the entire surface of the screen.&nbsp; Because of their positions in the grid, pixels can be thought of as little square dots.&nbsp; Each pixel has a separate representation in screen memory and can be assigned an independent color value.&nbsp; Varying the color of the individual pixels makes it possible to render an almost unlimited variety of images on the screen.</font>

<p><font face="Times">Typically, a pixel on a monochrome computer screen is capable of showing just two colors:&nbsp; either black or white.&nbsp; A black line is rendered by turning all the pixels along its path black; a white circle has all the pixels within its radius turned white.&nbsp; Intermediate shades of gray are rendered by <i>halftoning</i>, turning some pixels black and others white.&nbsp; A mixed pattern of adjacent black and white pixels appears as a solid, uniformly colored gray area.&nbsp; Figure 4-1 is a close-up diagram of a halftone gray area.&nbsp; The lines represent the pixel grid; the spaces between the lines represent individual pixels.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F1.gif" width=257 height=220></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-1</b></font><font face="Times">.&nbsp; Halftone with Black and White Pixels</font>

<p><br><br>

<p><font face="Times">Locations on the screen are described using a standard rectangular (Cartesian) coordinate system.&nbsp; Points are identified by their position relative to a horizontal x-axis and a vertical y-axis.&nbsp; The origin, where the two axes meet, is (0, 0).&nbsp; A point 500 pixels to the right of the origin as measured along the x-axis and 200 pixels above the origin as measured along the y-axis is (500, 200).&nbsp; Negative coordinates locate points below the x-axis and to the left of the y-axis.</font>

<p><font face="Times">The <i>resolution</i> of an image is a function of pixel density.&nbsp; The more pixels there are in a given area (that is, the smaller they are), the more detailed and precise the image can be.&nbsp; Computer screens have a lower resolution (fewer pixels per inch) than do laser printers.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The NeXT Computer Screen</b></font>

<p><font face="Times">The visible area on the MegaPixel Display screen holds nearly a million pixels, 1120 along each horizontal row and 832 in each vertical column.&nbsp; There are about 92 pixels per inch in each direction (91.80 per inch along the x-axis and 92.44 along the y-axis when the display is exactly 12.2 inches by 9 inches, but these dimensions may vary by</font> <img src="../../Images/cB1.gif" width=8 height=9><font face="Times">0.100 inch).</font>

<p><font face="Times">Pixels on the NeXT monochrome screen aren't limited to just black and white; each one can also display two shades of gray, for a total of four discrete colors:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">white</font><br>
<font face="Times">light gray</font><br>
<font face="Times">dark gray</font><br>
<font face="Times">black</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This reduces the need for halftoning while increasing the number of halftone shades.&nbsp; Where halftones are used, there's less variation in the color of adjacent pixels, so the screen can show purer, less granular shades of gray.&nbsp; Transitions from one shade of gray to another in continuous-tone images are smoother.&nbsp; Contrasts between a shade of gray and either black or white are sharper, since the gray can be rendered with fewer, if any, black or white pixels.</font>

<p><font face="Times">Figure 4-2 shows the same shade of halftone gray as Figure 4-1, only rendered with light gray rather than black pixels. Note that Figure 4-2 has three times as many nonwhite pixels, all closer to the desired shade of gray than the black pixels in Figure 4-1.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F2.gif" width=257 height=220></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-2</b></font><font face="Times">.&nbsp; Halftone with Gray and White Pixels</font>

<p><br><br>

<p><font face="Times">Each pixel requires two bits of memory to distinguish the four colors.&nbsp; When needed, two additional bits are set aside to store the coverage of the pixel--how transparent or opaque it is.&nbsp; (See &quot;Compositing and Transparency,&quot; later in this chapter.)&nbsp; Halftoning produces intermediate &quot;shades&quot; of coverage, just as it produces intermediate shades of gray.</font>

<p><font face="Times">To avoid halftoning on the MegaPixel Display, you can set the gray level to a value that results in pure black, pure white, or a pure gray.&nbsp; These four C constants are defined to the required values:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">NX_WHITE</font><br>
<font face="Times">NX_LTGRAY</font><br>
<font face="Times">NX_DKGRAY</font><br>
<font face="Times">NX_BLACK</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In the PostScript language, values specified to three decimal places work:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">white</font></td>

<td><font face="Times">1.0</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">light gray</font></td>

<td><font face="Times">0.667</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">dark gray</font></td>

<td><font face="Times">0.333</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">black</font></td>

<td><font face="Times">0.0</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Screen Coordinates</b></font>

<p><font face="Times">The entire screen can be thought of as the first (upper right) quadrant of a two-dimensional coordinate grid, with the origin in the lower left corner and the positive x-axis extending horizontally to the right and the positive y-axis extending vertically upward.&nbsp; A unit along either axis is equal to the distance across one pixel, approximately 1/92 inch.</font>

<p><font face="Times">Figure 4-3 illustrates this <i>screen coordinate system</i>.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F3.gif" width=231 height=207></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-3</b></font><font face="Times">.&nbsp; The Screen Coordinate System</font>

<p><br><br>

<p><font face="Times">Coordinates are specified as floating-point numbers.&nbsp; This permits you to move anywhere on the screen, not just from pixel to pixel.&nbsp; Coordinates that are integers--those that have no fractional part--lie between pixels in the screen coordinate system; fractional coordinates locate points somewhere within a pixel.&nbsp; Figure 4-4 indicates where four sample points are located in relation to pixel boundaries.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F4.gif" width=190 height=127></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-4</b></font><font face="Times">.&nbsp; Points and Pixels</font>

<p><br><br>

<p><font face="Times">&quot;Imaging Conventions&quot; below explains how fractional coordinates and lines that cut through pixels are handled on-screen.</font>

<p><font face="Times">The screen coordinate system has just one function:&nbsp; to position windows on the screen.&nbsp; When your application creates a new window, it must specify the window's initial size and location in screen coordinates.&nbsp; For drawing in a window, it will use a different coordinate system, one that's specific to the window (see &quot;Window Coordinates&quot; below).</font>

<p><font face="Times">No matter where a window is located, its edges are always aligned on pixel boundaries.&nbsp; If you try to position a window using fractional coordinates, they will be adjusted to whole integers.&nbsp; Fractional coordinates can be freely used when drawing within a window, however.</font>

<p><font face="Times">As Figure 4-3 above illustrates, the screen coordinate system extends beyond the screen in all directions.&nbsp; However, its range is not unlimited.&nbsp; No screen coordinate (no point within a window) can have a value greater than 16000 or less than</font> <img src="../../Images/c2D.gif" width=8 height=4><font face="Times">16000:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">(</font><img src="../../Images/c2D.gif" width=8 height=4><font face="Times">16000</font> <img src="../../Images/cA3.gif" width=8 height=9> <font face="Times"><i>x</i></font> <img src="../../Images/cA3.gif" width=8 height=9> <img src="../../Images/c2B.gif" width=8 height=7><font face="Times">16000,</font> <img src="../../Images/c2D.gif" width=8 height=4><font face="Times">16000</font> <img src="../../Images/cA3.gif" width=8 height=9> <font face="Times"><i>y</i></font> <img src="../../Images/cA3.gif" width=8 height=9> <img src="../../Images/c2B.gif" width=8 height=7><font face="Times">16000)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All windows must fit within the space bounded by</font> <img src="../../Images/cB1.gif" width=8 height=9><font face="Times">16000.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Window Coordinates</b></font>

<p><font face="Times">The reference coordinate system for a window is known as the <i>base coordinate system.</i>&nbsp; It differs from the screen coordinate system in only two ways:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It applies only to a particular window; each window has its own base coordinate system.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Its origin is at the lower left corner of the window, rather than the lower left corner of the screen.&nbsp; If the window moves, the origin and the entire coordinate system move with it.&nbsp; An image retains its position within a window's coordinate system no matter where the window is located.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In PostScript language terms, the base coordinate system is the equivalent to a &quot;default user space&quot; for the window.&nbsp; It provides a starting place for programs that draw within a window, just as the default user space provides a starting place for programs that describe pages for a printer.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">You can also establish a reference coordinate system with the same coordinate units as the default user space, 1/72 inch.&nbsp; However, this documentation assumes the base coordinate system for all windows.&nbsp; The base coordinate system is more convenient for drawing on the screen, since coordinate units fall on pixel boundaries.&nbsp; It's also the initial coordinate system established for all windows created through the Application Kit.&nbsp; (For more information, see the discussion of the <b>windowdeviceround</b> and <b>windowdevice</b> operators in the <i>NeXTstep Reference</i> manual.)</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Modifying the Coordinate System</b></font>

<p><font face="Times">You're not limited to the base coordinate system when you draw within a window.&nbsp; PostScript operators can radically transform the window's coordinates.&nbsp; The origin can be moved (by the <b>translate</b> operator), the x- and y-axes can be turned to point in any direction (by the <b>rotate</b> operator), and the size of a unit along either the x- or y-axis can be expanded or shrunk (by the <b>scale</b> operator).&nbsp; The base coordinate system is simply the reference system for any subsequent transformations by PostScript operators.</font>

<p><font face="Times">PostScript transformations apply only within a window.&nbsp; They don't alter the screen coordinate system, and therefore can't affect the size or location of the window itself.</font>

<p><font face="Times">When you draw, coordinates are expressed in the application's <i>current coordinate system</i>, the system reflecting the last coordinate transformations to have taken place within the current window.&nbsp; The PostScript interpreter keeps track of this system through the current transformation matrix (CTM) of the current graphics state.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>View Coordinates</b></font>

<p><font face="Times">Drawing is usually limited to areas that are smaller than the whole window.&nbsp; The Application Kit permits you to set up rectangular regions within a window and to move and resize them, much as windows themselves are moved and resized on the screen.&nbsp; The Kit provides each region--or &quot;View,&quot; after the Objective-C class that defines them--with a coordinate system, which it makes the application's current coordinate system before you draw.&nbsp; This coordinate system is a transformation of the base coordinate system and has a more convenient origin, at the lower left corner of the area you're drawing in.&nbsp; Figure 4-5 illustrates the relationship between the base coordinate system and the default coordinate system provided for a View.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="../../Images/F6.gif" width=271 height=211></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-5</b></font><font face="Times">.&nbsp; Window and View Coordinates</font>

<p><br><br>

<p><font face="Times">You can use Application Kit methods or PostScript operators, or both, to further modify these default coordinates.&nbsp; See Chapters 6 and 7 for more on Views.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Borders and Content Areas</b></font>

<p><font face="Times">The initial size of a window is determined by parameters that specify its width (along the x-axis) and its height (along the y-axis) in the screen coordinate system.&nbsp; These two parameters define the window's initial <i>content area</i>, the area that's available for drawing.&nbsp; The window's initial location is set by parameters that specify the lower left corner of the content area.</font>

<p><font face="Times">Windows typically have a title bar above the content area and a border around both the content area and title bar.&nbsp; Often they also have a resize bar below the content area and inside the border.&nbsp; (Some windows may have a border but lack a title bar and resize bar; some lack even the border.)</font>

<p><font face="Times">The window border, title bar, and resize bar lie outside the requested window area.&nbsp; If you ask the Application Kit to create a titled window 100 pixels wide and 100 pixels high, the window border and title bar will surround the 100-by-100 square you asked for.&nbsp; The point where you locate the window will correspond to the lower left corner of the square, inside the border.&nbsp; The border, title bar, and content area all lie inside the window, and share the window's coordinate system.</font>

<p><font face="Times">Figure 4-6 is a close-up view of the corner of a titled window created at (50.0, 300.0) in the screen coordinate system. The window border is just one pixel wide.&nbsp; The point where the window was located becomes the origin of the initial drawing coordinates within the content area (the coordinate origin for a View that fills the content area).&nbsp; The origin of the base coordinate system lies at the lower left corner of the window itself, outside the border.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F6.gif" width=346 height=190></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-6</b></font><font face="Times">.&nbsp; Window Corner</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Printing Coordinates</b></font>

<p><font face="Times">When a screen image is printed by the NeXT 400 dpi Laser Printer, or by any other PostScript printer, one unit within the base or screen coordinate system (that is, one pixel) translates to 1/72 inch, equal to about one typographical point. Since a screen pixel is smaller, approximately 1/92 inch, the screen shows images at just over three-fourths their printed size.&nbsp; This reduction permits a full 8 1/2-by-11-inch page to be shown on the screen from top to bottom, without scaling the window's coordinate system.</font>

<p><font face="Times">This doesn't mean that an image must always be shown on the screen at three-fourths its printed size.&nbsp; It's possible, for example, to use the PostScript <b>scale</b> operator to &quot;magnify&quot; the image on the screen, then print the image without the scaled magnification.&nbsp; The screen version could actually be larger than the unmagnified printed version.</font>

<p><font face="Times">Laser printers produce images with many more pixels per inch than do screen displays.&nbsp; The NeXT laser printer prints either 300 or 400 pixels per inch, depending on the setting.&nbsp; Printed images, therefore, have a higher resolution and are portrayed in more detail than screen images.</font>

<p><font face="Times">For example, a vertical line with a specified width of one unit within the base coordinate system can be shown on the screen as a thin rectangle just one pixel wide.&nbsp; When the line is printed, it will look almost 28% larger and have a width of at least four printer pixels.&nbsp; Setting the width of this line to less than 1--to 0.25, for example--will have no effect on the dimensions of the line on-screen, but will make the line thinner when it's printed.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Rectangles</b></font>

<p><font face="Times">It's often necessary to limit a PostScript operation, or drawing in general, to a particular area of the screen.&nbsp; These areas are most often specified as rectangles:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A window is a rectangle in the screen coordinate system.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Several PostScript operators, such as the compositing operators discussed under &quot;Compositing and Transparency&quot; below, act on rectangles within windows.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Application Kit uses rectangles extensively to designate particular areas--called &quot;Views&quot;--where drawing can occur inside windows (see Chapter 6 for details).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">On the NeXT computer, a rectangle is a combination of a point and an extent.&nbsp; The point locates the rectangle by assigning it x and y values within a coordinate system.&nbsp; The extent specifies the size of the rectangle--its width as measured in a direction parallel to the x-axis and its height as measured in a direction parallel to the y-axis.&nbsp; The width and height are measured from the point that locates the rectangle.</font>

<p><font face="Times">This way of specifying a rectangle has one consequence of note:&nbsp; A rectangle is aligned with its coordinate system; the sides of the rectangle are parallel to the coordinate axes.&nbsp; Figure 4-7 illustrates a rectangle with the orientation of the base or screen coordinate system.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F7.gif" width=201 height=133></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-7</b></font><font face="Times">.&nbsp; Rectangle</font>

<p><br><br>

<p><font face="Times">PostScript operators take four parameters to specify a rectangle.&nbsp; An example is <b>rectfill</b>, which fills a rectangle with the current color:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times"><i>x y width height</i> <b>rectfill</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In the Application Kit, rectangles are specified as C structures of type NXRect.&nbsp; The NeXT header file <b>event.h</b> (in the <b>dpsclient</b> subdirectory of <b>/usr/include</b>) defines the elements that make up an NXRect structure:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Since all coordinate values must be specified by floating-point numbers, it defines NXCoord as a <b>float</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">typedef float&nbsp;&nbsp; NXCoord;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A pair of NXCoord variables--one for the x coordinate and one for the y coordinate--designate a point:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">typedef struct _NXPoint {</font><br>
<img src="../../Images/sp.gif" width=171 height=1><font face="Courier" size="-1">NXCoord&nbsp;&nbsp;&nbsp;&nbsp; x;</font><br>
<img src="../../Images/sp.gif" width=171 height=1><font face="Courier" size="-1">NXCoord&nbsp;&nbsp;&nbsp;&nbsp; y;</font><br>
<img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">} NXPoint;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A pair of NXCoord variables also designate the size of a rectangle:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">typedef struct _NXSize {</font><br>
<img src="../../Images/sp.gif" width=171 height=1><font face="Courier" size="-1">NXCoord&nbsp;&nbsp;&nbsp;&nbsp; width;</font><br>
<img src="../../Images/sp.gif" width=171 height=1><font face="Courier" size="-1">NXCoord&nbsp;&nbsp;&nbsp;&nbsp; height;</font><br>
<img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">} NXSize;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The NeXT header file <b>graphics.h</b> (in the <b>appkit</b> subdirectory) combines NXPoint and NXSize structures to define the rectangle itself:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct _NXRect {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXPoint&nbsp;&nbsp;&nbsp;&nbsp; origin;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} NXRect;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The values in an NXSize structure should never be negative; for the Application Kit, the width and height of a rectangle must be positive (or 0.0).&nbsp; This means that the point that locates a rectangle (<b>origin</b>) will have the smallest coordinate values of any point in the rectangle.&nbsp; The extent of a rectangle is measured in positive directions from its origin.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Rectangle Geometry</b></font>

<p><font face="Times">From a pair of rectangles within the same coordinate system, it's possible to calculate a third rectangle, their <i>union</i>, the smallest rectangle that completely encloses them both.</font>

<p><font face="Times">It's often also possible to calculate a fourth rectangle, their <i>intersection</i>.&nbsp; Two rectangles are said to intersect if they have any area in common.&nbsp; Since rectangles within the same coordinate system have parallel sides, this area will also be a rectangle.</font>

<p><font face="Times">Rectangular union and intersection are illustrated in Figure 4-8.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F8.gif" width=339 height=267></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-8</b></font><font face="Times">.&nbsp; Union and Intersection of Rectangles</font>

<p><br><br>

<p><font face="Times">When passed pointers to two NXRect structures, <b>NXIntersectRect()</b> returns YES if the two rectangles intersect and NO if they don't.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; overlap;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">overlap = NXIntersectRect(&amp;rect1, &amp;rect2);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the two rectangles intersect, you can use <b>NXIntersectionRect()</b> to calculate the area that overlaps.&nbsp; It will place the intersection in the structure specified by its second argument and return a pointer to the same structure.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; *smallrect;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">smallrect = NXIntersectionRect(&amp;rect1, &amp;rect2);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the two rectangles don't overlap, <b>NXIntersectionRect()</b> returns a NULL pointer and doesn't modify either of the rectangles it's passed.</font>

<p><font face="Times"><b>NXUnionRect()</b> is similar to <b>NXIntersectionRect()</b>.&nbsp; It places the union of the two rectangles in the structure specified by its second argument and returns a pointer to the structure.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; *bigrect;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">bigrect = NXUnionRect(&amp;rect1, &amp;rect2);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXUnionRect()</b> and <b>NXIntersectionRect()</b> perform two of the most common calculations on rectangles.&nbsp; But there are also a number of other functions that modify NXRect structures in prescribed ways:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXSetRect()</b> initializes an NXRect structure.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXIntegralRect()</b> alters a given rectangle so that it has no fractional coordinates.&nbsp; If the coordinate system hasn't been scaled or rotated, it guarantees that the sides of the rectangle will lie on pixel boundaries.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times"><b>NXDivideRect()</b> slices a rectangle in two.&nbsp; You can specify the size of the slice and the side from which it should be taken.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXInsetRect()</b> calculates a rectangle that's inset from the one given.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXOffsetRect()</b> moves a rectangle by specified offsets along the x- and y-axes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Another function, <b>NXPointInRect()</b>, is used to determine whether a particular point (such as the location of the cursor) lies within a particular rectangle.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; inside;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">inside = NXPointInRect(&amp;point, &amp;rect);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">It returns YES if the point touches the rectangle, and NO if it doesn't.</font>

<p><font face="Times">All these functions are defined in the Application Kit.&nbsp; They're described in more detail in the <i>NeXTstep Reference </i>manuals.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>When a Rectangle Isn't Rectangular</b></font>

<p><font face="Times">The sides of a rectangle are always parallel to the x- and y-axes of its coordinate system.&nbsp; Since the coordinate axes are typically perpendicular to each other, the corners of a rectangle are, as expected, 90</font>&#176; <font face="Times">angles.</font>

<p><font face="Times">It's possible, however, to modify the PostScript coordinate system so that the axes intersect at an angle other than 90</font>&#176;<font face="Times">. A rectangle specified within such a coordinate system won't appear to be a rectangle at all.&nbsp; It will have the shape of a nonrectangular parallelogram; since its sides are parallel to the coordinate axes, they won't meet to form 90</font>&#176; <font face="Times">corners. This is illustrated in Figure 4-9.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F9.gif" width=367 height=259></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-9</b></font><font face="Times">.&nbsp; Nonrectangular Rectangle</font>

<p><br><br>

<p><font face="Times">The most straightforward way to produce a skewed coordinate system is with the following sequence of two PostScript transformations:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">Scale the coordinate system unequally.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">Rotate the coordinate axes into the scaled coordinates.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For example, Figure 4-9 above shows the approximate result of this PostScript code:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">2.0 1.0 scale</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">30.0 rotate</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">40.0 40.0 100.0 100.0 rectfill</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Here the <b>rectfill</b> operator produces a rectangle at (40.0, 40.0) with a width and height both equal to 100.0.&nbsp; In an unscaled, unrotated coordinate system, it would appear as an upright square.</font>

<p><font face="Times">Before the coordinate transformations in this example, the x-axis was horizontal and the y-axis was vertical; units along both axes had the same length.&nbsp; The <b>scale</b> operator stretched the length of a horizontal unit (measured along the x-axis) to twice the length of a vertical unit (measured along the y-axis).&nbsp; The <b>rotate</b> operator then altered the position of the x- and y-axes, but not the horizontal and vertical orientation of the scaling.&nbsp; Like anything else located in this scaled coordinate system, the x- and y-axes are stretched in a horizontal direction, and are thus pulled away from the perpendicular.&nbsp; Figure 4-10 illustrates what happened to the x-axis in the previous figure when it was rotated 30 in the scaled coordinate system.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F10.gif" width=369 height=222></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-10</b></font><font face="Times">.&nbsp; Rotated x-Axis in Scaled Coordinates</font>

<p><br><br>

<p><font face="Times">Although skewed coordinates turn rectangles into parallelograms, NeXT documentation refers to any area specified by a point and an extent as a &quot;rectangle,&quot; no matter what shape it has.&nbsp; When viewed from within a skewed coordinate system, a nonrectangular rectangle still has 90</font>&#176; <font face="Times">angles; it's nonrectangular only when viewed from the outside.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>The Window System</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The NeXT window system is grounded in extensions to the Display PostScript system.&nbsp; The extensions create windows, move and resize them, order them from front to back, direct drawing to them, associate events with them, remove them from the screen, and carry out other low-level window management tasks.</font>

<p><font face="Times">The Application Kit builds on these operators and provides an object-oriented programming interface to them.&nbsp; An application should create the windows it needs through the Kit.&nbsp; The Kit defines Window objects to manage windows, link them to an event-handling mechanism, and oversee the drawing that's done in them.&nbsp; Creating a Window object through the Kit produces a window to draw in and provides a structure that integrates the window into the application. The methods for creating and managing windows are discussed under &quot;Managing Windows&quot; in Chapter 6.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Window Numbers</b></font>

<p><font face="Times">Applications typically use a number of different Window objects and keep track of them through their object <b>id</b>s.&nbsp; The Window Server keeps track of windows by assigning each one a unique <i>window number</i> as an identifier.&nbsp; The window number is an <b>int</b> guaranteed to be greater than 0.</font>

<p><font face="Times">No two windows, even if they belong to different applications, will be assigned the same window number.&nbsp; However, when a window is destroyed, the Window Server may reuse its number.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Contexts and Graphics States</b></font>

<p><font face="Times">The Window Server can serve a large number of client applications; its PostScript interpreter interprets PostScript code concurrently for all running applications.</font>

<p><font face="Times">For each connection that it has to an application, the Window Server maintains an independent PostScript execution context.&nbsp; Figure 4-11 illustrates the context that each application sees.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F11.gif" width=328 height=257></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-11</b></font><font face="Times">.&nbsp; PostScript Execution Contexts</font>

<p><br><br>

<p><font face="Times">Every context has its own set of stacks, including an operand stack, graphics state stack, and dictionary stack.&nbsp; There are three built-in dictionaries in the dictionary stack.&nbsp; From top to bottom, they are <b>userdict</b>, <b>nextdict</b>, and <b>systemdict</b>. <b>userdict</b> is private to the context, while <b>nextdict</b> and <b>systemdict</b> are shared by all contexts.&nbsp; <b>nextdict</b> is a modifiable dictionary containing any dynamic information common to all applications, such as downloaded packages.&nbsp; <b>systemdict </b>is a read-only dictionary containing all the PostScript operators, both the standard ones and those implemented by NeXT.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>The Current Window</b></font>

<p><font face="Times">Each context has a current graphics state and graphics state stack.&nbsp; The current graphics state is a set of parameters that the PostScript interpreter uses when rendering images on the screen (or printed page).&nbsp; It includes parameters for such things as the current color, line width, clipping path, and dash pattern.</font>

<p><font face="Times">Three parameters are especially important to the window system:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current device, where drawing is to be rendered</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current transformation matrix (CTM), which maps the coordinate system the application is currently using to the device</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current clipping path, which defines the area where images can be rendered</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When drawing on the screen, the device is a window.&nbsp; The device of the current graphics state is the <i>current window</i>. PostScript painting operators, such as <b>stroke</b>, <b>fill</b>, and <b>show</b>, draw directly in the current window.&nbsp; You don't need the <b>showpage</b> or <b>copypage</b> operators to make images visible.</font>

<p><font face="Times">When the current graphics state is set to a new window device, the other two parameters also change:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current transformation matrix is initialized to the window's base coordinate system.&nbsp; (Thereafter, the <b>initmatrix </b>operator can be used to reestablishes this coordinate system.)</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current clipping path is set to a path around the window.&nbsp; (The <b>initclip</b> operator reestablishes this clipping path.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These changes ensure that drawing is confined to the current window and is in a coordinate system specific to the window.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Changing Graphics States</b></font>

<p><font face="Times">As users shift their attention from place to place on the screen, applications are required to shift the drawing focus from window to window and graphics state to graphics state.&nbsp; There can be only one current graphics state, and therefore only one current window, for each execution context.</font>

<p><font face="Times">The graphics state stack saves former graphics states that might later be restored.&nbsp; The <b>gsave</b> operator pushes the current graphics state on the stack and <b>grestore</b> replaces the current graphics state with one from the stack.&nbsp; This is illustrated in Figure 4-12.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F12.gif" width=297 height=178></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-12</b></font><font face="Times">.&nbsp; Graphics States</font>

<p><br><br>

<p><font face="Times">Because applications typically draw in many windows, it's possible for each graphics state on the stack to point to a different window device.</font>

<p><font face="Times">The stack saves graphics states in a particular order, but as users shift their attention on-screen, an application can be required to switch between graphics states in an order that the stack can't predict.&nbsp; Therefore, to simplify the task of switching between graphics states, the Display PostScript system permits graphic states to be saved not only on the stack, but also in individual graphics state objects.&nbsp; The <b>gstate</b> operator creates a new graphics state object and copies the current graphics state to it.&nbsp; The code below saves the current graphics state in an object named <b>foo</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/foo gstate def</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A graphics state object is not stored on the stack; the <b>gstate</b> operator allocates memory for it.&nbsp; Applications therefore tend not to create many graphics state objects for themselves, but reuse the ones they do create.</font>

<p><font face="Times">The <b>currentgstate</b> operator copies the current graphics state to a graphics state object, and the <b>setgstate</b> operator copies the graphics state recorded in a graphics state object to the current graphics state.&nbsp; These two operators are illustrated in Figure 4-12 above.&nbsp; They serve functions parallel to <b>gsave</b> and <b>grestore</b>.</font>

<p><font face="Times">At minimum, the Application Kit keeps one graphics state object for each window.&nbsp; The object identifies the window (as the device) and records its base coordinate system.&nbsp; Shifting the drawing focus from one window to another is a matter of first setting the current graphics state from the desired window's graphics state object and then altering parameters of the current graphics state as needed.&nbsp; Altering these parameters doesn't affect the graphics state object.</font>

<p><font face="Times">Additional graphics state objects can be assigned to facilitate shifting back and forth between particular graphics states within a window.&nbsp; For example, one object could be assigned to a text display and another to the scroller that scrolls the display.&nbsp; Views created through the Application Kit should be assigned graphic state objects using Kit methods rather than PostScript operators.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Window Buffering</b></font>

<p><font face="Times">Windows often overlap when there's more than one on the screen.&nbsp; When a group of windows are stacked together, a mouse click within one of them usually brings it to the front and its previously obscured contents become visible. Whether the contents are automatically made visible by the Window Server or must be redrawn by the application depends on whether the window has a backup buffer.&nbsp; The buffer stores pixel values for the portions of a window that aren't shown on the screen.&nbsp; When those portions become visible again, they can be copied from the buffer by the Window Server rather than be redrawn by the application.</font>

<p><font face="Times">So that you can pick the buffering scheme that's best for the needs of your application, three distinct types are provided:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Nonretained</i>.&nbsp; A nonretained window has no buffer.&nbsp; All drawing is done directly on-screen--that is, into the memory dedicated to holding screen pixel values.&nbsp; If part of the window gets covered by another window, the memory for that part of the screen changes and a portion of the covered window's contents are lost.&nbsp; If later the window is uncovered, any drawing in that part will be replaced by the background color.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Retained</i>.&nbsp; A retained window has a buffer equal to the size of the window.&nbsp; Drawing is done directly on-screen--directly into screen memory--for all visible portions of the window, and into the buffer for all portions of the window that are covered and not visible.&nbsp; If a visible portion of the window becomes obscured, the contents of that portion are saved in the buffer.&nbsp; If the obscured portion of the window is later revealed, the contents of the buffer are copied on-screen.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Buffered</i>.&nbsp; Like a retained window, a buffered window has a buffer large enough to hold its entire contents. However, the buffer isn't only backup storage, it also serves as a true input buffer.&nbsp; All drawing is first done in the buffer, then is copied to the screen through an explicit call to the NeXT PostScript <b>flushgraphics</b> operator. Drawing done through the Application Kit's display methods is automatically flushed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These three types are illustrated in Figure 4-13.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F13.gif" width=373 height=438></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-13</b></font><font face="Times">.&nbsp; Window Buffering</font>

<p><br><br>

<p><font face="Times">When a covered portion of a retained or buffered window becomes visible, the newly uncovered portion is automatically refreshed from the buffer.&nbsp; However, an uncovered portion of a nonretained window needs to be redrawn from scratch.&nbsp; Nonretained windows that are created through the Application Kit can handle this automatically.&nbsp; See &quot;Kit-Defined Events&quot; in the &quot;Event Handling&quot; section of Chapter 7.</font>

<p><font face="Times">The NeXT header file <b>dpsNeXT.h</b> (in <b>/usr/include/dpsclient</b>) defines three C constants that you can use to specify the buffering type when creating a window through Application Kit methods:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">NX_NONRETAINED</font><br>
<font face="Times">NX_RETAINED</font><br>
<font face="Times">NX_BUFFERED</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When created directly with PostScript operators, the equivalent constants are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">Nonretained</font><br>
<font face="Times">Retained</font><br>
<font face="Times">Buffered</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Choosing a Buffering Type</b></font>

<p><font face="Times">Because it combines the simplicity of drawing directly on the screen with the security of a backup buffer, a retained window is usually preferred over a nonretained window.&nbsp; Nonretained windows are appropriate for transitory images that you don't need to save, or for windows you can guarantee will never be covered.&nbsp; However, in a multi-application environment, this guarantee is a hard one to give.</font>

<p><font face="Times">A buffered window is appropriate when you're drawing images that take some time to appear, and you don't want users to watch them being rendered on-screen.&nbsp; With a buffered window, an elaborate picture can be displayed first in the buffer, and when it's complete be flushed instantaneously to the screen.</font>

<p><font face="Times">Buffered windows also yield smoother transitions between images when you're repeatedly drawing in the same area of the window.&nbsp; Suppose, for example, that your application draws the word &quot;RUNNING&quot; and then replaces it with &quot;FINISHED&quot;.&nbsp; PostScript operators paint only within the outline of images they're rendering--in this case, within the outlines of the letters of the two words.&nbsp; Therefore, it's necessary to erase &quot;RUNNING&quot; before drawing &quot;FINISHED&quot;; otherwise, some of &quot;RUNNING&quot; will show through the spaces between the letters of &quot;FINISHED&quot;.&nbsp; PostScript code like the following might be used:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1 setgray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % set the current color to white</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 120 20 rectfill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % erase</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 setgray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % set the current color to black</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 moveto</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">(FINISHED) show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % show &#34;FINISHED&#34;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">flushgraphics&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % flush, if it's a buffered window</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Display PostScript operator <b>rectfill</b> first erases a rectangular area by filling it with white, then <b>show</b> draws &quot;FINISHED&quot; in black.</font>

<p><font face="Times">Since a buffered window erases and redraws in the buffer, then flushes the buffer to the screen, you won't see the first image (&quot;RUNNING&quot;) removed before the second image (&quot;FINISHED&quot;) replaces it.&nbsp; However, a retained window erases and redraws on-screen.&nbsp; This difference doesn't much matter for a case where one word replaces another.&nbsp; But where images rapidly replace each other--as in an animation or redrawing lines of text in response to the user's typing--you'll notice a slight flicker in a retained window as images are erased before they're replaced.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The Screen List</b></font>

<p><font face="Times">The Window Server keeps track of the current front-to-back order of windows through a <i>screen list</i>.&nbsp; The list is rearranged every time the user brings a window to the front or sends one to the back.&nbsp; Applications reorder windows on-screen by reordering them in the list.&nbsp; This should be done through Application Kit methods.&nbsp; See Chapter 6 for details.</font>

<p><font face="Times">A window can be placed at the top of the screen list--that is, in the frontmost position--at the bottom of the list, or in any position above or below another window.&nbsp; Every window has a unique position in the list; even if two windows don't overlap on the screen, one of them is listed in front of the other.&nbsp; Windows can also be left off the list, and thus kept off the screen.</font>

<p><font face="Times">When you position a window in the list, you must specify two parameters:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Whether it's to be placed above or below another window, or left off the list entirely.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">What the window number of the other window is.&nbsp; If this number is 0, the window you're ordering will be placed at the very top or bottom of the list.&nbsp; If the window you're ordering is to be left off the list, this second parameter is ignored.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The NeXT header file <b>dpsNeXT.h</b> (in <b>/usr/include/dpsclient</b>) defines three C constants that can be used to order windows:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">NX_ABOVE</font><br>
<font face="Times">NX_BELOW</font><br>
<font face="Times">NX_OUT</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In PostScript code, the constants are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">Above</font><br>
<font face="Times">Below</font><br>
<font face="Times">Out</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Window Tiers</b></font>

<p><font face="Times">The Application Kit divides the screen list into six tiers.&nbsp; The top five tiers keep special types of windows from being buried under other windows when they're on-screen.&nbsp; The tiers are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">Pop-up and pull-down lists</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">Attention panels</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">3.</font></td>

<td><font face="Times">The main menu and attached submenus</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">4.</font></td>

<td><font face="Times">Other menus</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">5.</font></td>

<td><font face="Times">Docked icons</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">6.</font></td>

<td><font face="Times">All other windows</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">See <i>Chapter 2, &quot;The NeXT User Interface&quot;</i> for more on window tiers, and Chapter 6 for information on how to keep windows in the proper tier.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Off-Screen Windows</b></font>

<p><font face="Times">Windows are created off-screen.&nbsp; Applications must place them in the screen list to make them visible.&nbsp; If a window is buffered or retained, it's a good idea to draw in it before moving it on-screen.&nbsp; This prevents the user from seeing images rendered in stages.&nbsp; Windows that are kept permanently off-screen can be useful for caching images that you want to composite to on-screen windows.&nbsp; (See &quot;Compositing and Transparency&quot; later in this chapter for more information on compositing from an off-screen window.)</font>

<p><font face="Times">An off-screen window is entirely invisible; it has no screen memory.&nbsp; All drawing goes directly into the window's buffer.&nbsp; Drawing in an off-screen nonretained window is pointless; since it has no buffer, there's nowhere for the drawing to go.&nbsp; Flushing an off-screen buffered window is similarly pointless.</font>

<p><font face="Times">You can put a window in the screen list, and take it out again, with Application Kit methods (described under &quot;Managing Windows&quot; in Chapter 6).&nbsp; A window disappears from the screen when it's removed from the list, and is restored to the screen when it's put back in the list.&nbsp; (A removed window disappears only because covered portions of the windows behind it--including the background window for the entire screen, <b>workspaceWindow</b>--are redisplayed.)</font>

<p><font face="Times">It's also possible to locate windows off-screen yet keep them in the screen list.&nbsp; Because the screen coordinate system extends far beyond the screen along both the x- and the y-axis, you can assign coordinates that prevent a window from being visible.&nbsp; An ordinary-sized window located at (</font><img src="../../Images/c2D.gif" width=8 height=4><font face="Times">5000.0,</font> <img src="../../Images/c2D.gif" width=8 height=4><font face="Times">5000.0) would not show up on the screen, for example.</font>

<p><font face="Times">For two reasons, it's preferable to keep windows off-screen by removing them from the screen list rather than by assigning them off-screen coordinates:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Events--user actions on the keyboard and mouse--can be associated with any window in the screen list, whether its coordinates place it on the screen or off.&nbsp; However, windows not in the list don't get events.&nbsp; Since events are usually associated with an on-screen display (a slider or button, for example) and require visual feedback, they shouldn't normally be associated with windows the user can't see.&nbsp; Events are discussed in the next chapter.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Windows that aren't in the screen list can be assigned on-screen coordinates.&nbsp; This simplifies subsequent handling; placing the window on-screen involves no coordinate adjustments and no effort to remember where the window was located.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>The Background Color</b></font>

<p><font face="Times">Windows created through the Application Kit should be assigned a background color with methods defined in the Kit. This section describes the background color of windows at a lower level, the level of PostScript operators.</font>

<p><font face="Times">When a new window is created, the pixels within it are initialized to a <i>background color</i>, usually white.&nbsp; You can choose a color other than white by combining the effects of a few PostScript operators.</font>

<p><font face="Times">Through the <b>setexposurecolor</b> operator, you can determine the color that's displayed when new areas of the window are exposed.&nbsp; This operator sets the color that's shown in areas added to a window when it's resized larger.&nbsp; It also sets the color that's used when covered areas of a nonretained window are exposed.&nbsp; (When retained and buffered windows are exposed, their on-screen appearance is determined by the contents of their buffers.)</font>

<p><font face="Times">This code sets the background color of the current window to 50% gray:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0.5 setgray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Set a new gray value</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">setexposurecolor&nbsp;&nbsp;&nbsp; % Set the background color to new gray value</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To make the initial color of a nonretained window match the color set with this operator, create the window off-screen, set the background color, then move the window on-screen.</font>

<p><font face="Times">You can set the background color of a retained or buffered window by a combination of the <b>fill</b> operator (for the initial surface area of the window) and the <b>setexposurecolor</b> operator (for any future surface area if the window is resized). The window should be created off-screen and its background color set, before being moved on-screen.</font>

<p><font face="Times">When an area of a window is erased, you may want the color shown to be the same as the background color.&nbsp; Since the <b>erasepage</b> operator erases to white, don't use it unless white is the color you want.&nbsp; Instead make the clipping path the current path and fill it with the background color of your choice.&nbsp; This code erases to 50% gray:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">clippath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Make the clipping path the current path</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0.5 setgray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Set a new gray value</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Fill current path with new gray value</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Compositing and Transparency</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><i>Compositing</i> is a NeXT extension to the Display PostScript system that enables separately rendered images to be combined into a final image.&nbsp; It encompasses a wide range of imaging capabilities:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It provides the means for simply copying an image &quot;as is&quot; from one place to another.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It lets you add two images together so that both appear in the composite superimposed on each other.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It defines a number of operations that take advantage of <i>transparency</i> in one or both of the images that are combined.&nbsp; When they're composited, the transparency of one image can let parts of the other show through.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Compositing can be used for copying within the same window on the screen, as during scrolling, or for taking an image rendered in one window and transferring it to another.&nbsp; Images are often stored in off-screen windows and composited into windows on-screen as they're needed.&nbsp; For example, the Workspace Manager first renders application and document icons in off-screen windows, then copies them on-screen.</font>

<p><font face="Times">When images are partially transparent, they can be composited so that transparent sections of one determine what you'll see of the other.&nbsp; Each compositing operation uses transparency in a different way.&nbsp; In a typical operation, one image provides a background or foreground for the other.&nbsp; When parts of an image are transparent, it can be composited over an opaque background, which will show through the transparent &quot;holes&quot; in the image on top.&nbsp; In other operations, transparent sections of one image can be used to &quot;erase&quot; matching sections of the image it's composited with.&nbsp; In most operations, the composite is calculated from the transparency of both images.</font>

<p><font face="Times">Compositing with transparency can achieve a variety of interesting visual effects.&nbsp; A partially transparent, uniformly gray area can be used like a pale wash to darken the image it's composited with.&nbsp; Patches of partially transparent gray can add shadows to another image.&nbsp; Repeated compositing while slowly altering the transparency of two images can dissolve one into the other.&nbsp; Or an animated figure can be composited over a fixed background.</font>

<p><font face="Times">Before images can be composited, they must be rendered.&nbsp; To take advantage of transparency when compositing, at least one of the images needs to be rendered, to some extent, with transparent paint.</font>

<p><font face="Times">The next section describes how to create transparent images for compositing.&nbsp; If you're interested only in using compositing to copy, turn to the later section titled &quot;Compositing.&quot;</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Transparent Paint</b></font>

<p><font face="Times">On the NeXT computer, you can set a coverage parameter in the current graphics state in addition to the color parameter:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The <b>setalpha</b> operator sets the current coverage to an <i>alpha value</i> in a range from 0 (completely transparent) to 1 (completely opaque).</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">0.333 setalpha</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times">The default alpha value is 1.&nbsp; To use transparency, you must explicitly set a lower value; <b>currentalpha</b> returns the current setting.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The <b>setgray</b> operator sets the current color to a value in a range from 0 (black) to 1 (white):</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=143 height=1><font face="Courier" size="-1">0.5 setgray</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times"><b>currentgray</b> returns the current setting.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">In this discussion, the color parameter is illustrated by the single value, sometimes referred to as a <i>gray value</i>, that's set by <b>setgray</b> and returned by <b>currentgray</b>.&nbsp; However, the principles of compositing and transparency outlined here also apply when the color parameter has more than one component.&nbsp; For example, the red, green, and blue components in an RGB color system can each be set to a different value, but each would interact with the alpha value just as the gray value does.</font>

<p><font face="Times">Together, the alpha value and color value determine the kind of paint that's used when rendering an image.&nbsp; The color value determines the color of the paint; the alpha value determines how opaque or transparent it is.&nbsp; In the example above, the paint is mostly transparent; only one third of it is opaque.&nbsp; If it had been made completely transparent, as in</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0.0 setalpha</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">the current color would have been irrelevant; images drawn with transparent paint are invisible.</font>

<p><font face="Times">Figure 4-14 below illustrates the kind of paint that would be produced from an alpha value of 0.333 and a color value of 0.5.&nbsp; Setting the color value midway between white and black is like mixing equal equal portions of white and black paint (or, on the NeXT MegaPixel Display, equal portions of light gray and dark gray) to produce a medium gray. Making this paint only a third opaque is like mixing one portion of it with two portions of transparent paint.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F14.gif" width=254 height=186></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-14</b></font><font face="Times">.&nbsp; Mixing Transparent Paint</font>

<p><br><br>

<p><font face="Times">The color is still 0.5, midway between black and white, but the paint is diluted with transparency.&nbsp; When drawing with this paint, as in</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 100 100 rectfill</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">some of the background will show through.</font>

<p><font face="Times">What paint with a gray value of 0.5 and an alpha value of 0.333 actually looks like depends on the background it's applied against.&nbsp; The paint is just one-third opaque, so it contributes only one-third of the visual result.&nbsp; The background contributes the other two-thirds.</font>

<p><font face="Times">The background that shows through transparent paint is device-dependent.&nbsp; You won't see the images already displayed in the area being painted; they'll be erased no matter what paint you use.&nbsp; Rather, the background depends solely on the imaging model assumed by the device.&nbsp; There are two principal, and competing, models:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">In the PostScript imaging model, an image is built up by applying paint on a white surface.&nbsp; This is a convenient model for printers, which normally put ink on white pages, and it fits well with the assumptions of artists who begin with a white canvas.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">In the competing model, images are built up by adding color to a colorless, black surface.&nbsp; This model is commonly assumed in video and color graphics.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Devices can also assume backgrounds other than black or white, but black and white are the only two that need to be discussed here.</font>

<p><font face="Times">Figure 4-15 below shows how each of these imaging models would affect the partially transparent gray paint in the example above.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F15.gif" width=230 height=232></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-15</b></font><font face="Times">.&nbsp; Painting with Transparency</font>

<p><br><br>

<p><font face="Times">If the background color is black, the result will appear blacker than the medium gray we originally set.&nbsp; If the background color is white, the result will be whiter.</font>

<p><font face="Times">The NeXT MegaPixel Display adopts the PostScript model:&nbsp; A white background is assumed.&nbsp; Areas painted with completely transparent paint appear white on-screen; areas painted with partially transparent grays appear as lighter grays.&nbsp; However, for external data representation, the second imaging model, with a black background, is assumed. See &quot;Data Representation&quot; below for details.</font>

<p><font face="Times">In either case, the appearance of the painted image may be deceptive, since, when composited, the transparency of the image may let some of the other image (rather than a black or white background) show through.</font>

<p><font face="Times">Note that painting destroys any images that were previously rendered in the same area.&nbsp; Painting one image after another completely obliterates the first image.&nbsp; Even when the paint is totally transparent, the images it covers are destroyed (in favor of the background color assumed by the device).&nbsp; The only way to combine images is through compositing.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Data Representation</b></font>

<p><font face="Times">Painting operators (such as <b>rectfill</b> and <b>stroke</b>) produce an image on-screen or in a window buffer.&nbsp; They directly affect pixel values.</font>

<p><font face="Times">The values that painting operators produce depend on a number of factors, including:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The alpha and color values of the current graphics state.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The transfer function (which maps values set by <b>setgray</b> and <b>setalpha</b> to values used by the device).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current halftone screen.&nbsp; (See &quot;Pixels, Halftones, and Rectangular Coordinates&quot; above for information on halftones.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The range of values that a pixel can represent depends on the number of bits provided per pixel.&nbsp; On the MegaPixel Display, two bits of memory are set aside to store the color of each pixel, and another two to store its coverage.&nbsp; Values for the coverage of pixels are stored separately from color values.</font>

<p><font face="Times">Every pixel within a window has both color and coverage components.&nbsp; However, for efficiency, memory isn't allocated for the coverage component if all the window's pixels are opaque.&nbsp; Instead of being explicitly stored, the opaqueness of the window is implicit.&nbsp; Once any pixel needs to be assigned an explicit coverage value (because it's no longer completely opaque), alpha storage is allocated for the entire window.</font>

<p><font face="Times">There are significant performance advantages associated with windows that have implicitly opaque pixels.&nbsp; Imaging in such a window is twice as fast as imaging in a window with explicit coverage, since only half as much memory is affected.&nbsp; Copying between implicitly opaque windows is optimized to be highly efficient; compositing operations between windows with explicitly stored coverage values can be several times slower.</font>

<p><font face="Times">The <b>currentwindowalpha</b> operator, described in the <i>NeXTstep Reference, Volume 2</i>, reports whether a window has an explicit coverage component.&nbsp; It's useful mainly for debugging; you'd rarely need to know how a window's coverage values are stored.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Bitmaps</b></font>

<p><font face="Times">A <i>bitmap</i> is binary data that describes the pixel values for an image.&nbsp; It's an external data representation, perhaps kept in a file or in memory allocated by your program, as opposed to the representations used internally by the device.</font>

<p><font face="Times">A bitmap is the most efficient way of rendering a complicated image in a window; the external data values in the bitmap can be translated directly into device-internal pixel values.&nbsp; The <b>NXImageBitmap()</b> function displays a bitmap image, and <b>NXReadBitmap()</b> produces a bitmap from an existing image.&nbsp; (These two functions are described in the <i>NeXTstep Reference, Volume 2</i>.)</font>

<p><font face="Times">Bitmaps cover a rectangular area and describe all the pixels within the rectangle.&nbsp; Because the MegaPixel Display requires two bits of memory for each component of a pixel, a bitmap also assigns two bits per pixel for each component.&nbsp; Bitmaps always have a color component and may or may not also have a coverage component.&nbsp; If all the pixels described by the bitmap are completely opaque, the coverage component can be omitted.</font>

<p><font face="Times">By convention, bitmaps use the same color and coverage scales as <b>setgray</b> and <b>setalpha</b>:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Color</b></font></td>

<td nowrap><font face="Helvetica"><b>Value</b></font></td>

<td><font face="Helvetica"><b>Coverage</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">White</font></td>

<td nowrap><font face="Times">1</font></td>

<td><font face="Times">Opaque</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Black</font></td>

<td nowrap><font face="Times">0</font></td>

<td><font face="Times">Transparent</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Where there's more than one bit of storage per pixel, all the bits for a component must be &quot;on&quot; for the pixel to be white or opaque, and all must be &quot;off&quot; for it to be black or transparent.&nbsp; Because there are two bits per pixel for both color and coverage on the MegaPixel Display, each pixel can have any of four values in each component:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Color</b></font></td>

<td><font face="Helvetica"><b>Coverage</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">White</font></td>

<td><font face="Times">Opaque</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Light gray</font></td>

<td><font face="Times">2/3 opaque</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Dark gray</font></td>

<td><font face="Times">1/3 opaque</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Black</font></td>

<td><font face="Times">Transparent</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Not every combination of color and coverage values is permitted, however.&nbsp; When there's any degree of transparency, color values are adjusted toward black.&nbsp; This adjustment is explained in the next section.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Premultiplication</b></font>

<p><font face="Times">It's convenient, both in bitmaps and in device-internal image representations, to store color values that reflect the effect of the coverage component.&nbsp; The intended or &quot;true&quot; color (as determined by <b>setgray</b>) is multiplied by the coverage before being stored.&nbsp; So a white pixel (true color = 1) that's one-third transparent (coverage = 0.667) will store a color value of 0.667 (1</font> <img src="../../Images/cB4.gif" width=8 height=7> <font face="Times">0.667).</font>

<p><font face="Times">There are two reasons for this adjustment:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's a required part of all compositing operations.&nbsp; Doing the multiplication when pixel values are first stored--&quot;premultiplying&quot;--means that it can be avoided during compositing.&nbsp; This makes compositing more efficient.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It results in a value that more accurately reflects the pixel's actual color contribution.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For example, when the color parameter is set to 0.5 and the coverage parameter equals 0.333, as illustrated in Figure 4-14 above, color values are premultiplied to 0.167 (0.5</font> <img src="../../Images/cB4.gif" width=8 height=7> <font face="Times">0.333).&nbsp; This value reflects the visual result of placing this mostly transparent paint over an assumed black background, as shown in Figure 4-15 above; the background biases the color toward black.&nbsp; If 0.167 isn't one of the pure colors available on the device, the actual color values for pixels in the painted area will be determined by the halftone pattern for 0.167 gray.</font>

<p><font face="Times">Where pixel values are opaque (coverage = 1), premultiplication doesn't change color values.&nbsp; But where there's any degree of transparency, premultiplying results in color values that are blacker than the true values set.&nbsp; This reflects the effect of an assumed black background showing through.&nbsp; In bitmaps, color values must be premultiplied &quot;toward black&quot; in this way.&nbsp; This means that, in external data representations, a pixel's color value can never be greater than its coverage value.&nbsp; The table in Figure 4-16 below summarizes permitted color and coverage combinations.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F16.gif" width=230 height=152></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-16</b></font><font face="Times">.&nbsp; Permitted Pixel Values</font>

<p><br><br>

<p><font face="Times">Note that the color of a completely transparent pixel is black, and a white pixel can only be opaque.&nbsp; Only opaque pixels can show the full range of colors.</font>

<p><font face="Times">Although a black background is assumed for the external data representation stored in bitmaps, the internal representations on the MegaPixel Display use the opposite convention.&nbsp; Internally, color values are premultiplied towards white rather than black.&nbsp; Where there's transparency, stored color values are whiter than the true color, reflecting an assumed white background showing through.&nbsp; <b>NXImageBitmap()</b> and the imaging operators on which it's based accurately translate external (bitmap) values into the correct internal values for the MegaPixel Display. <b>NXReadBitmap()</b> produces correct bitmaps from internal image representations.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Premultiplication toward white is accomplished, in part, by using an internal gray scale that's the inverse of the PostScript gray scale.&nbsp; Internally, 0 is white and 1 is black.</font>

<p><font face="Times">At first glance, the difference between external and internal data representation may seem unnecessary.&nbsp; However, premultiplication toward black for external data representation is a device-independent standard.&nbsp; Converting from it to a variety of device-internal representations--including the representations required for color systems and the premultiplied-toward-white representations required for the MegaPixel Display--are easy and accurate.&nbsp; Adopting it as a standard means that you won't have to modify bitmap data to render it on different devices.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Compositing</b></font>

<p><font face="Times">In general, compositing combines two rectangular images of the same size, shape, and orientation, one a <i>source image </i>and the other a <i>destination image</i>, with the result replacing the destination image.&nbsp; Source and destination images may be located in the same window, or in different windows.&nbsp; The windows may be on-screen or off.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Compositing Operators</b></font>

<p><font face="Times">There are three compositing operators--<b>composite</b>, <b>compositerect</b>, and <b>dissolve</b>.&nbsp; The most general of the three is <b>composite</b>.&nbsp; It and <b>compositerect</b> are described below.&nbsp; <b>dissolve</b> is a special-purpose operator described later under &quot;Dissolving.&quot;</font>

<p><br><br>

<p><font face="Helvetica"><b>composite</b></font>

<p><font face="Times">The <b>composite</b> operator takes a list of eight operands; the first four specify the rectangle of the source image:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times"><i>src<sub>x</sub>src<sub>y</sub>width height srcgstate dest<sub>x</sub>dest<sub>y</sub>op</i> <b>composite</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The fifth operand, <i>srcgstate</i>, names a graphics state that specifies both the window device where the source rectangle is located and the coordinate system it's defined in.</font>

<p><font face="Times">The next two operands, <i>dest<sub>x</sub></i>and <i>dest<sub>y</sub></i>, locate the destination image in the current window and current coordinate system.&nbsp; Pixels in the destination image are paired one-to-one with pixels in the source image.&nbsp; The destination rectangle will be the same size and orientation as the source rectangle, regardless of the current coordinate system. It's positioned relative to (<i>dest<sub>x</sub></i>, <i>dest<sub>y</sub></i>) exactly as the source rectangle is to (<i>src<sub>x</sub></i>, <i>src<sub>y</sub></i>).&nbsp; This is illustrated in Figure 4-17.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F17.gif" width=436 height=346></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-17</b></font><font face="Times">.&nbsp; Compositing</font>

<p><br><br>

<p><font face="Times">The outline of the source rectangle may cross pixel boundaries due to fractional coordinates, scaling, or (as in the second example in Figure 4-17 above) rotated axes.&nbsp; The source image includes all the pixels that the rectangle encloses or enters.&nbsp; See &quot;Imaging Conventions&quot; later in this chapter for information on how outlines chose pixels.</font>

<p><font face="Times">The final operand to <b>composite</b> specifies the type of compositing operation.&nbsp; There are several to choose from:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Copy</font></td>

<td nowrap><font face="Times">Sover</font></td>

<td><font face="Times">Dover</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Clear</font></td>

<td nowrap><font face="Times">Sin</font></td>

<td><font face="Times">Din</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">PlusD</font></td>

<td nowrap><font face="Times">Sout</font></td>

<td><font face="Times">Dout</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">PlusL</font></td>

<td nowrap><font face="Times">Satop</font></td>

<td><font face="Times">Datop</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap></td>

<td nowrap><font face="Times">Xor</font></td>

<td></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>dpsNeXT.h</b> header file defines matching constants that can be used in Objective-C code:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NX_COPY</font></td>

<td nowrap><font face="Times">NX_SOVER</font></td>

<td><font face="Times">NX_DOVER</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NX_CLEAR</font></td>

<td nowrap><font face="Times">NX_SIN</font></td>

<td><font face="Times">NX_DIN</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NX_PLUSD</font></td>

<td nowrap><font face="Times">NX_SOUT</font></td>

<td><font face="Times">NX_DOUT</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NX_PLUSL</font></td>

<td nowrap><font face="Times">NX_SATOP</font></td>

<td><font face="Times">NX_DATOP</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap></td>

<td nowrap><font face="Times">NX_XOR</font></td>

<td></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The operation called &quot;Copy&quot; is one of the most basic; it simply replaces the destination image with the source image. In the example below, it moves the source image ten units higher in the same window:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myGState setgstate&nbsp;&nbsp;&nbsp; % make myGState the current graphics state</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 200 200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % the source rectangle</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myGState&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % the source graphics state</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % location of the destination rectangle</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">Copy composite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % copy source to destination</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this example, the source and destination images overlap.&nbsp; This is typically the case when an image is scrolled.</font>

<p><br><br>

<p><font face="Helvetica"><b>compositerect</b></font>

<p><font face="Times">When the source of a compositing operation is a constant color, it's convenient to use the <b>compositerect</b> operator instead of <b>composite</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times"><i>dest<sub>x</sub>dest<sub>y</sub>width height op</i> <b>compositerect</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>compositerect</b> is like <b>composite</b>, except that there's no real source image; its first four operands define the destination rectangle directly in the current window.&nbsp; <b>compositerect</b>'s effect on the destination is as if there were a source image filled as specified by the color and alpha parameters in the current graphics state.&nbsp; For example, you could erase a rectangular area to white by setting the current color to 1 and then calling <b>compositerect</b> to perform a Copy operation:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1 setalpha</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1 setgray</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 100 100 Copy compositerect</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This is exactly the same as:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1 setalpha</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1 setgray</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 100 100 rectfill</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">However, <b>compositerect</b> can be used for compositing operations other than Copy; <b>rectfill</b> and the other painting operators only render images in Copy mode.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Types of Compositing Operations</b></font>

<p><font face="Times">Most compositing operations are designed to make use of transparency in the source or destination image.&nbsp; But some, such as Copy illustrated above, are useful even when both images are completely opaque.</font>

<p><font face="Times">Figure 4-18 below illustrates all the compositing operations and summarizes each one in terms of what replaces the destination image.&nbsp; &quot;Source image&quot; or &quot;destination image&quot; in a result means both the color and coverage components of the pixels in the corresponding image.&nbsp; For simplicity, these summaries assume that the coverage values in the images are either 1 or 0 (opaque or fully transparent).&nbsp; The paragraphs following the illustration describe each operation in more detail.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F18.gif" width=479 height=578></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-18</b></font><font face="Times">.&nbsp; Compositing Operations</font>

<p><br><br>

<p><font face="Times">For a more complete discussion of compositing, including information on how composite images are calculated, see the paper &quot;Compositing Digital Images&quot; by Thomas Porter and Tom Duff in <i>Computer Graphics</i> (<i>SIGGRAPH '84 Conference Proceedings</i>) Volume 18, Number 3 (July 1984).</font>

<p><br><br>

<p><font face="Helvetica"><b>Copy</b></font>

<p><font face="Times">Copy is the simplest compositing operation and probably the one most used.&nbsp; It ignores the destination image, and replaces it with the source image; every pixel in the source rectangle is copied to the destination.&nbsp; Copy is used in scrolling to move an image from one location to another.&nbsp; It's also used to bring images stored in off-screen windows to the screen.&nbsp; Copy is the only way images are moved on the NeXT computer.</font>

<p><br><br>

<p><font face="Helvetica"><b>Clear</b></font>

<p><font face="Times">Whereas Copy ignores the destination image, Clear ignores both the destination and the source.&nbsp; It turns the destination rectangle completely transparent.&nbsp; Clearing the rectangle has the same effect as painting it with pure transparent paint. This code</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 100 100</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">Clear compositerect</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">is equivalent to</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 setalpha</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 100 100 rectfill</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">except that Clear doesn't change the alpha value in the current graphics state.</font>

<p><font face="Times">Clear is useful for creating a transparent surface to paint on.&nbsp; A transparent surface is like a clear sheet of plastic that you can selectively color with opaque paint.&nbsp; When the sheet is placed over another image, the other image will show through wherever paint hasn't been applied.</font>

<p><font face="Times">Before it's painted on.&nbsp; a transparent surface lets the background color--white on the MegaPixel Display--show through everywhere.&nbsp; However, you should never use Clear simply to erase to the background.&nbsp; A transparent surface isn't the same as an opaque white surface.&nbsp; If the destination window doesn't already have memory allocated to store the coverage component of its pixels, Clear will allocate it.&nbsp; It may therefore double the amount of memory for the window.</font>

<p><br><br>

<p><font face="Helvetica"><b>PlusD and PlusL</b></font>

<p><font face="Times">PlusD (for &quot;darker&quot;) and PlusL (for &quot;lighter&quot;) are two versions of the same basic operation.&nbsp; They both add the source and destination images together.&nbsp; Where partially transparent areas in the source and destination overlap, the composite becomes more opaque.&nbsp; It's like looking through two panes of tinted glass rather than one; together they're more opaque than either alone.&nbsp; Where either of the original images is completely opaque, the composite is also opaque; where either image is completely transparent, the composite has the coverage of the other image.</font>

<p><font face="Times">PlusD and PlusL differ only in how they add source and destination color values.&nbsp; PlusD adds colors so that they become darker; PlusL adds them so that the result is lighter.</font>

<p><font face="Times">PlusD compositing is the more natural of the two for devices like the MegaPixel Display where the white background of the PostScript imaging model is assumed; it adds color values to be less like the background.&nbsp; Where the gray of one image overlaps the gray of the other, a darker shade of gray results.&nbsp; Black plus any other color yields black; white plus another color yields the other color.</font>

<p><font face="Times">PlusL compositing is not currently implemented for the MegaPixel Display.&nbsp; It would be most naturally used where a black background is assumed, for it adds color values to become lighter, less like the background.&nbsp; Where the gray of one image overlaps the gray of the other, a lighter shade of gray results.&nbsp; Black plus any other color yields the other color; white plus another color yields white.</font>

<p><br><br>

<p><font face="Helvetica"><b>Transparency Operations</b></font>

<p><font face="Times">For Copy, Clear, PlusD, and PlusL, neither the source nor the destination image need be transparent (though they can be).&nbsp; In contrast, the other compositing operations are most interesting and useful when one (or both) of the images is partially transparent.&nbsp; The transparency of one image helps determine what you'll see of the other.</font>

<p><font face="Times">With one exception, the operations that make use of transparency come in pairs and have similar names.&nbsp; The first letter of the name is an &quot;S&quot; or a &quot;D,&quot; standing for &quot;source&quot; or &quot;destination.&quot;&nbsp; The remaining letters of the name describe the type of operation.&nbsp; They're summarized in the list below:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Sover and Dover</font></td>

<td><font face="Times">One image is placed over the other.&nbsp; Transparency in the image on top lets the image underneath show through.</font></td></tr>

<tr valign=top>

<td width=124 height=17></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td><font face="Times">Aside from Copy, Sover and Dover are perhaps most common and useful compositing operations.&nbsp; They permit a foreground image to be composited over a background image, or let areas of partial opacity in the image on top add shading to the image underneath.&nbsp; The arrow cursor you see on the screen is placed there using Sover compositing.&nbsp; The source rectangle has transparent pixels surrounding the opaque arrow.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Sin and Din</font></td>

<td><font face="Times">One image is displayed wherever, and to the extent that, the other image is opaque. In a sense, the transparency of the second image eliminates portions of the first.</font></td></tr>

<tr valign=top>

<td width=124 height=17></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td><font face="Times">Sin and Din can be used to clip a picture to a particular shape, say an oval.&nbsp; The oval is drawn with opaque paint on a clear (transparent) surface, and the picture is Sin'ed over it.&nbsp; Or, if you've drawn a portrait of someone on a clear surface, you can turn it into a silhouette by using <b>compositerect</b> to Sin a black rectangle over it.&nbsp; All the opaque pixels in the portrait will turn black.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Sout and Dout</font></td>

<td><font face="Times">One image is displayed wherever, and to the extent that, the other image is transparent.&nbsp; The opacity of the second image eliminates portions of the first.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Satop and Datop</font></td>

<td><font face="Times">One image is placed on top of the other, with the composite adopting the transparency of the image underneath.&nbsp; The image on top shows through only where (and to the extent that) the image underneath is opaque.&nbsp; The image underneath shows through only where (and to the extent that) it's opaque and the image on top is transparent.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Xor</font></td>

<td><font face="Times">Each image is visible only where (and to the extent that) it's opaque and the other image is transparent.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Dissolving</b></font>

<p><font face="Times">The <b>dissolve</b> operator blends two images together.&nbsp; Typically, it's called over and over again in a loop so that one image (the source) can appear to slowly replace the other (the destination).</font>

<p><font face="Times"><b>dissolve</b> takes almost the same set of operands as <b>composite</b>, but since it uses a compositing operation that's particular to its purpose (one similar to Plus), the operation isn't stated as an operand.&nbsp; Instead, you specify a fraction, <i>delta</i>, that determines how much each image contributes to the composite:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times"><i>src<sub>x</sub>src<sub>y</sub>width height srcgstate dest<sub>x</sub>dest<sub>y</sub>delta</i> <b>dissolve</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When <i>delta</i> is 0, only the destination image is in the composite; when it's 1, only the source image is present.&nbsp; In the example below, 40% of the composite comes from the source image; the remaining 60% belongs to the original destination image.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 200 200 myGState 50 50 0.4 dissolve</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To gradually replace one image with another, <b>dissolve</b> should be called in a loop with <i>delta</i> increasing slowly from 0 to 1 with each call.&nbsp; Since it must combine the original destination and source images each time, the altered destination image must be replaced with the original before <b>dissolve</b> is called.&nbsp; This is done by storing the destination image in an off-screen window and copying it to the destination rectangle each time through the loop.&nbsp; Dissolving should be done in a buffered window so that only the result produced by the <b>dissolve</b> operator is flushed to the screen.</font>

<p><font face="Times">In the example below, the original destination image is stored in an off-screen window identified by the <b>offGS</b> graphics state object; the source image is in a window identified by the <b>srcGS</b> graphics state object.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 1 64 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % begin loop, stepping from 0 to 64</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/delta exch 64 div def&nbsp; % redefine delta each time as the current step</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">% number of steps divided by the total</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 200 200 offGS</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 Copy composite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % copy in the original destination</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 200 200 srcGS</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 delta dissolve&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % dissolve in the source image</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">flushgraphics&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % flush the result to the screen</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % end the loop</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Highlighting</b></font>

<p><font face="Times">On the NeXT MegaPixel Display, highlighting is usually accomplished by changing white pixels to light gray and light gray pixels to white:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Buttons and menu commands have a light gray background that turns to white when they're highlighted.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Selectable text is displayed against a white background, which becomes light gray to mark the selection.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Since the background color to a display is typically light gray or white, this type of highlighting fits a variety of contexts and doesn't radically change what the user sees.</font>

<p><font face="Times">To make highlighting easy, there's an additional compositing operation, called &quot;Highlight,&quot; that's used only with the <b>compositerect</b> operator:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">10 10 50 50 Highlight compositerect</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">On the MegaPixel Display, Highlight turns every white pixel in the destination rectangle to light gray and every light gray pixel to white, regardless of the pixel's coverage value.&nbsp; Repeating the same operation reverses the effect. (Highlight may act differently on other devices.&nbsp; For example, on displays that assign just one bit per pixel, it would invert every pixel.)</font>

<p><font face="Times">The <b>NXHighlightRect()</b> function is the most direct way to highlight in Objective-C code.&nbsp; It performs Highlight compositing on the area specified by an NXRect structure.&nbsp; The code in the example below is equivalent to the PostScript code shown above:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; rect = {{10.0, 10.0}, {50.0, 50.0}};</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXHighlightRect(&amp;rect);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The Highlight operation doesn't change the value of a pixel's coverage component.&nbsp; To ensure that the pixel's color and coverage combination remains valid, Highlight operations should be temporary and should be reversed before any further compositing.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Instance Drawing</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A screen-oriented user interface often does highly interactive drawing as a means of providing feedback to the user, typically in response to the user dragging with the mouse.&nbsp; Examples of this include stretching out a rectangle, moving an object around on the screen, and highlighting objects as they're selected.&nbsp; In general, something is drawn over and over again, changing its location, size, or orientation each time, with previous occurrences of the image disappearing as new occurrences are drawn.&nbsp; This kind of interactive, temporary drawing is facilitated by a NeXT extension to the Display PostScript system known as <i>instance drawing</i>.</font>

<p><font face="Times">Instance drawing is temporary drawing done within an on-screen window.&nbsp; Rendered images appear directly on-screen and aren't saved in the window's buffer.&nbsp; They can be easily removed and replaced with the original image, usually in preparation for the next instance drawing.</font>

<p><font face="Times">The <b>setinstance</b> operator turns instance drawing mode on and off.&nbsp; While the mode is on, all drawing in the current window is treated as instance drawing rather than as part of the window's permanent display.&nbsp; The mode setting is stored as a parameter in the current graphics state.&nbsp; All images produced in instance drawing mode are removed by the <b>newinstance</b> operator (so named because you call it when you're about to replace a previous instance with a new one). <b>newinstance</b> restores the original image.</font>

<p><font face="Times">In addition, there's a <b>hideinstance</b> operator for restoring the original image within a specified rectangle.&nbsp; For example, if instance drawing is used to mark selected objects, <b>hideinstance</b> can be invoked to unmark objects the user has deselected by dragging back over them.</font>

<p><font face="Times">If you do instance drawing in a retained or buffered window and part of the drawing is obscured by another window, you'll get a window-exposed subevent (of the kit-defined event) if the obscured part of the drawing is exposed.&nbsp; In practice, it should rarely happen that your instance drawing is obscured by another window; usually you'll do instance drawing in the frontmost window, since that's the window the user is actively working in.&nbsp; (Events are discussed in the next chapter.)</font>

<p><font face="Times">The following example illustrates the three instance drawing operators--<b>setinstance</b>, <b>hideinstance</b>, and <b>newinstance</b>. You can run the code that's presented here in a PostScript previewer such as <b>pft</b> to see the demonstration on-screen.</font>

<p><font face="Times">Normally you'd do instance drawing in response to events and take some of the drawing coordinates from the current position of the cursor.&nbsp; But this demonstration uses coordinates that are randomly determined.&nbsp; In a self-contained loop, it draws a black rectangle in a narrow window along the left edge of the screen and bounces one side of the rectangle up and down.&nbsp; The bouncing effect is produced by progressively adding small slices to the rectangle to make it grow larger, and by subtracting small slices to make it grow smaller.&nbsp; Slices are added in instance drawing mode and hidden using the <b>hideinstance</b> operator.</font>

<p><font face="Times">First, the window is created:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/w 100 def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Define w for &#34;width&#34;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/h 832 def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Define h for &#34;height&#34;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0 w h Buffered window&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Create a buffered window</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">windowdeviceround&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Make it the current device</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">Above 0 currentwindow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Place the window on-screen</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">orderwindow</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To show that <b>hideinstance</b> and <b>newinstance</b> reinstate the original image, there has to be something showing in the window before instance drawing begins.&nbsp; This code supplies a simple design:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">0 0&nbsp; 0 h&nbsp; w h&nbsp; w 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Put window corners on the stack</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">3 {8 copy 8 2 roll} repeat&nbsp;&nbsp;&nbsp; % Set up to start from each corner</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">4 {moveto curveto} repeat&nbsp;&nbsp;&nbsp;&nbsp; % Draw the curve from each corner</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">stroke&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Stroke the path</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">flushgraphics&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Flush it to the screen</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The code that follows draws the bouncing rectangle.&nbsp; It has two loops:&nbsp; The outer one switches the end of the window where the rectangle is drawn.&nbsp; The inner loop expands and contracts the rectangle from that end a random number of times.&nbsp; Each time through the inner loop, a new y coordinate (<b>ynew</b>) is selected at random.&nbsp; Depending on the location of <b>ynew</b>, the rectangle is either stretched--by having <b>rectfill</b> repeatedly fill one-pixel-high cross sections of the window--or constricted--by having <b>hideinstance</b> remove one-pixel-high cross sections.</font>

<p><font face="Times">After a few times, this whole process is repeated at the other end of the window.&nbsp; To start fresh from the other end, the <b>newinstance</b> operator is used to remove the entire rectangle.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">true setinstance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Turn on instance drawing mode</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">50 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Repeat the outer loop 50 times</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/yold 0 def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % To start, define yold to be 0</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">rand 20 mod {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Repeat inner loop 0-19 times</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/ynew rand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Define ynew to be a random number less</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">h mod def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %&nbsp;&nbsp;&nbsp; than the window height</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">ynew yold gt {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % If ynew is greater than yold, add</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">yold 1 ynew&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %&nbsp;&nbsp;&nbsp; slices to the rectangle</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">{0 exch w 1</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">rectfill} for</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Otherwise, hide slices of the rectangle</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">yold -1 ynew</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">{0 exch w 1</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">hideinstance} for</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">} ifelse</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/yold ynew def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Redefine yold to be ynew</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">} repeat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Repeat the inner loop</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">0 h translate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Move the coordinate origin</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">1 -1 scale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Flip the polarity of the y-axis</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">newinstance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Remove all instance drawing</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} repeat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Repeat the outer loop</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">false setinstance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % Turn off instance drawing mode</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Sending PostScript Code to the Window Server</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Your application must send PostScript code to the NeXT Window Server to draw on the screen.&nbsp; Communication with the Window Server is made possible through a bidirectional connection between the application process and the Window Server process.&nbsp; This section discusses how applications send drawing information over this connection to the Server.</font>

<p><font face="Times">Programs based on the Application Kit establish this connection automatically at startup.&nbsp; If your program doesn't use the Application Kit, you must establish a connection to the Window Server through direct calls to functions defined in the library <b>libNeXT.a</b>.&nbsp; This library includes the basic Display PostScript client library along with extensions that support the NeXT window system.</font>

<p><font face="Times">The primary documentation for the client library and for the Display PostScript System in general is contained in a series of manuals by Adobe Systems.&nbsp; See &quot;Suggested Reading&quot; in the <i>NeXT Technical Summaries</i> manual for information about these manuals.&nbsp; For information about those functions that are specific to the NeXT implementation of the Display PostScript System, see <i>NeXTstep Reference, Volume 2</i> and the comments in the NeXT header file <b>dpsclient/dpsNeXT.h</b>.</font>

<p><font face="Times">Once a connection is established, information passes across it in both directions until the connection is closed when the user quits the application.&nbsp; For transmission efficiency, the information sent to the Window Server consists primarily of binary-encoded PostScript code.&nbsp; For further efficiency, the information passed in either direction across the connection is accumulated into buffers before being sent across the connection.&nbsp; In most cases, the buffers are flushed automatically without the explicit intervention of the application.</font>

<p><font face="Times">Most of the drawing information your application sends to the Window Server (for example, instructions for drawing standard user-interface objects like buttons and sliders) is created and sent for you by the Application Kit objects that make up your application.&nbsp; You only need to write and send drawing instructions for those features that are unique to your application.&nbsp; There are several ways to accomplish this:&nbsp; using the <b>pswrap</b> program, using C functions that correspond to individual PostScript operators, or writing directly to the connection.&nbsp; The next three sections discuss these techniques.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Using pswrap</b></font>

<p><font face="Times">For most programmers, <b>pswrap</b> provides the best way of sending PostScript code to the Window Server.&nbsp; <b>pswrap </b>(described in detail in Adobe Systems' <i>pswrap Reference Manual</i>) is a program that creates a C function to correspond to a sequence of PostScript code.&nbsp; When your application is run, a call to the C function sends a binary-encoded version of the PostScript code to the Window Server.</font>

<p><font face="Times">Each function definition begins with <b>defineps</b> and ends with <b>endps</b>.&nbsp; The definition includes the C function name, any the function requires, and a listing of the PostScript code the function represents.</font>

<p><font face="Times">For example, you could define a function that draws a square on the screen, as illustrated below:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">defineps drawSquare(float x)</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">newpath</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">100.0 100.0 moveto</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">0.0 50.0 rlineto</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">50.0 0.0 rlineto</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">0.0 -50.0 rlineto</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">closepath</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">x setgray</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">stroke</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">endps</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The first six lines of PostScript code in this example outline a square area on the screen.&nbsp; The <b>setgray</b> operator sets the shade of gray equal to the value of <b>x</b>, the input argument to this function.&nbsp; Finally, <b>stroke</b> paints the outline with the selected shade of gray.</font>

<p><font face="Times">Elsewhere in your C source code, you can call this <b>drawSquare</b> function in the same manner as you would any C function:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">drawSquare(0.5);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>pswrap</b> lets you combine PostScript and Objective-C (or C) code in a natural way.&nbsp; <b>pswrap</b> functions can take input arguments (as above) and can, through output arguments, return values sent across the connection from the PostScript interpreter.&nbsp; A <b>pswrap</b> function can be defined in a separate file or can be included in the same file as the Objective-C source code.&nbsp; If Objective-C and PostScript code are combined in a single file, <b>pswrap</b> passes the Objective-C code through unchanged to an output file and translates only the embedded PostScript code that's marked by the <b>defineps </b>and <b>endps</b> delimiters.&nbsp; After preprocessing with <b>pswrap</b>, the output file can be compiled in the normal way.</font>

<p><font face="Times">The benefits of using <b>pswrap</b> to create a function corresponding to several lines of PostScript code are most clearly seen in comparison to the alternatives:&nbsp; the single-operator functions and writing directly to the connection.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Using Single-Operator Functions</b></font>

<p><font face="Times">The easiest way to send one or two lines of PostScript code to the Window Server is by using a set of C functions that have a one-to-one correspondence with the PostScript operators.&nbsp; These functions were created by applying <b>pswrap</b> to PostScript code containing each of these operators; thus, they can be considered a fundamental kind of <b>pswrap</b>-generated function.</font>

<p><font face="Times">Each of these &quot;single-operator&quot; functions has the same name as the corresponding PostScript operator, but begins with the prefix &quot;PS&quot; or &quot;DPS&quot;.&nbsp; The functions that have the &quot;PS&quot; prefix act on the current PostScript context; you must specify the PostScript context for the &quot;DPS&quot; functions.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Standard Display PostScript single-operator functions are listed in Adobe Systems' <i>Client Library Reference Manual</i>.&nbsp; Those single-operator functions that are specific to the NeXT computer environment are described in <i>NeXTstep Reference, Volume 2</i>.&nbsp; The C functions chapter in the <i>Technical Summaries</i> manual summarizes all single-operator functions.</font>

<p><font face="Times">An example of a single-operator function is <b>PSsetgray()</b>, the C function that corresponds to the PostScript <b>setgray </b>operator.</font>

<p><font face="Times">The arguments to a single-operator function are the operands required by the corresponding PostScript operator, as seen in this rewrite of the above example:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSnewpath();</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSmoveto(100.0, 100.0);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSrlineto(0.0, 50.0);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSrlineto(50.0, 0.0);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSrlineto(0.0, -50.0);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSclosepath();</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSsetgray(0.5);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSstroke();</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In some cases, if a PostScript operator leaves a value on the stack, the corresponding single-operator function also leaves a value on the stack rather than returning it to the application.&nbsp; This is done for efficiency, since typically the value is needed as input for the next operator to be executed.</font>

<p><font face="Times">In general, using <b>pswrap</b> to create a customized function corresponding to multiple lines of PostScript code is preferable to using multiple single-operator functions.&nbsp; Customized functions reduce the interpretation overhead incurred by multiple single-operator function calls.&nbsp; In addition, <b>pswrap</b> lets you program directly in PostScript code, making program listings more natural and concise.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Connection Buffering</b></font>

<p><font face="Times">For efficiency, data passed from the application to the Window Server is first accumulated in a buffer.&nbsp; Data returned from the Server is similarly buffered.&nbsp; To ensure that all data in the application's buffer is sent across the connection, the buffer must be flushed.&nbsp; As long as your application makes use of Application Kit facilities, you will rarely need to flush buffers explicitly.</font>

<p><font face="Times">The buffer on the application side is flushed automatically at the following times:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Whenever the application tries to get events</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">After a timed entry executes</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This buffer can also be flushed explicitly with a call to <b>DPSFlush()</b>.&nbsp; Simple programs that just draw on the screen but don't get data from the Window Server have to call <b>DPSFlush()</b> to ensure that all PostScript code generated is flushed to the Server.&nbsp; Applications might also call <b>DPSFlush()</b> in these situations:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Before doing especially time-consuming processing in response to an event, to give the user more timely feedback</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">In GDB (the GNU debugger), to ensure that all PostScript code generated so far has been sent to the Window Server</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The buffer on the Window Server side is flushed automatically at these times:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Whenever the Server has an event or error to send the application</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Whenever the <b>flush</b> operator is executed</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Connection buffering and the fact that your application and the Window Server are separate processes executing asynchronously provide another reason for using <b>pswrap</b> functions to send drawing information to the Window Server. Code destined for the Window Server is not sent until the application-side buffer is flushed.&nbsp; Once the code arrives in the Server, it may have to wait to be executed until the Server has finished with another application's input.&nbsp; Finally, tokens are returned from the Server as they become available; token output is not synchronized with PostScript code input.</font>

<p><font face="Times">Fortunately, <b>pswrap</b> insulates you from most of the consequences of this asynchrony.&nbsp; As described above, a <b>pswrap </b>function flushes the application-side buffer for you.&nbsp; It also flushes the Window Server side buffer when a token is ready to be returned to the application.&nbsp; The returned token is checked for an internal synchronization code to ensure that the token is the correct one to return to a particular <b>pswrap</b>-generated function.&nbsp; In fact, the only time this asynchrony of execution may become evident is when error messages are received.&nbsp; An error message received at one moment may refer to a section of code sent to the Server somewhat earlier.&nbsp; However, error messages usually contain enough contextual information to allow you to determine the problem's location relatively easily.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Imaging Conventions</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In the PostScript language, all visible forms have an outline delineating the area to be colored.&nbsp; This is true both of filled figures and of simple lines.</font>

<p><font face="Times">There are two steps to drawing a filled figure:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">Construct a path around the area that's to be colored.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">Fill the area outlined by the path.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Drawing a line--whether it's open (like an arc) or closed (like a full circle)--also takes two steps:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">Construct the path where you want the line located.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">Stroke the path to color the line.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Stroking fills an outline that's constructed along either side of the path using the line width, line cap, and line join parameters of the current graphics state.&nbsp; One-half the line width falls on one side of the path and one-half on the other. This outlines the area covered by the line, with the path running through the center of the outline.&nbsp; The line cap parameter determines the shape of the outline at the ends of an open path; line join determines its shape where separate segments of the path meet.&nbsp; When the path is stroked, the outline is filled.&nbsp; The path itself has a width of 0.</font>

<p><font face="Times">Figure 4-19 illustrates the path and outline of a short curved line with a width set to 2 and butt-end line caps.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F19.gif" width=231 height=185></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-19</b></font><font face="Times">.&nbsp; Path and Outline</font>

<p><br><br>

<p><font face="Times">It's possible that a line drawn in this way will totally cover only a few pixels.&nbsp; A one-pixel-wide line drawn along a path from (4.0, 10.0) to (700.0, 183.0), for example, will touch many pixels, but cover none of them entirely.</font>

<p><font face="Times">Because figures and paths can cut across pixels in this way, it's reasonable to ask just which pixels an outline will affect.&nbsp; For the most part, the answer doesn't matter:&nbsp; Pixels are so small that you ordinarily don't need to be concerned with which ones are turned on when an outline is filled.</font>

<p><font face="Times">For the cases when you're doing detailed drawing and are concerned with this question, the remainder of this section discusses the way imaging is carried out on the NeXT MegaPixel Display and 400 dpi Laser Printer.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The General Rule</b></font>

<p><font face="Times">An outlined figure selects all the pixels that it overlaps.&nbsp; This includes all the pixels its outline completely surrounds and any pixel the outline enters, even if most of the pixel actually lies outside the area the outline encloses.&nbsp; (An outline enters a pixel if it crosses from one side to another, or if it simply cuts into the pixel without actually passing through.)</font>

<p><font face="Times">This general rule chooses the pixels that can be colored--either uniformly or in a halftone pattern--when an outline is painted.&nbsp; The examples below illustrate this principle.&nbsp; Each assumes that the drawing is done with solid, opaque paint; the pixels that are colored in the illustrations are the ones this rule selects.</font>

<p><font face="Times">Consider the outline of a white circle, like the one illustrated in Figure 4-20.&nbsp; The path defining the circumference of the circle completely encloses some pixels, but encloses only parts of others.&nbsp; Every pixel the circumference passes through is turned white, even if most of the pixel lies outside the circle.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F20.gif" width=267 height=188></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-20</b></font><font face="Times">.&nbsp; Section of a White Circle</font>

<p><br><br>

<p><font face="Times">If an outline lies on a pixel boundary but doesn't enclose or enter the pixel, the pixel isn't treated as if it were inside the outline.&nbsp; The pixel and the outlined figure don't overlap.</font>

<p><font face="Times">The 3-by-5 rectangle illustrated in Figure 4-21 has an outline that doesn't enter any pixels; it lies entirely on pixel boundaries.&nbsp; When the rectangle is filled with black paint, only the 15 pixels entirely enclosed within the outline turn black.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F21.gif" width=315 height=219></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-21</b></font><font face="Times">.&nbsp; Filled Rectangle</font>

<p><br><br>

<p><font face="Times">Figure 4-22 and Figure 4-23 illustrate two horizontal lines, each with its line width set to 1.&nbsp; The path of the line in Figure 4-22 was drawn down the center of a row of horizontal pixels--say, from (100.0, 4.5) to (800.0, 4.5).&nbsp; Its outline completely covers each pixel on its path, but it doesn't enter any in the adjacent rows.&nbsp; Therefore, only a single row of pixels is colored to show the line.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F22.gif" width=299 height=190></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-22</b></font><font face="Times">.&nbsp; Horizontal Path at Pixel Midpoint</font>

<p><br><br>

<p><font face="Times">In Figure 4-23, the path of the line was drawn slightly lower--say, from (100.0, 4.3) to (800.0, 4.3).&nbsp; The line partially overlaps two rows of pixels, the row the path passes through and the row beneath.&nbsp; Both rows are colored to display the line.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F23.gif" width=299 height=190></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-23</b></font><font face="Times">.&nbsp; Horizontal Path below Pixel Midpoint</font>

<p><br><br>

<p><font face="Times">As the two illustrations above show, an outline one-pixel wide will be displayed as a one-pixel line only if it falls midway between pixel boundaries.&nbsp; Otherwise, it will be twice as thick.</font>

<p><font face="Times">This variation in how outlines of the same width are displayed is generally not desirable.&nbsp; It's especially noticeable on-screen and especially when the outlines are thin.</font>

<p><font face="Times">To eliminate the variation, the Display PostScript system has added a parameter to the graphics state which, when true, adjusts the thickness of stroked lines so that they always approximate the width of the outline.&nbsp; With stroke adjustment, the line shown in Figure 4-23 above would turn on a single row of pixels, no matter where it's located.&nbsp; This is illustrated in Figure 4-24.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F24.gif" width=299 height=190></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-24</b></font><font face="Times">.&nbsp; Stroke Adjustment for a Path below Pixel Midpoint</font>

<p><br><br>

<p><font face="Times">Stroke adjustment is true by default on the NeXT computer.</font>

<p><font face="Times">The general rule, as stated and illustrated above (and as modified by stroke adjustment), is all that's required to select pixels if the outline encloses any area at all.&nbsp; Where an outline collapses to a single point or to a line with a width of 0, however, additional rules are needed.&nbsp; The additions are required so that:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A zero-width line can be shown using the fewest number of pixels possible.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">All figures--even points and zero-width lines drawn along pixel boundaries--can be visible.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The following two sections discuss these special rules.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Outlines with No Area</b></font>

<p><font face="Times">When, to draw a very thin line, you set the PostScript line width variable to 0, the resulting outline is identical to the path; it has no width at all.&nbsp; A zero-width outline can also result when a path that defines a filled figure doubles back on itself.&nbsp; Occasionally, an outline will collapse to a single point.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Points</b></font>

<p><font face="Times">A single point is shown by turning on a single pixel.&nbsp; If the point lies in the middle of a pixel, that pixel is the one turned on.&nbsp; If the point lies between pixels, just one of the pixels is chosen.&nbsp; The choice depends on the device.&nbsp; Figure 4-25 below illustrates how the choice is made on the NeXT MegaPixel Display and 400 dpi Laser Printer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the point lies on the vertical boundary between pixels, the pixel on the right is the one chosen.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the point lies on the horizontal boundary between pixels, the one below is chosen.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the point lies on the corner of four pixels, the one on the lower right is chosen.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F25.gif" width=280 height=190></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-25</b></font><font face="Times">.&nbsp; Pixels that Display Points</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Zero-Width Lines</b></font>

<p><font face="Times">Zero-width lines are rendered by turning on the fewest possible number of pixels to show a connected line.&nbsp; For a straight line, this is accomplished by comparing the base coordinates of its two endpoints:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the difference between the two x coordinates is greater than the difference between the two y coordinates (the line is more horizontal than vertical), exactly one pixel will be turned on in each vertical column between the two endpoints.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the difference between the two y coordinates is greater than the difference between the two x coordinates (the line is more vertical than horizontal), exactly one pixel will be turned on in each horizontal row.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the differences between the y coordinates and the x coordinates are the same (the line is drawn at a 45</font>&#176; <font face="Times">angle), exactly one pixel will be turned on in each column and in each row.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Figure 4-26 illustrates how these conventions apply to a variety of straight zero-width lines.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F26.gif" width=330 height=201></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-26</b></font><font face="Times">.&nbsp; Zero-Width Lines</font>

<p><br><br>

<p><font face="Times">To choose which pixel to turn on in a particular column or row, the conventions look only at the section of the line falling within that column or row.&nbsp; The pixel that includes the section's midpoint is the one that's chosen.&nbsp; Figure 4-27 shows how a pixel is chosen when a zero-width path passes through two pixels in the same column.&nbsp; In the illustration, the pixel on the top left is chosen over the pixel below it, because it contains the midpoint of the path segment falling within the left column.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F27.gif" width=317 height=240></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-27</b></font><font face="Times">.&nbsp; Choosing a Pixel</font>

<p><br><br>

<p><font face="Times">When the midpoint falls on the boundary between pixels, only one of the pixels is chosen.&nbsp; The choice is made for midpoints in the same way as it's made for other points (see &quot;Points&quot; and Figure 4-26).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Within a row, the pixel on the right is chosen.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Within a column, the lower of the two pixels is chosen.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Where a horizontal or vertical zero-width line lies entirely between pixels, every midpoint is on a pixel boundary.&nbsp; This is illustrated by the rectangular path in Figure 4-28.&nbsp; Here the line width was set to 0 and the path was stroked rather than filled.&nbsp; The pixels that are colored are the ones that would be chosen on the NeXT screen and laser printer.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F28.gif" width=338 height=217></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-28</b></font><font face="Times">.&nbsp; Zero-Width Line on a Rectangular Path</font>

<p><br><br>

<p><font face="Times">All the conventions discussed above for zero-width lines are used even if the outline isn't straight.&nbsp; An automatic PostScript flattening process turns a curved path into a series of very short, straight-line segments that approximate the curve.&nbsp; The conventions apply to these segments.&nbsp; (The segments are actually chords joining selected points along the curved path.)</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Half-Open Shapes</b></font>

<p><font face="Times">This section explains the principle that lies behind the general rule and some of the other imaging conventions that were illustrated above.&nbsp; It's presented for readers who would like to know the basis for the conventions.</font>

<p><font face="Times">The general rule can be restated as follows:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times">If a pixel and an outlined figure have one or more points in common, the pixel is part of the figure.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">It's fairly easy to tell that a pixel and a figure have a point in common when the point lies within the pixel and is surrounded by the outline of the figure.&nbsp; It's more problematic when the point is on a pixel boundary or on the outline itself.</font>

<p><font face="Times">To solve the problem, all shapes, whether pixels or outlined figures, are considered &quot;half-open&quot;:&nbsp; Only about half the points on the edge of the shape are included in it.&nbsp; When two figures are tiled together, each point along their common border will belong to just one of the figures.&nbsp; Similarly, the points on a border between two pixels belong to just one pixel; each point on the screen is assigned to one and only one pixel.</font>

<p><font face="Times">Since PostScript flattening turns every curve into a series of short, straight segments, the rules that determine which points on the edge of a shape belong to the shape, and which do not, need to be stated only for straight edges.&nbsp; All shapes, whether outlines or pixels, are covered by the same rules:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the edge of a shape faces exactly upward or at all leftward, the points on the edge belong to the shape.&nbsp; If the edge faces exactly downward or at all rightward, the points on the edge don't belong to the shape.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A point at the corner between two straight edges belongs to the shape if both of the edges do, or if just one edge does and the corner is concave.&nbsp; If neither edge belongs to the shape, the corner point doesn't either.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The directions stated in these rules are for the NeXT MegaPixel Display and 400 dpi Laser Printer.&nbsp; They may be different on other devices.</font>

<p><font face="Times">By these rules, each pixel includes its upper and left borders and the corner point that joins them.&nbsp; The upper left is the only corner that belongs to the pixel.</font>

<p><font face="Times">The outline of a straight zero-width line collapses to the path of the line, but is still treated as having an edge on each of its sides.&nbsp; The edges face in opposite directions.&nbsp; Following the rules stated above, the endpoints of the line--the corners between the two edges--don't belong to the line.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Clipping</b></font>

<p><font face="Times">A PostScript clipping path outlines the area where painting operators (such as <b>show</b>, <b>fill</b>, and <b>stroke</b>) can render an image.&nbsp; Like any other outline, it selects pixels according to the general rule and other conventions discussed above. Only pixels selected by both the clipping path and an outlined figure can actually be used to display the figure.</font>

<p><font face="Times">Figure 4-29 and Figure 4-30 show how clipping paths and image outlines interact.&nbsp; Both figures illustrate a rectangular path like the one shown in Figure 4-28.&nbsp; This time, however, the width of the line is set to 1 and path is made to double as the clipping path.</font>

<p><font face="Times">In Figure 4-29, the path is located exactly as it was in Figure 4-28:&nbsp; entirely on pixel boundaries.&nbsp; The outline of the one-pixel-wide line therefore covers half of every pixel on either side of its path.&nbsp; However, none of the pixels around the outside of the clipping path are within the area where drawing can occur, since the clipping path doesn't enter or enclose them.&nbsp; Only a single strand of pixels inside the clipping path is colored to display the line.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F29.gif" width=370 height=217></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-29</b></font><font face="Times">.&nbsp; Clipping Path between Pixels</font>

<p><br><br>

<p><font face="Times">In Figure 4-30, the rectangle has been shifted slightly to the left.&nbsp; Each of the vertical sections of the clipping path now passes through a column of pixels.&nbsp; On the left, both columns of pixels the outline enters are used to display it.&nbsp; One column has the clipping path running through it, so it isn't clipped from the drawing area.&nbsp; The other column is entirely surrounded by the clipping path, so it also lies within the drawing area.&nbsp; (On the right, only one of the columns lies within the drawing area.)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F30.gif" width=370 height=217></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-30</b></font><font face="Times">.&nbsp; Clipping Path Crossing Pixels</font>

<p><br><br>

<p><font face="Times">Finally, it might be helpful to return to the zero-width line illustrated in Figure 4-28, one drawn along a rectangular path lying entirely between pixels.&nbsp; What happens if the path is made into a clipping path?&nbsp; Since the path and zero-width line don't enter any pixels, only the pixels that the clipping path entirely surrounds can be used to display the line.&nbsp; As shown in Figure 4-31, just two sides of the rectangle will be visible.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F0.gif" width=370 height=217></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 4-31</b></font><font face="Times">.&nbsp; Clipped Zero-Width Rectangular Line</font></td></tr>

</table>



<p><br><br><br><br><br><br><br><br>

</body>
</html>
