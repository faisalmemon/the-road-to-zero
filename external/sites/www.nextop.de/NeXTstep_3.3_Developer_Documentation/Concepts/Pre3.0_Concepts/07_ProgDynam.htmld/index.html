<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/Concepts/Pre3.0_Concepts/07_ProgDynam.rtfd -->
<!-- Date: Sun Jun 28 19:37:43 1998 -->
<head>
<title>07_ProgDynam</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Release 3.3 Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Helvetica" size="+3"><b>7</b></font></td>

<td><font face="Times" size="+3"><i>Program Dynamics</i></font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Changes made for the current release of NeXTstep affect the information presented in this chapter.&nbsp; For details see:</b></font>

<p><img src="../../Images/sp.gif" width=19 height=1><font face="Times"><b>/NextLibrary/Documentation/NextDev/ReleaseNotes/AppKit.rtf</b></font><br>
<img src="../../Images/sp.gif" width=19 height=1><font face="Times"><b>/NextLibrary/Documentation/NextDev/ReleaseNotes/AllocInitAndNew.rtf</b></font>

<p><br><br><br><br>

<p><font face="Times">The previous chapter, &quot;Program Structure,&quot; described how a program based on the Application Kit is constructed from a small number of interconnected objects.&nbsp; This chapter shows how applications use that structure to carry out essential interactive activities:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Responding to events</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Drawing on the screen (and on the printed page)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Sending and receiving remote messages</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Because events motivate almost all program activities, the chapter begins with a discussion of event handling in the Application Kit.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Event Handling</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NeXT applications are driven by the user's actions on the keyboard and mouse--that is, by events.&nbsp; The application receives an event from the Window Server, responds to it, then looks for the next event.&nbsp; If there is no next event, the application waits until the user does something and an event is received.</font>

<p><font face="Times">The Application object, NXApp, initiates this event loop--the application's <i>main event loop</i>--when it receives a <b>run </b>message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp run];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">On each cycle of the loop, NXApp gets an event, analyzes it, and sends an appropriate message to initiate the application's response.&nbsp; It passes keyboard events to the key window and mouse events to the Window associated with the event in the event record.&nbsp; The Window, in turn, dispatches the event to one of its Views.&nbsp; Most of your program's activity will be in reaction to the messages NXApp and the application's Windows send out after receiving an event.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Some of their <i>event messages</i> will reach objects that can respond directly.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Some event messages will reach Control objects--Buttons, Sliders, Scrollers, TextFields, and the like--and will be translated into more specific <i>action messages</i> for other objects.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXApp continues to get events out of the event queue and dispatch them until the event loop is broken.&nbsp; Typically, it's broken only when the application terminates.&nbsp; If the response to an event includes a <b>terminate:</b> message,</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp terminate:self];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXApp closes all the application's windows, frees its objects, and exits the program.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The <b>terminate:</b> method takes an argument only so that it can respond to an action message, usually an action message coming from the Quit command.&nbsp; It doesn't actually looks at its argument, so it doesn't matter what value is passed.&nbsp; See &quot;Action Messages,&quot; later in this chapter, for more on the structure of these messages.</font>

<p><font face="Times">Sometimes an application's response to an event is to set up a <i>modal event loop</i> that will get all subsequent events for a short period of time.&nbsp; For example, the response to a mouse-down event may be to set up a modal loop that will collect events until the user releases the mouse button and a mouse-up event is received.&nbsp; Modal loops are set up within the main event loop in response to an event or action message.</font>

<p><font face="Times">Most of the unique behavior of your application will be encoded in class definitions for objects that can respond to event and action messages.</font>

<p><font face="Times">This section of the chapter looks at event handling in a typical application, beginning where the application itself begins, with the code that sets up its event-handling objects.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Setting Up Event-Handling Objects</b></font>

<p><font face="Times">An Objective-C program begins just as a C program does, by calling its <b>main()</b> function.&nbsp; In a program based on the Application Kit, <b>main()</b> is usually very short.&nbsp; Its job is to set up the Application object and other core objects your program needs at startup, then to turn over control of the program to them.&nbsp; It can be as short as just three or four lines of code:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[Application new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">setUp();</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp run];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp free];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this version of <b>main()</b>, the <b>new</b> method creates an Application object, NXApp, which receives a <b>run</b> message to begin getting events from the Window Server.&nbsp; When the <b>run</b> method quits, <b>free</b> cleans up after the application.</font>

<p><font face="Times">Most of the application's time is spent in the <b>run</b> method, getting and responding to events.&nbsp; But before a <b>run</b> message can be sent, the application must prepare itself for the events it's about to receive.&nbsp; It must:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Create the Windows, Views, and other objects it needs to handle events at startup.&nbsp; It's possible to create new objects at any time while the program is running, but an initial set of core objects must be in place before the first event is processed.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Initialize the objects so they're connected into a program framework.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Present the application to the user by placing the initial display on-screen and designating a Window to serve as the initial key window.&nbsp; If the application allows users to edit text or graphics within the window, it should also designate a View to show the initial selection, and then set the selection.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In the version of <b>main()</b> shown above, all this code has been segregated into the <b>setUp()</b> function.&nbsp; For some applications, it might be appropriate to define a subclass of the Application class and include setup code in a redefined version of the <b>new</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">@implementation MyApplication : Application</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">+ new</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">self = [super new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* setup code goes here */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>main()</b> function could then consist of just a single line of nested messages:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[[[MyApplication new] run] free];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When you design your application using Interface Builder, you can do most of the work of setting up your application by selecting objects from palettes and editing them on-screen.&nbsp; Interface Builder lets you graphically lay out the Windows, Views, and other interface objects your application needs, initialize them, display them, and archive them in a file for later use.&nbsp; The file can then be inserted into the __NIB segment of the application executable:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">cc ...&nbsp; -segcreate __NIB myProject.nib myProject.nib</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Here the <b>-segcreate</b> linker option copies the <b>myProject.nib</b> file into a section of the __NIB segment and assigns the section the same name as the file.</font>

<p><font face="Times">A message to NXApp to open this section takes the place of the <b>setUp()</b> function:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[Application new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp loadNibSection:&#34;myProject.nib&#34; owner:NXApp];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp run];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp free];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In the example above, the objects that were archived in <b>myProject.nib</b> are loaded into memory and connected to the object that &quot;owns&quot; them, NXApp.</font>

<p><font face="Times">Archived objects can have owners other than NXApp:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp; theHub;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[Application new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">theHub = [MyCoordinator new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp setDelegate:theHub];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp loadNibSection:&#34;newProject.nib&#34; owner:theHub];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp run];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp free];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For this example, the programmer defined a class, MyCoordinator, to contain the basic algorithms of the application--its inner workings as opposed to its interface.&nbsp; After creating an Application object, <b>main()</b> creates an instance of the MyCoordinator class, makes it the delegate of the Application object, and connects it with the user-interface objects archived in <b>newProject.nib</b>.&nbsp; Whenever a Window object is loaded from the archive, it's automatically added to NXApp's list of windows; NXApp doesn't have to be named as the Window's owner.</font>

<p><font face="Times">With Interface Builder, you can create any number of archive files (or __NIB sections), each with a different set of objects and, if desired, a different owner.&nbsp; For example, every panel the application uses could be archived separately. The archive file (or section) would contain the Panel object and all the Control objects it displays; its owner would be an object you'd design to receive action messages from the panel and coordinate its activities.&nbsp; The owner could be made the Panel's delegate; if needed, NXApp could be provided with an instance variable to keep track of the Panel's owner.</font>

<p><font face="Times">In this way, your application can build its own network of objects, all relying on the basic network of core objects described under &quot;Program Framework&quot; in the previous chapter.</font>

<p><font face="Times">Interface Builder is described in the next chapter.&nbsp; This chapter concentrates on the program structure defined in the Application Kit, and so returns to a simple version of a <b>setUp()</b> function that can be bracketed (as can <b>loadNibSection:owner:</b>) by <b>new</b> and <b>run</b> messages.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>setUp() Example</b></font>

<p><font face="Times">Interface Builder is the preferred way to program an application.&nbsp; But to show the steps required by the Application Kit for setting up an application, the code for a simple program is listed below.</font>

<p><font face="Times">There are three windows in this example program--a main menu, an information panel, and a small window where the user can enter and edit text.&nbsp; All three are illustrated in Figure 7-1.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F0.gif" width=391 height=427></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-1</b></font><font face="Times">.&nbsp; Little</font>

<p><br><br>

<p><font face="Times">This program has the basic elements of a real application, but is too simplified to be very useful, hence its name, &quot;Little.&quot;&nbsp; But despite its simplicity, it behaves like a full-fledged application.&nbsp; It can be hidden, its principal window can be miniaturized, the panel and menu disappear when it's deactivated and reappear again when it's activated, the keyboard alternatives work, the text the user types can be selected and edited, and so on.</font>

<p><font face="Times">So that you can compile this little program and try it out for yourself, the source code and a makefile for it are on-line in <b>/NextLibrary/Documentation/NextDev/Examples/Little</b>.</font>

<p><font face="Times">The entire application is written in two functions, <b>main()</b> and <b>setUp()</b>; it includes no class definitions of its own.&nbsp; The <b>main()</b> function has just four lines of code, as illustrated above and repeated below; the <b>setUp()</b> function is just 58 lines, so the whole program can be printed in a little over a page.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;appkit/appkit.h&gt;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void setUp(void)</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myWindow, myPanel, myMenu, windowText;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXRect&nbsp; aRect;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 1:&nbsp; Set up a Window ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXSetRect(&amp;aRect, 100.0, 350.0, 300.0, 300.0);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">myWindow = [Window newContent:&amp;aRect</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">style:NX_TITLEDSTYLE</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">backing:NX_BUFFERED</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">buttonMask:NX_MINIATURIZEBUTTONMASK</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">defer:NO];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myWindow setTitle:&#34;A Little Demonstration&#34;];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXSetRect(&amp;aRect, 0.0, 0.0, 300.0, 300.0);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">windowText = [Text newFrame:&amp;aRect</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">text:&#34;&#34;</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">alignment:NX_LEFTALIGNED];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[windowText setOpaque:YES];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[[myWindow contentView] addSubview:windowText];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 2:&nbsp; Set up a Panel ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXSetRect(&amp;aRect, 100.0, 700.0, 300.0, 40.0);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">myPanel = [Panel newContent:&amp;aRect</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">style:NX_TITLEDSTYLE</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">backing:NX_BUFFERED</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">buttonMask:NX_CLOSEBUTTONMASK</font><br>
<img src="../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">defer:YES];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myPanel setTitle:&#34;About Little&#34;];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myPanel removeFromEventMask:(NX_KEYDOWNMASK | NX_KEYUPMASK)];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 3:&nbsp; Set up a Menu ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">myMenu = [Menu newTitle:&#34;Little&#34;];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[[myMenu addItem:&#34;Info...&#34;</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">action:@selector(orderFront:)</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">keyEquivalent:'\0']</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">setTarget:myPanel];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myMenu addItem:&#34;Hide&#34;</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">action:@selector(hide:)</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">keyEquivalent:'h'];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myMenu addItem:&#34;Quit&#34;</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">action:@selector(terminate:)</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">keyEquivalent:'\0'];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myMenu sizeToFit];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp setMainMenu:myMenu];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 4:&nbsp; Display all windows that aren't deferred ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myWindow display];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 5:&nbsp; Move myWindow on-screen ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myWindow orderFront:nil];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 6:&nbsp; Make it the key window ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[myWindow makeKeyWindow];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*** Step 7:&nbsp; Show a selection in the key window ***/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[windowText selectAll:nil];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[Application new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">setUp();</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp run];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[NXApp free];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All the methods used in this example are defined in the Application Kit.&nbsp; Some were discussed in the previous chapter under &quot;Managing Windows&quot;; others are described in Chapter 9, &quot;User-Interface Objects.&quot;&nbsp; The <b>NXSetRect()</b> function, which assigns values to an NXRect structure, is discussed in <i>NeXTstep Reference, Volume 2</i>.</font>

<p><font face="Times">As its first act (step 1), the <b>setUp()</b> function creates a new instance of the Window class and titles it.&nbsp; It then creates a Text object the same size as the Window's content area and makes it a subview of the Window's content view.&nbsp; (It could equally as well have made the Text object the content view and freed the default content view provided by the Window object.)</font>

<p><font face="Times">Next (step 2), <b>setUp()</b> creates a Panel to serve as Little's information panel.&nbsp; The Panel is assigned a title, and keyboard events are removed from its event mask so that it can't become the key window.&nbsp; This panel will behave just like any other information panel, except for the glaring fact that it doesn't contain any information.&nbsp; Additional code would be required to draw the application's icon in the panel and provide text giving version and copyright information. (Little is too little to have any such information to impart.)&nbsp; Usually, information panels are designed in Interface Builder.</font>

<p><font face="Times">The <b>setUp()</b> function then (step 3) creates a menu with the three minimal commands every application should have:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Info command sends an <b>orderFront:</b> message to its target, the information panel, placing the panel on-screen at the front of its tier.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Hide command sends a <b>hide:</b> message that NXApp will respond to by hiding all the application's windows. The command is assigned Command-h as its keyboard alternative.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Quit command sends a <b>terminate:</b> message that NXApp will respond to by shutting down the application. Although it's not required by the user-interface guidelines, the command is assigned the common keyboard alternative Command-q.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The size of the Menu is altered so that it exactly fits the three commands, and it's made the main menu of the application.</font>

<p><font face="Times">At this point, all the objects in the application have been created and initialized.&nbsp; It remains only to present the application to the user by displaying the contents of the one window that hasn't been deferred (step 4), moving the principal Window of the application on-screen (step 5), making it the key window on launch (step 6), and setting the Text object to display an initial selection (step 7).&nbsp; Steps 5 and 6 could have been combined by using a single method, <b>makeKeyAndOrderFront:</b>.</font>

<p><font face="Times">The <b>display</b> message that <b>myWindow</b> receives in step 4 calls upon every View within its view hierarchy to draw itself.&nbsp; The images are displayed into the window's backup buffer, but nothing appears on-screen.&nbsp; A window must be reordered into the screen list for its display to be visible.&nbsp; That's the function of step 5.</font>

<p><font face="Times">It's unnecessary to supply code in step 4 to display <b>myMenu</b> and <b>myPanel</b> along with <b>myWindow</b>.&nbsp; Menus are created as deferred windows and so are displayed automatically just before they're placed on-screen.&nbsp; The Panel was also created as a deferred window in step 2, and will be displayed just before the user brings it to the screen with the Info command.</font>

<p><font face="Times">Similarly, no code is needed to put the Menu and Panel on-screen.&nbsp; When the application is activated, the Application Kit places the main menu at the location specified by the NXMenuX and NXMenuY parameters.&nbsp; By default, it's in the upper left corner of the screen.&nbsp; The Info command will put the information panel on-screen and the panel's close button will remove it again.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Opening Files</b></font>

<p><font face="Times">If the Little program had the ability to open and display files, it would be organized a bit differently.&nbsp; Instead of creating a main window (<b>myWindow</b>) at the outset, it would have waited for an instruction indicating which file to open.&nbsp; Only then would it create a Window for the file and, in actions paralleling steps 4, 5, 6, and 7 of the example program, display the file in the Window, move the Window on-screen, make it the key window, and designate an initial selection.</font>

<p><font face="Times">The instruction to open a file can come from three different sources:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the user launches an application by double-clicking an icon for one of its files, the Workspace Manager passes the name of the file to the application.&nbsp; The Application object receives an <b>openFile:ok:</b> message just before getting its first event.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the user double-clicks a file in a directory window after the application is launched, the Workspace Manager sends the application a message with the name of the file.&nbsp; Application's <b>openFile:ok:</b> method is again entrusted with the message.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the user selects a file from the application's Open panel, the application must get the name (and directory) of the file from the OpenPanel object and open the file.&nbsp; The Open panel is brought to the screen by the Open menu command, in much the same way that an information panel is.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In all three cases the application must supply the code that creates the Window, displays the file, places the Window on-screen, makes it the key window, and sets the initial selection within the window.&nbsp; But instead of doing this as part of a <b>setUp()</b> function, it's done in response to the user's selection of a file.</font>

<p><font face="Times">If the selection of a file generates an <b>openFile:ok:</b> message to the Application object, you should put this code in an <b>appOpenFile:type:</b> method defined in either an Application subclass or as part of the Application object's delegate. <b>openFile:ok:</b> does some preprocessing of the message, and sends an <b>appOpenFile:type:</b> message for the delegate or NXApp to actually open the file.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Final Initialization</b></font>

<p><font face="Times">Just before the <b>run</b> method gets its first event, it does some final initialization to make sure that the application is ready:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It activates the application, which will cause it to receive an application-activated subevent (of the kit-defined event).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It provides the application with default Listener and Speaker objects, if a Listener and Speaker weren't created in the application's setup code.&nbsp; These objects give the application the ability to communicate with the Workspace Manager and other applications.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It checks in the application with the network name server so that it will have a public port where it can receive messages from the Workspace Manager and other applications.&nbsp; The application is checked in under the name returned by the Application object's <b>appListenerPortName</b> method, which is usually the name assigned in the header to the __ICON segment of the application executable, or possibly the name passed in the first string of the NXArgv array.&nbsp; You can override <b>appListenerPortName</b> so that it returns a different name.&nbsp; If it returns NULL,, the application is assigned a private port so that it can communicate with the Workspace Manager, but it won't have a public port.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It sends an <b>openFile:ok:</b> message to NXApp, if the user launched the application by double-clicking a file icon.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>run</b> method also gives the application one last chance to do any final initialization of its own.&nbsp; It sends the Application object's delegate an <b>appDidInit:</b> message, if the delegate has a method that can respond.</font>

<p><font face="Times">The delegate's <b>appDidInit:</b> method can make any adjustments necessary for the events that are about to arrive.&nbsp; For example, if an application normally opens and displays a file, but the user launched it by double-clicking an application icon rather than a file icon, <b>appDidInit:</b> could open an empty window for the user to work in.</font>

<p><font face="Times">The argument passed in an <b>appDidInit:</b> message is the Application object's <b>id</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Event Masks</b></font>

<p><font face="Times">Each window's event mask, maintained by the Window Server, determines which events the Server can send to the application process for that window.&nbsp; See Chapter 5, &quot;Events,&quot; for information on the structure of event masks and the methods used to associate events with particular windows.</font>

<p><font face="Times">Each Window object keeps track of its own event mask through its <b>winEventMask</b> instance variable.&nbsp; The <b>eventMask </b>method returns the current mask:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp; myMask;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myMask = [myWindow eventMask];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A new menu or list has these event types in its default event mask:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-down</font></td>

<td><font face="Times">(both left and right)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-up</font></td>

<td><font face="Times">(both left and right)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-dragged</font></td>

<td><font face="Times">(both left and right)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">kit-defined</font></td>

<td></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The default mask for panels and standard windows includes this full range of events:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">key-down</font><br>
<font face="Times">key-up</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-down</font></td>

<td><font face="Times">(both left and right)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-up</font></td>

<td><font face="Times">(both left and right)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-entered</font></td>

<td></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">mouse-exited</font></td>

<td></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">kit-defined</font></td>

<td></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">system-defined</font></td>

<td></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td><font face="Times">application-defined</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Miniwindows and icons, whether in or out of the dock, have a similar event mask, but exclude key-down and key-up events.</font>

<p><font face="Times">To ensure that they work properly, you should refrain from changing the event masks of menus, lists, icons, and miniwindows.&nbsp; However, the event masks of standard windows and panels can be altered to suit the needs of your application.</font>

<p><font face="Times">If you want a window to receive an event type that's not included in the default mask, or to avoid receiving an event type that is included, you must change the Window object's event mask:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp; oldMask;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">oldMask = [myWindow setEventMask:myNewMask];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If <b>myNewMask</b> is different from the mask maintained by the Window Server for <b>myWindow</b>, <b>setEventMask:</b> changes both the Window Server's mask and <b>myWindow</b>'s <b>winEventMask</b> instance variable.&nbsp; The following code resets a default mask to include flags-changed events:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">oldMask = [myWindow setEventMask:([myWindow eventMask] |</font><br>
<img src="../../Images/sp.gif" width=376 height=1><font face="Courier" size="-1">NX_FLAGSCHANGED)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This operation could be accomplished more simply with the <b>addToEventMask:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">oldMask = [myWindow addToEventMask:NX_FLAGSCHANGED];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">There's also a method for removing event types from the current mask:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">oldMask = [myWindow removeFromEventMask:NX_APPDEFINEDMASK)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Each of these methods returns the former event mask so that you can cache it and restore it later if needed.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Asking for Particular Events</b></font>

<p><font face="Times">An application should limit the events it receives from the Window Server to just those it's interested in.&nbsp; This saves processing time, reduces the amount of code you must write, and limits potential errors from handling unwanted events.</font>

<p><font face="Times">But, for most types of events, it's best to set the window's event mask at the outset so that it will receive all the events you ever want for it.&nbsp; It's generally not a good idea to change the mask in response to events, since the user might act between the time you send the message and the time the Window Server gets around to resetting the mask.&nbsp; The delay could cause your application to miss events it expected to receive.</font>

<p><font face="Times">The principal exception to this rule arises when you want to receive mouse-dragged or mouse-moved events:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Since these events are sent continuously, as long as the mouse is in motion, it doesn't matter that the Window Server won't begin sending them until it resets the event mask.&nbsp; Missing the first in a series of mouse-dragged or mouse-moved events is usually of little consequence.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Since dispatching a continuous stream of events demands a lot of processing time, you should keep the mask for these two events set only for a limited period.&nbsp; Have your application set the Window's event mask to include mouse-dragged or mouse-moved events just before it's ready to respond to them and have it reset the mask when it's finished.&nbsp; Your application shouldn't ask for these events and then attend to other things.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A menu includes mouse-dragged events in its event mask because it must always be ready to respond to them.&nbsp; When using a menu, users typically drag through the list of menu commands.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Receiving Keyboard Events</b></font>

<p><font face="Times">The Application Kit guarantees that keyboard events are sent to the active application, regardless of whether its on-screen windows have event masks that accept keyboard events.&nbsp; This enables the application to respond to keyboard alternatives when it's active, even if it has no windows for the user to type in.</font>

<p><font face="Times">Although the event mask doesn't determine which application gets keyboard events, it does help determine which Window within the application will receive them:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Application Kit associates keyboard events with the current key window.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">For a Window to be the key window, it must have an event mask that accepts key-down events.&nbsp; The initial event mask for all Windows (except menus, miniwindows, and icons) includes key-down events, so, by default, they all are potential key windows.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Since the NeXT user interface requires every standard window to be the key window whenever it's the main window the user is working in, standard windows should keep key-down events in their event masks.&nbsp; If the window doesn't display typing, it will beep whenever it receives a key-down event.</font>

<p><font face="Times">However, if you have a panel that won't respond to keyboard events and shouldn't be marked as the key window, you must reset its mask to exclude key-down events.&nbsp; Any Window that excludes key-down events should also exclude key-up events, so this example removes both event types from the event mask:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myPanel removeFromEventMask:(NX_KEYDOWNMASK | NX_KEYUPMASK)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A Panel should remove keyboard events from its event mask if it meets all three of these tests:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It doesn't display typing.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's not an attention panel.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It doesn't have a button that the user can operate from the keyboard by pressing Return.&nbsp; Normally, such a button is only permitted in an attention panel or in a panel that displays a text field.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Receiving Timer and Cursor-Update Events</b></font>

<p><font face="Times">A Window's event mask never needs to include either timer events or cursor-update events.</font>

<p><font face="Times">Timer events are synthetic events, generated by the application when it needs them.&nbsp; Because they aren't sent across the connection from the Window Server, the event mask doesn't determine whether they can be received.&nbsp; See &quot;Using Timer Events&quot; under &quot;Modal Event Loops&quot; later in this chapter for information on how to generate these events.</font>

<p><font face="Times">Cursor-update events signal that it's time to change the cursor image.&nbsp; Applications don't respond to these events directly; the change is made by the Application Kit.</font>

<p><font face="Times">A Window receives cursor-update events if a cursor has been associated with a particular area (a cursor rectangle) located within the window and registered with the Window object.&nbsp; The Kit makes sure the application gets these events when they're needed; the event doesn't have to be included in the Window's event mask.&nbsp; However, because cursor-update events are based on mouse-entered and mouse-exited events, it's best to keep those two events in the event mask if you want to receive cursor-update events.</font>

<p><font face="Times">See &quot;Changing the Cursor&quot; later in this chapter for more information on setting cursor rectangles.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Selecting an Application, Window, and View</b></font>

<p><font face="Times">After the application's core objects have been set up, the event masks of its windows have been adjusted, and a <b>run </b>message sent, the Application object begins getting events from the Window Server.&nbsp; Most events are dispatched in messages to other objects, as described in the next section, &quot;Event Messages.&quot;</font>

<p><font face="Times">Left mouse-down events also serve to select the application, the window, and even the View that will be the focus of future events.&nbsp; The selected object's event-handling status is designated by terms that are mostly familiar from the user interface:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times"><i>active application</i></font></td>

<td><font face="Times">The application that's been selected to receive keyboard events, and to have visible menus and panels.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times"><i>key window</i></font></td>

<td><font face="Times">The Window that's been selected to handle keyboard events for the application, and to be the primary recipient of action messages from menus and panels.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times"><i>main window</i></font></td>

<td><font face="Times">The Window that's the principal focus of user actions.&nbsp; It's usually identical to the key window.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times"><i>first responder</i></font></td>

<td><font face="Times">The View that's been selected to have the first chance at responding to keyboard events and action messages sent to a Window.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The active application, key window, and main window are concepts important to the user interface and are defined in Chapter 2, &quot;The NeXT User Interface.&quot;&nbsp; The first responder is no less important, but, like all Views, is a part of the implementation of the user interface, rather than part of its definition.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>The First Responder</b></font>

<p><font face="Times">When the user clicks in a Text object, such as the one in the Little example program listed earlier under &quot;Setting Up Event-Handling Objects,&quot; it's selected to receive subsequent events, especially keyboard events.&nbsp; The click also selects the insertion point where future typing will appear.</font>

<p><font face="Times">That simple demonstration program had just one View--a Text object--displayed within its Window.&nbsp; But imagine a Window, such as the one illustrated in Figure 7-2, with four Text objects sharing its content area.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F1.gif" width=262 height=277></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-2</b></font><font face="Times">.&nbsp; Four Text Objects in a Window</font>

<p><br><br>

<p><font face="Times">By clicking in one quadrant or another, the user determines where typing will appear (which Text object will receive keyboard events).&nbsp; Only one of the four objects will show a selection or insertion point at a time.</font>

<p><font face="Times">The object that's selected to be the focus of future events for a Window is the <i>first responder</i>.&nbsp; Each Window has its own first responder, which it returns when asked:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; handler;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">handler = [myWindow firstResponder];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The first responder is typically a View object in the Window's view hierarchy, but it can be any Responder.&nbsp; At the outset, each Window is its own first responder.&nbsp; Because Windows generally can't respond to keyboard and mouse events, this is usually the same as having a <b>nil</b> first responder.</font>

<p><font face="Times">The first responder is a central actor in the handling of event and action messages.&nbsp; It receives:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Keyboard event messages (<b>keyDown:</b>, <b>keyUp:</b>, and <b>flagsChanged:</b>).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Action messages from Controls that don't have explicit targets of their own.&nbsp; This includes messages from menu commands that affect the current selection, such as the Cut, Copy, Paste, Bold, and Italic commands.&nbsp; See &quot;Action Messages,&quot; later in this chapter.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Messages that notify the first responder when the Window becomes the key window and when it stops being the key window (<b>becomeKeyWindow</b> and <b>resignKeyWindow</b>).&nbsp; See &quot;The Key Window and Main Window&quot; below.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Mouse-moved event messages (<b>mouseMoved:</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the first responder can't respond to any of these messages, its next responder is given a chance to respond.&nbsp; See &quot;Event Messages in the Responder Chain&quot; and &quot;Action Messages&quot; later in this chapter for details.</font>

<p><br><br>

<p><font face="Helvetica"><b>Changing the First Responder</b></font>

<p><font face="Times">As shown by the example illustrated in Figure 7-2 above, the Application Kit lets the user pick the first responder; the Window object alters its <b>firstResponder</b> instance variable on the basis of the left mouse-down events it receives (see &quot;Left Mouse Events,&quot; under &quot;Event Messages&quot; below).</font>

<p><font face="Times">Before making the View selected by a mouse-down event the first responder, the Window sends it an <b>acceptsFirstResponder</b> message to ask whether it accepts this role.&nbsp; By default, all Views--in fact, all Responders--answer NO, leaving the current first responder in place.&nbsp; An object can agree to be made the first responder simply by implementing an <b>acceptsFirstResponder</b> method that answers YES:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- (BOOL)acceptsFirstResponder</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return YES;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Some objects may return YES under certain circumstances and NO under others.&nbsp; If a Text object displays editable or selectable text, it answers YES.&nbsp; If the text is neither editable nor selectable, it answers NO.</font>

<p><font face="Times">If the selected View returns YES, the Window attempts to make it the first responder through its <b>makeFirstResponder:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[self makeFirstResponder:selectedView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">As used by the Application Kit, the <b>acceptsFirstResponder</b> and <b>makeFirstResponder:</b> methods permit users to alter the first responder in a carefully regulated manner.&nbsp; You can also set the first responder from within your application using the same methods.&nbsp; This is most appropriate when registering an object as the Window's initial first responder on launch.</font>

<p><font face="Times">To function as the initial first responder of a Window, a Text object needs not only to be made the first responder, it must also be assigned a selection.&nbsp; The Text class defines three methods that do both; they register a new selection and send the Window a <b>makeFirstResponder:</b> message.&nbsp; The <b>selectAll:</b> method used in the Little example earlier in this chapter selects all the object's text; the <b>selectText:</b> method does the same.&nbsp; The <b>setSel::</b> method defines a range of text to select.&nbsp; In the example below, it selects the characters at positions 52 through 190 (up to position 191):</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[windowText setSel:52 :191];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the range of text selected is 0--if both arguments to <b>setSel::</b> are the same, or there's no text for <b>selectAll:</b> and <b>selectText:</b> to select--the selection is an insertion point.&nbsp; The <b>selectAll:</b> message in the Little example will make the receiving Text object show a blinking caret for the insertion point when the program is launched and the Window becomes the key window; it won't take an initial click to select the Text object as the first responder.</font>

<p><br><br>

<p><font face="Helvetica"><b>Notification</b></font>

<p><font face="Times">The <b>makeFirstResponder:</b> method first sends the current first responder a <b>resignFirstResponder</b> message to notify it that a change is about to be made; the new first responder is then notified with a <b>becomeFirstResponder</b> message. The default implementation for both these methods is simply to return <b>self</b>.&nbsp; An object can override the default to keep track of whether it's the current first responder, or to prevent the change from being made:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If an object returns <b>nil</b> to a <b>resignFirstResponder</b> message, it refuses to be deactivated and remains the first responder.&nbsp; No <b>becomeFirstResponder</b> message is sent and <b>makeFirstResponder:</b> returns NULL.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If an object returns <b>nil</b> to a <b>becomeFirstResponder</b> message, it refuses to be the new first responder.&nbsp; Since the current first responder has already resigned, the Window is made the first responder instead.&nbsp; This returns the Window to its state before any events or <b>makeFirstResponder:</b> messages were received.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">An object could refuse to become the first responder if its internal state temporarily prevents it from responding to events and action messages.&nbsp; An object might refuse to give up being the first responder if it needs to receive additional events.&nbsp; For example, an object that asks the user to type a directory name might remain the first responder until it receives the name of a valid directory.</font>

<p><br><br>

<p><font face="Helvetica"><b>Accepting First Responder Status</b></font>

<p><font face="Times">An object should agree to be the first responder (by returning YES to an <b>acceptsFirstResponder</b> message) only if it needs to receive some of the event and action messages that are directed to a first responder.&nbsp; These messages were listed above and include, most prominently:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Keyboard event messages</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Action messages that aren't hard-wired to a specific target</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Action messages from the Controls within the Font panel and from menu commands such as Cut, Copy, and Paste fit this description.&nbsp; They affect the current selection, which can change from Window to Window and from View to View.&nbsp; More precisely, they affect the current selection of the first responder in the key window or main window.</font>

<p><font face="Times">Any View that displays material that the user can select or edit must be able to respond to untargeted action messages like these, and therefore must accept first responder status.&nbsp; In the Application Kit, for example, Text objects, TextFields, and Forms agree to be the first responder when they display editable text, whereas Buttons, Sliders, and Scrollers always refuse.</font>

<p><font face="Times">Most objects that refuse to be the first responder fit into one of two categories:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If an object responds only to mouse events, it can set up its own modal loop to get all the events it needs, except the mouse-down events that initiate the loop.&nbsp; It doesn't have to be the first responder to receive mouse-down event messages.&nbsp; See &quot;Modal Event Loops,&quot; later in this chapter, for a description of this type of object.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If an object inherits from View simply so that it can draw on the screen, not so that it can respond to events, it won't want any events at all.&nbsp; The event messages it receives will be passed on to its next responder.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>The Key Window and Main Window</b></font>

<p><font face="Times">The Application Kit changes the key window (and main window) in response to left mouse-down events received from the Window Server.&nbsp; If the window associated with the event isn't already the key window, it's made the new key window provided that it has an event mask that accepts key-down events.&nbsp; Unless the window is a panel, it's also made the main window.&nbsp; The main window changes only when the key window does.</font>

<p><font face="Times">Each Window object keeps track of whether it's the key window or main window:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; keyStatus, mainStatus;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">keyStatus = [myWindow isKeyWindow];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mainStatus = [myWindow isMainWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Application object can identify which of its Windows is the key window and main window:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; key, main;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">key = [NXApp keyWindow];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main = [NXApp mainWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These two methods return <b>nil</b> if the application isn't active or if there is no key window or main window.</font>

<p><br><br>

<p><font face="Helvetica"><b>Changing the Key Window</b></font>

<p><font face="Times">You can alter the key window (and main window) programmatically with the <b>makeKeyWindow</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow makeKeyWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method can also be performed indirectly, through the <b>makeKeyAndOrderFront:</b> method. <b>makeKeyAndOrderFront:</b> combines a <b>makeKeyWindow</b> message with an <b>orderFront:</b> message.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow makeKeyAndOrderFront:self];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For the Window that receives a (direct or indirect) <b>makeKeyWindow</b> message to actually be made the key window, it must be on-screen and must accept key-down events.&nbsp; For it also to be made the main window, it must be on-screen, accept key-down events, and not be a Panel.&nbsp; The <b>canBecomeMainWindow</b> method returns whether these three conditions are true:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; potentialMain;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">potentialMain = [myWindow canBecomeMainWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Since the key window and main window belong only to the active application, the receiving Window's application must also be the active application when a <b>makeKeyWindow</b> message is sent.&nbsp; If it's not, the message serves only to register the intended key window (and main window) for the next time the application is activated.&nbsp; The user can override this intention simply by clicking another window.</font>

<p><font face="Times">Programmatically making a Window the key window is appropriate only in a limited number of situations:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">After the user acts in a panel that's the key window, the panel should return key-window status to the main window. For example, when the Font panel sets the font of the current selection, it makes the main window (where the selection is located) the key window.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">To respond to a remote message, the application might need to designate an appropriate key window.&nbsp; After receiving a message to open a file, for example, the application should make the window that displays the file the key window.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">An initial key window is designated in the application's setup code.&nbsp; For example, the Little demonstration program listed under &quot;Setting Up Event-Handling Objects&quot; above sent a <b>makeKeyWindow</b> message to its principal Window as part of its <b>setUp()</b> function.&nbsp; Since the application wasn't active at the time the message was sent, it served only to register the Window as the desired key window (and main window) once the application was activated.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Notification</b></font>

<p><font face="Times">When the key window changes, the new key window is notified with a <b>becomeKeyWindow</b> message.&nbsp; If the Window also becomes the main window, it's notified with a <b>becomeMainWindow</b> message.&nbsp; The former key window and main window are notified of their lost status with <b>resignKeyWindow</b> and <b>resignMainWindow</b> messages:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[thatWindow resignKeyWindow];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[thisWindow becomeKeyWindow];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[thatWindow resignMainWindow];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[thisWindow becomeMainWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These messages are sent whenever the key window or main window changes, no matter what the reason.&nbsp; The change could be caused by:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A left mouse-down event deactivating one application and activating another</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A left mouse-down event within another window of the same application</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The user hiding an application, and thus deactivating it</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The user unhiding an application, and thus activating it</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The user closing the key window or main window</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The user miniaturizing the key window or main window</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A <b>makeKeyWindow</b> message in the active application</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In other words, the messages exactly parallel the changes in window status that the user sees.&nbsp; See Chapter 2 for more on how user actions affect a window's status.</font>

<p><font face="Times">When any of the four messages are generated by a left mouse-down event, they're sent before any <b>becomeFirstResponder</b> and <b>resignFirstResponder</b> messages that might be generated by the same event.</font>

<p><font face="Times">The Window class defines methods that can respond to all four messages shown above.&nbsp; Each method records the Window's change in status and notifies the Window's delegate of the change, provided the delegate has a method that can respond to the message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[self delegate] windowDidBecomeKey:self];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[self delegate] windowDidResignKey:self];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[self delegate] windowDidBecomeMain:self];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[self delegate] windowDidResignMain:self];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Window also passes <b>becomeKeyWindow</b> and <b>resignKeyWindow</b> messages on to its first responder, if the first responder can respond.&nbsp; In the Application Kit, the Text object uses these messages to learn when to begin blinking the caret marking the insertion point and when to stop.&nbsp; The caret should blink only in the Text object that will display the user's typing--that is, only in the first responder of the key window.</font>

<p><font face="Times">Your application can use these notification messages to keep itself current with the user's actions.&nbsp; For example, you may want to make sure that the PrintInfo object cached by the Application object reflects the document in the key window.&nbsp; You might also want to update panels (such as an &quot;inspector&quot; panel) so that they display information appropriate for the main window.</font>

<p><font face="Times">To take advantage of the notification, you must implement methods that can respond either to the messages sent to the Window or to the ones sent to its delegate.&nbsp; The methods you define in a Window subclass should perform the default versions defined in the Window class:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- becomeKeyWindow</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[super becomeKeyWindow];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>The Active Application</b></font>

<p><font face="Times">When a left mouse-down event selects a new active application, it generates an application-activated subevent (of the kit-defined event).&nbsp; The subevent is sent to the application even before the mouse-down event.</font>

<p><font face="Times">When one application is activated, another might be deactivated, so a mouse-down event may also cause an application-deactivated subevent (also of the kit-defined event) to be sent to the current active application.&nbsp; The active application is always deactivated before another application is activated, so the application-deactivated subevent is sent before the application-activated subevent.&nbsp; But since they're sent to different processes, it's not determined which one will be acted on first.</font>

<p><font face="Times">When the user hides an application, an application-deactivated subevent is generated, but no application-activated subevent.</font>

<p><font face="Times">The <b>isActive</b> method returns the application's current status:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; activeStatus;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">activeStatus = [NXApp isActive];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>activeApp</b> method returns a user object (an integer) identifying the PostScript execution context of the active application:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp; activeOne;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">activeOne = [NXApp activeApp];</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Changing the Active Application</b></font>

<p><font face="Times">Usually, applications are activated by left mouse-down events that spawn application-activated and application-deactivated subevents.&nbsp; But the Application Kit is sometimes called upon to activate an application in the absence of an event.&nbsp; An application is activated when:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's launched.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It receives a message to open a file.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It's returned to the screen after being hidden.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In the first two cases, the activation is conditional:&nbsp; The application will become active only if there's no current active application.&nbsp; This condition is usually met because the Workspace Manager deactivates the current active application both when it launches a new application and when it sends an inactive application an <b>openFile:ok:</b> message.&nbsp; The condition won't be met only if the user chooses another application to work in before the target application has a chance to activate.</font>

<p><font face="Times">If your application accepts messages (other than <b>openFile:ok:</b> messages) from other applications, it may need to activate itself in response:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp activateSelf:NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The NO flag indicates that the activation is conditional.&nbsp; This method may generate application-activated subevents. With YES as an argument, the activation is unconditional; it will force the current active application to be deactivated and so may also generate application-deactivated subevents for another application.</font>

<p><font face="Times">In general, protocols between cooperating applications require the application receiving a message to activate itself conditionally, if it needs user interaction to do its work.&nbsp; The sending application should deactivate itself so the receiving application can become active:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp deactivateSelf];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If, in response to a message, an application activates itself unconditionally, it should restore the previous active application (the one sending the message) when it's finished.&nbsp; The <b>activateSelf:</b> method returns the PostScript execution context of the previous active application:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp; lastActive</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">lastActive = [NXApp activateSelf:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The number can be used to reactivate the application later:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp activate:lastActive];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Instead of using <b>activateSelf:</b> for unconditional activation, applications can also use the <b>unhide:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp unhide:anId];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>unhide:</b> includes an <b>activateSelf:</b> message (with YES as its argument) and also ensures that the windows of the newly activated application aren't hidden.</font>

<p><br><br>

<p><font face="Helvetica"><b>Notification</b></font>

<p><font face="Times">When the Application object receives an application-activated subevent from the Window Server, it first does what's necessary to activate the application.&nbsp; It then sends itself a <b>becomeActiveApp</b> message.&nbsp; An application-deactivated subevent generates a <b>resignActiveApp</b> message.</font>

<p><font face="Times">The methods that respond to these two messages simply notify the Application object's delegate of the change in status, if the delegate has a method that can handle the message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[self delegate] appDidBecomeActive:self];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[self delegate] appDidResignActive:self];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The sole purpose of <b>becomeActiveApp</b> and <b>resignActiveApp</b> messages is to give your application a way of coordinating its activities with changes in its status.&nbsp; You can take advantage of this opportunity either by implementing <b>appDidBecomeActive:</b> and <b>appDidResignActive:</b> methods for the delegate or by overriding Application's <b>becomeActiveApp</b> and <b>resignActiveApp</b> methods in a subclass definition.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Event Messages</b></font>

<p><font face="Times">As the Application object gets events from the Window Server, it dispatches them as Objective-C messages to other objects.&nbsp; With few exceptions, NXApp sends every event to a Window object:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Keyboard events are sent to the key window.&nbsp; (However, Command key-down events, potential keyboard alternatives, can be sent to any Window.)</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Mouse events are sent to the Window associated with the event--that is, to the Window whose window number is recorded in the <b>window</b> component of the event record.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The window-moved, window-resized, and window-exposed subevents of the kit-defined event are also sent to the Window associated with the event.&nbsp; (The window-resized subevent isn't currently used by the Application Kit. However, should window-resized subevents be posted or placed in the event queue, the Kit would dispatch them to the window in the event record.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the event is a keyboard or mouse event, the Window usually sends it on to one of the objects in its view hierarchy.&nbsp; It handles kit-defined subevents itself.</font>

<p><font face="Times">The events that NXApp doesn't dispatch to a Window are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Application-defined events, which NXApp handles itself with the aid of its delegate.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The application-activate and application-deactivate subevents of the kit-defined event.&nbsp; These two subevents are handled internally by the Application Kit; your objects never need to respond to them directly, though they can be notified when the application is activated or deactivated.&nbsp; See &quot;Selecting an Application, Window, and View&quot; above.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Subevents of the system-defined event.&nbsp; All but the power-off subevent are used internally by objects defined in the Kit; your application never has to deal with them.&nbsp; The power-off subevent is handled by the Workspace Manager, which notifies all the applications it launched that the power is about to go off.&nbsp; Applications generally respond to the Workspace Manager's message rather than to the event itself.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Timer events.&nbsp; The Application object doesn't dispatch timer events; you should ask for them only when you're prepared to get them out of the event queue yourself.&nbsp; See &quot;Using Timer Events&quot; under &quot;Modal Event Loops&quot; later in this chapter.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Cursor-update events, which are used internally by the Application Kit.&nbsp; See &quot;Changing the Cursor&quot; later in this chapter.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The object that receives an event from the Application object, or from a Window, gets it in the form of an <i>event message</i>--a message to apply a method named after the event type or subtype it reports.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Event Category</b></font></td>

<td><font face="Helvetica"><b>Method</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Mouse events</font></td>

<td nowrap><font face="Times">mouseDown:</font></td>

<td><font face="Times">(for the left mouse button)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap></td>

<td nowrap><font face="Times">mouseUp:</font></td>

<td><font face="Times">(for the left mouse button)</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap></td>

<td nowrap><font face="Times">mouseDragged:</font></td>

<td><font face="Times">(for the left mouse button)</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">rightMouseDown:</font></td>

<td><font face="Times">(for the right mouse button)</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">rightMouseUp:</font></td>

<td><font face="Times">(for the right mouse button)</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">rightMouseDragged:</font></td>

<td><font face="Times">(for the right mouse button)</font></td></tr>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">mouseMoved:</font></td>

<td></td></tr>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">mouseEntered:</font></td>

<td></td></tr>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">mouseExited:</font></td>

<td></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Keyboard events</font></td>

<td><font face="Times">keyDown:</font><br>
<font face="Times">keyUp:</font><br>
<font face="Times">flagsChanged:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Kit-defined subevents</font></td>

<td><font face="Times">windowExposed:</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><img src="../../Images/sp.gif" width=100 height=1><font face="Times">windowMoved:</font></td>

<td></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><img src="../../Images/sp.gif" width=100 height=1><font face="Times">windowResized:</font></td>

<td></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">System-defined subevents</font></td>

<td><font face="Times">powerOff:</font></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Application-defined events</font></td>

<td><font face="Times">applicationDefined:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In each case, the method takes a single argument, a pointer to the event record.&nbsp; By its very name the event message identifies the event type or subtype; its argument passes along all the other available information about the event.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The Application Kit and this documentation take the point of view of a right-handed user.&nbsp; The primary mouse button, whether left or right, generates &quot;left mouse events&quot; and the other mouse button, if it functions differently than the primary button, generates &quot;right mouse events.&quot;&nbsp; If a user enables the left mouse button to bring the main menu to the cursor, it will generate right mouse events and the right mouse button will generate left mouse events.&nbsp; If neither button is enabled to bring the main menu to the cursor, both buttons generate left mouse events.</font>

<p><font face="Times">The Application Kit implements default versions of methods that respond to event messages.&nbsp; Some have default behavior that your application can inherit and rely on.&nbsp; Others--especially those for keyboard and mouse events--do little or nothing.&nbsp; You must either implement your own methods so that your application can respond to the events in its own way, or make use of the objects provided in the Kit with defined responses to event messages:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Text object responds to keyboard events by formatting and displaying the user's typing.&nbsp; It responds to mouse events by altering the selection and insertion point.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Control objects (such as Buttons, Sliders, and TextFields) capture keyboard and mouse events and turn them into action messages for other objects.&nbsp; By implementing a method that can respond to an action message, you can add specific behavior to your application without directly responding to the event message.&nbsp; (Action messages are described in a later section.)</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">ScrollViews capture the mouse events that scroll one (larger) View within another (smaller) View, and do the scrolling for you.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The following sections discuss how event messages are dispensed and the Kit's default response to each one.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Keyboard Events</b></font>

<p><font face="Times">The Application object sends keyboard events to the key window, which passes them on as event messages to its first responder.</font>

<p><font face="Times">There's just one exception to this rule.&nbsp; When the Application object gets a key-down event, it checks whether the Command key was down at the time of the event.&nbsp; If it was, NXApp first tries to pass the event as a potential keyboard alternative--a keystroke that can activate a menu item or a button.&nbsp; Only after determining that no object will respond to the keyboard alternative does NXApp distribute it as an ordinary key-down event.&nbsp; See &quot;Keyboard Alternatives,&quot; later in this section, for more information.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Left Mouse Events</b></font>

<p><font face="Times">Users can select an object on the screen (a View) by moving the cursor so that it points to the object and pressing the left mouse button.&nbsp; The mouse-down event is sent to the object the user selects as a <b>mouseDown:</b> event message. Mouse-dragged and mouse-up events that follow the mouse-down event are sent to the same object.</font>

<p><font face="Times">However, mouse-dragged and mouse-up events generally aren't distributed through event messages.&nbsp; Once an object receives a mouse-down event, its <b>mouseDown:</b> method can set up its own event loop to get these events until the user releases the mouse button.&nbsp; See &quot;Modal Event Loops,&quot; later, for details.</font>

<p><br><br>

<p><font face="Helvetica"><b>Hit Testing</b></font>

<p><font face="Times">When it receives a mouse-down event, the Window object uses View's <b>hitTest:</b> method to look for the View in which the cursor was located when the mouse button was pressed--the View that contains the coordinates of the mouse-down event's <b>location</b> component.&nbsp; If <b>location</b> is within more than one View, <b>hitTest:</b> picks the View that's lowest in the view hierarchy.</font>

<p><font face="Times"><b>hitTest:</b> searches through a <b>subviews</b> list by starting at the end and working its way back toward the beginning.&nbsp; This gives the last subview to draw the first opportunity to accept the event.&nbsp; If the cursor is located in an area shared by two overlapping subviews of the same superview, as illustrated in Figure 7-3, the subview on top gets the event.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F2.gif" width=216 height=120></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-3</b></font><font face="Times">.&nbsp; Overlapping Subviews</font>

<p><br><br>

<p><font face="Helvetica"><b>Trapping the First Event</b></font>

<p><font face="Times">A left mouse-down event selects more than just the object that's to receive subsequent mouse events.&nbsp; It can also select:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The active application, if the mouse-down event spawns application-activated and -deactivated subevents.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The key window (and main window), if the Window that receives the event isn't already the key window.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The first responder, if the View associated with the event accepts first-responder status.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When a left mouse-down event is used to select a new key window, and possibly a new active application, you may not want it to do anything more.</font>

<p><font face="Times">Suppose, for example, that the user has two of the Quadrant windows illustrated above in Figure 7-2, &quot;Four Text Objects in a Window,&quot; on-screen at the same time; each of the windows has Text objects displaying editable text.&nbsp; By clicking first in one window, then in another, the user can repeatedly alter the key window.&nbsp; If the click were passed through to the Text object each time, it would also select a new first responder and alter the current text selection or insertion point.&nbsp; This would make it nearly impossible to select a window without also selecting text.</font>

<p><font face="Times">To prevent this from happening, you can trap mouse-down events that choose the key window before they change the first responder and before they're sent through as event messages to Views within the Window's view hierarchy.</font>

<p><font face="Times">Whenever a Window receives a left mouse-down event that makes it the key window, it sends the View that was selected by the event an <b>acceptsFirstMouse</b> message before passing it the event.&nbsp; If the View returns YES, the Window will send it a <b>mouseDown:</b> message for the event.&nbsp; If the View returns NO, the mouse-down event won't be sent to the View, and neither will the mouse-dragged and mouse-up events that follow the mouse-down.</font>

<p><font face="Times">In general, Views that display material that the user can select or edit should return NO to an <b>acceptsFirstMouse </b>message; other Views should return YES.&nbsp; In the Application Kit, Text objects, TextFields, and Forms refuse the first series of left mouse events, but Sliders, Buttons, and Scrollers accept them.</font>

<p><font face="Times">The default response of the <b>acceptsFirstMouse</b> method defined in the View class is NO.&nbsp; To change the default in your View subclass, simply implement your own version of the method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- (BOOL)acceptsFirstMouse</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return YES;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Selecting the First Responder</b></font>

<p><font face="Times">The Application Kit tries to make the View selected by a left mouse-down event the first responder.&nbsp; If it answers YES to an <b>acceptsFirstResponder</b> message, its Window is sent a <b>makeFirstResponder:</b> message as discussed above under &quot;The First Responder.&quot;</font>

<p><font face="Times">If the View selected by the mouse-down event is one that accepts being the first responder, but the current first responder refuses to give up that status (returns <b>nil</b> to a <b>resignFirstResponder</b> message), the mouse-down event and the following mouse-dragged and mouse-up events are sent to the current first responder, rather than to the View selected by the mouse-down event.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Right Mouse Events</b></font>

<p><font face="Times">Right mouse events within the key window are distributed very much like left mouse events.&nbsp; When the user presses the right mouse button while the cursor is in the key window, hit testing finds the View where the cursor is located.&nbsp; The right mouse-down event and subsequent right mouse-dragged and right mouse-up events are sent to that View.</font>

<p><font face="Times">However, Views rarely respond to right mouse events.&nbsp; In the user interface, these events are reserved for bringing a copy of the main menu to the cursor.&nbsp; Therefore, <b>rightMouseDown:</b> event messages generally are passed up the responder chain from next responder to next responder until they reach the Window, which then makes sure that the main menu gets the event.&nbsp; The main menu sets up a modal event loop that collects all subsequent right mouse events until the mouse button is released.&nbsp; (Event loops are discussed under &quot;Modal Event Loops&quot; later in this chapter, and passing event messages up the responder chain is discussed under &quot;Event Messages in the Responder Chain&quot; below.)</font>

<p><font face="Times">This pattern of distribution permits a View that needs to distinguish between left and right mouse events to get both.&nbsp; At the same time, it ensures that right mouse events that aren't intercepted by a View do the job that they're meant to do in the user interface.</font>

<p><font face="Times">Unlike left mouse events, right mouse events don't change the active application, key window, or first responder, and they aren't trapped if the View returns NO to an <b>acceptsFirstMouse</b> message.</font>

<p><font face="Times">Only Views in the key window are given a chance to respond to right mouse events.&nbsp; If the Window that receives a right mouse event isn't the key window, it turns the event over to the main menu.&nbsp; This restriction makes the user interface for right mouse events match that of left mouse events more exactly.&nbsp; When the user begins working within a window using the left mouse button, the window becomes the key window.&nbsp; To ensure that the user's work with the right mouse button also takes place in the key window, the window has to be the key window before any right mouse events can be distributed to its Views.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Mouse-Exited and Mouse-Entered Events</b></font>

<p><font face="Times">An application can receive mouse-exited and mouse-entered events, provided:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">At least one of its Windows has an event mask that accepts the events, and</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The application has set a tracking rectangle within the Window.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Mouse-exited events are generated when the cursor leaves the tracking rectangle; mouse-entered events occur when the cursor enters the rectangle.</font>

<p><font face="Times">A Window can have any number of tracking rectangles.&nbsp; So that particular events can be matched to particular rectangles, you can assign each rectangle an identifying tag that will be reported back in the event records of the mouse-exited and mouse-entered events that it generates.</font>

<p><font face="Times">Window's <b>setTrackingRect:inside:owner:tag:left:right:</b> method sets a tracking rectangle:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; rect;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[aView getFrame:&amp;rect];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[aView superview] convertRect:&amp;rect toView:nil];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow setTrackingRect:&amp;rect</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">inside:YES</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">owner:aView</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">tag:3</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">left:YES</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">right:NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this example, <b>aView</b>'s frame rectangle is made the tracking rectangle, and <b>aView</b> itself is made the tracking rectangle's owner, the object responsible for handling the events the rectangle generates.&nbsp; The owner need not be a View, but it should be a Responder.&nbsp; When the Window receives mouse-exited and mouse-entered events, it dispatches <b>mouseExited:</b> and <b>mouseEntered:</b> event messages directly to the owner.</font>

<p><font face="Times">The <b>convertRect:toView:</b> message above transforms <b>aView</b>'s frame rectangle to the correct coordinate system for making it a tracking rectangle.&nbsp; A tracking rectangle is specified in the base coordinate system for the window--here in <b>myWindow</b>'s base coordinate system.&nbsp; Since a View records its <b>frame</b> instance variable in its superview's coordinate system, the message is sent to <b>aView</b>'s superview.&nbsp; See &quot;Converting Coordinates&quot; later in the chapter for more on <b>convertRect:toView:</b> and similar methods.</font>

<p><font face="Times">The rectangle's tag distinguishes it from other tracking rectangles within the same window.&nbsp; The inside flag indicates whether the cursor starts out inside the rectangle (YES) or outside it (NO).&nbsp; If it's YES, the first event received for the rectangle will be a mouse-exited event, regardless of where the cursor is actually located.&nbsp; If NO, the first event will be be a mouse-entered event.</font>

<p><font face="Times">The last two arguments to <b>setTrackingRect:inside:owner:tag:left:right:</b> specify whether events are to be generated for the rectangle only if one or both of the mouse buttons is being held down.&nbsp; In this example, mouse-exited and mouse-entered events will be generated only while the left mouse button is down.&nbsp; This makes these events somewhat akin to left mouse-dragged events.</font>

<p><font face="Times">A tracking rectangle remains in effect until another rectangle with the same tag is set for the Window, or until it's removed by the <b>discardTrackingRect:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow discardTrackingRect:3];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Don't assign negative tags to tracking rectangles.&nbsp; The Application Kit uses negative numbers to identify the tracking rectangles that generate cursor-update events.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Kit-Defined Events</b></font>

<p><font face="Times">The application-activated and application-deactivated subevents of the kit-defined event don't generate event messages.&nbsp; However, they do initiate <b>becomeActiveApp</b> and <b>resignActiveApp</b> messages to the Application object, and <b>appDidBecomeActive:</b> and <b>appDidResignActive:</b> messages to the Application object's delegate, as discussed under &quot;The Active Application&quot; above.&nbsp; You should respond to these subevents only by writing methods that can respond to these messages.</font>

<p><font face="Times">The subevents of the kit-defined event that concern the state of a window generate event messages to the Window object whose window number is listed in the event record.&nbsp; The Window class defines methods to respond to these messages.</font>

<p><br><br>

<p><font face="Helvetica"><b>Window-Moved</b></font>

<p><font face="Times">The <b>windowMoved:</b> method updates the Window's <b>frame</b> instance variable to record the new location of the window. It then informs the Window's delegate of the move by sending it a <b>windowDidMove:</b> message, if the delegate has a method that can respond.&nbsp; The delegate can use Window's <b>getFrame:</b> method to get the window's new location in screen coordinates:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- windowDidMove:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXRect&nbsp; rect;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[sender getFrame:&amp;rect];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The location of a window is important to the Application Kit as it responds to user actions that manipulate windows, but it's generally of little use to an application.&nbsp; Most applications shouldn't care where the user places windows and won't need to do anything special when a window moves.</font>

<p><br><br>

<p><font face="Helvetica"><b>Window-Exposed</b></font>

<p><font face="Times">The <b>windowExposed:</b> method redisplays part (sometimes all) of the Window's contents.&nbsp; The area that's redisplayed is a rectangle calculated from the event record.&nbsp; The location of the rectangle is taken from the event record's <b>location </b>component and its size is taken from the <b>data.compound.misc.L</b> component.</font>

<p><font face="Times">After sending a display message, <b>windowExposed:</b> informs the Window's delegate with a <b>windowDidExpose: </b>message, if the delegate has a method that can respond.</font>

<p><br><br>

<p><font face="Helvetica"><b>Window-Resized</b></font>

<p><font face="Times">The <b>windowResized:</b> method redisplays the Views within a window in response to a window-resized subevent. However, this method isn't currently used.&nbsp; When the user resizes a window by dragging its resize bar, no window-resized subevents are generated.&nbsp; Instead, the Window's frame view, which contains the resize bar, resizes the Window and redisplays its Views.&nbsp; Applications are informed of the resizing, not by an event, but by notification messages sent to the Window's delegate (or, in the absence of a delegate, to the Window itself):</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">As the user drags an outline of the window, repeated <b>windowWillResize:toSize:</b> messages are sent to the delegate, if the delegate implements a <b>windowWillResize:toSize:</b> method.&nbsp; These messages give the delegate a chance to determine the new size of the window.&nbsp; The first argument to <b>windowWillResize:toSize:</b> is the <b>id</b> of the Window object.&nbsp; The second argument passes a pointer to an NXSize structure containing the proposed new width and height of the window.&nbsp; The delegate can alter these values to constrain the size of the window.&nbsp; It can be kept within maximum and minimum size limits, or be made to grow and shrink by defined amounts (as is the Workspace Manager's Directory Browser).&nbsp; The on-screen outline will reflect the altered values the delegate places in the NXSize structure.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">After the user releases the mouse button and just before the window is redisplayed in its new size, the delegate is informed with a <b>windowDidResize:</b> message, if it has a method that can respond.&nbsp; The argument passed in a <b>windowDidResize:</b> message is the <b>id</b> of the Window object, which can provide the new dimensions of the window in response to a <b>getFrame:</b> message.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If a Window doesn't have a delegate, or its delegate doesn't respond to <b>windowWillResize:toSize:</b> and <b>windowDidResize:</b> messages, these messages will be sent to the Window instead--but only if the Window can respond.&nbsp; This means that you can implement <b>windowWillResize:toSize:</b> and <b>windowDidResize:</b> methods either in a Window delegate or in a Window subclass.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Application-Defined Events</b></font>

<p><font face="Times">If your application makes use of application-defined events, you must write the code to respond to them.</font>

<p><font face="Times">When it receives the event, the Application object sends itself an <b>applicationDefined:</b> event message.&nbsp; But its <b>applicationDefined:</b> method does nothing more than pass the same message on to its delegate, if the delegate can respond.</font>

<p><font face="Times">You can implement an <b>applicationDefined:</b> method either in a subclass of the Application class, or in a class definition for the Application object's delegate.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>System-Defined Events</b></font>

<p><font face="Times">Most subevents of the system-defined event are handled internally by the Application Kit.&nbsp; Only one, the power-off subevent, results in event messages.</font>

<p><font face="Times">Power-off subevents are generated when the user presses the Power key on the keyboard.&nbsp; The Window Server broadcasts the event to every application with on-screen windows.</font>

<p><font face="Times">One of the applications that receives the event is the Workspace Manager.&nbsp; It puts up a panel that requires users to confirm the power-off instruction or cancel it.&nbsp; If the user doesn't rescind the instruction, the Workspace Manager sends each application it launched a <b>powerOffIn:andSave:</b> message.&nbsp; This is the same message it sends to its applications when the user wants to log out.</font>

<p><font face="Times">The <b>powerOffIn:andSave:</b> message is received by the Application object, which terminates the main event loop and sends its delegate an <b>appPowerOffIn:andSave:</b> message, if the delegate has a method that can respond.&nbsp; The first argument to both methods is the number of milliseconds before the power goes off.&nbsp; The second argument is currently meaningless and should be ignored.</font>

<p><font face="Times">The Application object's delegate can ask for more time by sending the Workspace Manager an <b>extendPowerOffBy:actual:</b> message.&nbsp; It should then save files and take whatever other steps are necessary to prepare for the shutdown.</font>

<p><font face="Times">Applications that are launched in the workspace ignore the power-off subevent and attend only to the messages received from the Workspace Manager.&nbsp; Applications that are launched from the command line won't get these messages and must respond to <b>powerOff:</b> event messages instead.</font>

<p><font face="Times">NXApp is the object that receives the <b>powerOff:</b> message.&nbsp; If the application was launched by the Workspace Manager, its <b>powerOff:</b> method does nothing.&nbsp; Otherwise it sends its delegate an <b>appPowerOff:</b> message, if the delegate can respond.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Cursor Coordinates</b></font>

<p><font face="Times">Methods that respond to mouse events may want to note the exact location of the cursor on-screen.&nbsp; The coordinates in the <b>location</b> component of the event record are given in the window's base coordinate system; they can be translated to the receiving View's local coordinates by the <b>convertPoint:fromView:</b> method.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXPoint&nbsp; where;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">where = eventPtr-&gt;location;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[self convertPoint:&amp;where fromView:nil];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method transforms a point expressed in the coordinate system of its second argument to the receiving View's reference coordinate system.&nbsp; When the second argument is <b>nil</b>, as it is here, it's assumed that the point is expressed in the base coordinate system.&nbsp; <b>convertPoint:fromView:</b> alters the NXPoint structure referred to by its first argument and returns a pointer to the same structure.</font>

<p><font face="Times">Note that once the <b>location</b> component of the event record has been transformed from the base coordinate system, other objects in the view hierarchy will be unable to rely on it.&nbsp; For this reason, it's first assigned to the local variable <b>where</b> before being passed to <b>convertPoint:fromView:</b> in the example above.</font>

<p><br><br>

<p><font face="Helvetica"><b>Querying the Cursor</b></font>

<p><font face="Times">If the process of responding to an event takes some time and you need a more recent indication of the cursor's location, Window's <b>getMouseLocation:</b> method provides one:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXPoint&nbsp; where;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow getMouseLocation:&amp;where];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method places the current cursor location in the NXPoint structure referred to by its argument; it returns <b>self</b>.&nbsp; The point is specified in the receiving Window's base coordinate system and can be altered by the <b>convertPoint:fromView:</b> method illustrated above.</font>

<p><br><br>

<p><font face="Helvetica"><b>Testing the Cursor's Location</b></font>

<p><font face="Times">Methods that respond to events often must test whether the cursor is located in a particular View or in a particular region of a View, usually expressed as a rectangle.&nbsp; The function that makes the test is <b>NXMouseInRect()</b>.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp;&nbsp;&nbsp; inside;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; rect;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView getBounds:&amp;rect];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">inside = NXMouseInRect(&amp;where, &amp;rect, NO);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This function takes a pointer to the cursor location and a pointer to a rectangle, here <b>myView</b>'s bounds rectangle, and returns whether the point is inside the rectangle.&nbsp; The third argument, NO in the example, is best explained by examining what's meant by the &quot;location of the cursor.&quot;</font>

<p><font face="Times">The cursor's location, as reported in the event record or by <b>getMouseLocation:</b>, is, in fact, the location of just one point on the cursor, its <i>hot spot</i>.&nbsp; Since the cursor is an image, displayed with pixels, the hot spot corresponds visually to a particular pixel--in effect a &quot;hot pixel.&quot;&nbsp; The pixel chosen by the hot spot is the one cursor pixel that users can't drag off-screen.</font>

<p><font face="Times">When testing whether the cursor is inside a rectangle, what we really want to know is whether the pixel corresponding to the hot spot is inside the rectangle.</font>

<p><font face="Times">The hot spot has no fractional coordinates, so it always lies on a corner where four pixels meet.&nbsp; On the MegaPixel Display, the pixel chosen by the hot spot is, in accord with the rules described under &quot;Imaging Conventions&quot; in Chapter 4, &quot;Drawing,&quot; the one that lies below it and to its right.&nbsp; In Figure 7-4, small arrows point to the potential hot spots that would chose the &quot;hot pixels&quot; labeled &quot;A&quot; and &quot;B&quot;.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F3.gif" width=190 height=190></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-4</b></font><font face="Times">.&nbsp; Testing the Cursor's Location</font>

<p><br><br>

<p><font face="Times">In this diagram, pixel A lies inside the shaded rectangle and pixel B lies outside it, but both hot spots lie on the edge of the rectangle.&nbsp; To correctly determine which hot spot chooses a pixel inside the rectangle and which does not, <b>NXMouseInRect()</b> must know the polarity of the y-axis.&nbsp; When passed NO as the third argument, it assumes that y coordinate values increase from bottom to top, so hot spots with y coordinate values that match the minimum rectangle values are excluded from the rectangle.&nbsp; When passed YES, it assumes that the y-axis has been flipped, with coordinate values increasing from top to bottom, so hot spots with y coordinates equal to the maximum rectangle values are the ones excluded.</font>

<p><font face="Times">Flipped coordinate systems are described under &quot;View Coordinate Systems&quot; later in this chapter.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Event Messages in the Responder Chain</b></font>

<p><font face="Times">Every Window has its own responder chain of Views.&nbsp; When a View receives a keyboard or mouse event message that it can't handle, the message is passed to its next responder.</font>

<p><font face="Times">The chain is established as each View object has its <b>nextResponder</b> instance variable initialized to another object.&nbsp; As a default, and with the sole exception of the content view, a View's next responder is its superview.&nbsp; The content view's next responder is the Window.&nbsp; The Window ends the responder chain; its next responder is <b>nil</b>.</font>

<p><font face="Times">You can add other Responders into this default chain:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[anotherResponder setNextResponder:[self nextResponder]];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[self setNextResponder:anotherResponder];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The mechanism for passing events along the chain is inherited from the Responder class.&nbsp; Responder has a default implementation for the methods that respond to keyboard and mouse event messages.&nbsp; Its methods don't take any action in response to the event; they simply send the same message on to the next responder:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- keyDown:(NXEvent *)theEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[nextResponder keyDown:theEvent];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For an object to actually do anything with key-down events, it must be provided with a <b>keyDown:</b> method that overrides the Responder version.</font>

<p><font face="Times">For example, suppose that a mouse-down event makes <b>redView</b> the first responder.&nbsp; The application then receives a key-down event that gets passed to <b>redView</b> in the form of a <b>keyDown:</b> message.&nbsp; However, <b>redView</b> isn't equipped to handle a key-down event; it doesn't have access to a <b>keyDown:</b> method that overrides the method defined in the Responder class.&nbsp; The Responder method passes the event--again as a <b>keyDown:</b> message--to <b>redView</b>'s next responder, its superview.</font>

<p><font face="Times">Figure 7-5 illustrates how the chain works.&nbsp; It shows part of the inheritance hierarchy for <b>redView</b> and two other objects, <b>greenView</b> and <b>blueView</b>.&nbsp; When <b>redView</b> receives a <b>keyDown:</b> message, it applies the version of this method it inherits from the Responder class.&nbsp; As shown above, Responder's <b>keyDown:</b> method simply passes the message on to <b>redView</b>'s next responder, <b>greenView</b>.&nbsp; <b>greenView</b> also applies Responder's version of <b>keyDown:</b>, passing the message on to its next responder, <b>blueView</b>.&nbsp; <b>blueView</b>'s class defines a <b>keyDown:</b> method that overrides Responder's default.&nbsp; It applies this method and breaks the chain.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F4.gif" width=468 height=287></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-5</b></font><font face="Times">.&nbsp; Responder Chain</font>

<p><br><br>

<p><font face="Times">By repeated iterations of the Responder method, an event message can be passed up the view hierarchy to the content view and Window.&nbsp; If it's passed all the way up the chain, and no object responds with a method that overrides Responder's default, the event won't be handled.&nbsp; It's the application's responsibility to respond to all the mouse and keyboard events it asks for.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Action Messages</b></font>

<p><font face="Times">Control objects give content to the user's mouse and keyboard actions.&nbsp; They translate the event messages they receive into more precise, application-specific action messages for other objects.&nbsp; A Control can be viewed as simply a tool that permits the user to give instructions to the application, a device that stands between the user and the object that will ultimately respond to the user's event.</font>

<p><font face="Times">The Control classes defined in the Application Kit--Button, Scroller, Slider, TextField, Matrix, and Form--are described in Chapter 9 under &quot;Controls.&quot;&nbsp; Control itself is an abstract superclass; it defines a paradigm for inter-object communication--action messages--that its subclasses inherit and other objects emulate.&nbsp; You can define your own Control subclasses to take advantage of this paradigm.</font>

<p><font face="Times">Controls use ActionCell objects of various sorts to hold information about their internal state.&nbsp; The ActionCell superclass defines instance variables for the two elements essential to an action message:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">target</font></td>

<td><font face="Times">The object that's responsible for responding to the user's action on the Control</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">action</font></td>

<td><font face="Times">The method that specifies what the target is to do</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Control class defines an instance variable that can identify the sender of an action message:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">tag</font></td>

<td><font face="Times">A number that the target can use to distinguish among Controls that send the same action messages</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Each ActionCell can also have its own tag.</font>

<p><font face="Times">A Control can send a different action message to a different target for each ActionCell it contains.&nbsp; Matrix and Form objects typically contain more than one ActionCell, but Buttons, Sliders, and TextFields are single-Celled.&nbsp; The content area of a Menu is filled by a Matrix of ActionCells.&nbsp; Scrollers aren't composed of Cells; they define their own <b>target</b>, <b>action</b>, and <b>tag</b> instance variables.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>The Target</b></font>

<p><font face="Times">The target is the object that receives the action message.&nbsp; Setting a target</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myControl setTarget:messageHandler];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myMatrix setTarget:messageHandler at:rowSix :colZero];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">ties the Control to a specific object that's expected to respond to all its action messages; no other object will ever have the opportunity to respond.&nbsp; Typically, the target is another View in the same Window as the Control, the Window's delegate, or an object of your own design.</font>

<p><font face="Times">The <b>target</b> method returns the Control's current target:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; bullseye;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">bullseye = [myControl target];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Some Controls can't be tied to a particular target.&nbsp; The Cut command in the Edit menu, for example, can delete material first in one window, then in another.&nbsp; The user selects the receiver of the Cut command's action message by picking the key window (and main window) and choosing the Window's first responder.&nbsp; The command deletes the selection owned by the first responder in the key or main window.</font>

<p><font face="Times">Controls like this have their targets set to <b>nil</b>.&nbsp; The mechanism for dispatching action messages finds an appropriate receiver for the message each time the message is sent.&nbsp; This mechanism is explained under &quot;Action Messages in the Responder Chain&quot; below.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>The Action</b></font>

<p><font face="Times">The <b>action</b> instance variable names the method the target is asked to perform.&nbsp; It's a method selector, assigned with the Objective-C <b>@selector()</b> operator:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myControl setAction:@selector(doBehave:)];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myMatrix setAction:@selector(doBeNice:) at:rowOne :colThree];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Action methods take a single argument, the <b>id</b> of the Control object that sends the message.&nbsp; This argument enables the receiver to ask the Control for more information, if it's needed.&nbsp; For example, a target receiving an action message from a Button might want to learn the Button's current state:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- doReact:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; setting;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">setting = [sender state];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Each Control dispatches action messages in response to a different set of user events:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A Button generally sends action messages on a mouse-up event, if it also received the mouse-down event and the cursor is inside its frame rectangle when the mouse button goes up.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A repeating Button sends action messages continuously, as long as the user holds the mouse button down and keeps the cursor inside its frame rectangle.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A Slider also can send action messages continuously, as long as the mouse button is held down.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A Slider that doesn't send continuous action messages can send them on a mouse-down event, on a mouse-up event, or for each mouse-dragged event that repositions its knob.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A TextField sends action messages when the user presses Return after entering data in the field, but only if the data is acceptable.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Although the ActionCell class provides for only one action selector, Control (and Cell) subclasses can define any number of other actions for special circumstances, and dispatch them when they want to.&nbsp; For example, a Control could send one message when it's clicked and another when it's double-clicked.</font>

<p><font face="Times">Some Controls may want to give their targets an opportunity to take action when the mouse button first goes down, and so may dispatch an action message on a mouse-down event.&nbsp; For example, a Button that caused its target to change shape might want the target to assume its altered shape, temporarily, on a mouse-down event so that the user can see what the Button does.&nbsp; The change would become permanent only on a mouse-up event.</font>

<p><font face="Times">The method that Controls use to send action messages is <b>sendAction:to:</b>.&nbsp; It takes the action selector and target object, which can be <b>nil</b>, as arguments.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myControl sendAction:@selector(doReact:) to:messageHandler];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the selector for the action message is NULL, no message is sent.</font>

<p><font face="Times">Since both the target and the action are passed as parameters to <b>sendAction:to:</b>, Control subclasses are free to define multiple target objects and action selectors for special circumstances.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Action Messages in the Responder Chain</b></font>

<p><font face="Times">When the target of an action message is <b>nil</b>, the Control that's about to send the message must look for an appropriate receiver.&nbsp; It conducts its search in a prescribed order:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It begins with the first responder in the current key window and follows <b>nextResponder</b> links up the responder chain to the Window object.&nbsp; After the Window object, it tries the Window's delegate.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the main window is different from the key window, it then starts over with the first responder in the main window and works its way up the main window's responder chain to the Window object and its delegate.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Next, it tries the Application object, NXApp, and finally the Application object's delegate.&nbsp; NXApp and its delegate are the receivers of last resort.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This search path is illustrated below in Figure 7-6.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F5.gif" width=431 height=254></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-6</b></font><font face="Times">.&nbsp; Search Path</font>

<p><br><br>

<p><font face="Times">The search stops as soon as an appropriate receiver is found for the action message.&nbsp; Most often, the first responder in the key or main window will handle it.</font>

<p><font face="Times">To end the search for a receiver, two things are required:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">An object must have a method that can receive the action message.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The method must return a value other than <b>nil</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If an object has access to a method matching the action selector, the message is sent.&nbsp; If the object then returns a value other than <b>nil</b>, the search for a receiver is aborted.</font>

<p><font face="Times">By returning <b>nil</b>, a method permits objects farther along the search path to receive the same action message.&nbsp; This is useful when the first responder and all the Views above it in the view hierarchy should have a chance to react to the message.&nbsp; However, returning <b>nil</b> isn't typical.&nbsp; Most methods that handle action messages should return <b>self</b> to stop the message from going any farther.</font>

<p><font face="Times">This way of finding receivers for untargeted action messages serves a variety of different messages.&nbsp; It locates the receiver for:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Action messages destined for the first responder, such as those sent from the Font panel or by the Cut, Copy, and Paste commands.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Action messages destined for the key window or main window, such as those sent by the Miniaturize and Close commands.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Action messages destined for the Application object, such as those sent by the Hide and Quit commands.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">You can take advantage of the fact that the Application object and its delegate end the search path by implementing default methods that respond to action messages in an Application subclass, or in the delegate's class.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Kit-Defined Action Methods</b></font>

<p><font face="Times">The Application Kit defines a number of methods that can respond to action messages; they each take a single argument, the <b>id</b> of the sender.&nbsp; Often the Kit-defined method doesn't do anything with the argument; it's there just so the method selector can be used in action messages.</font>

<p><font face="Times">The chart below lists, by class, some of the action methods defined in the Kit:</font>

<p><br><br><br>

<p><font face="Times"><b>Application</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">hide:</font></td>

<td><font face="Times">Hides the application's windows for the Hide command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">unhide:</font></td>

<td><font face="Times">Unhides and activates the application.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">stop:</font></td>

<td><font face="Times">Stops the main event loop without terminating the application.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">terminate:</font></td>

<td><font face="Times">Terminates the application and exits for the Quit command.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Button and ButtonCell</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">performClick:</font></td>

<td><font face="Times">Simulates clicking the Button or ButtonCell.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Control and Cell</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">takeIntValueFrom:</font></td>

<td><font face="Times">Resets receiver's <b>int</b> value to that of the sender.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">takeFloatValueFrom:</font></td>

<td><font face="Times">Resets receiver's <b>float</b> value to that of the sender.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">takeDoubleValueFrom:</font></td>

<td><font face="Times">Resets receiver's <b>double</b> value to that of the sender.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">takeStringValueFrom:</font></td>

<td><font face="Times">Resets receiver's string value to that of the sender.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Matrix</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">selectAll:</font></td>

<td><font face="Times">Selects all the Cells in the Matrix.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">selectText:</font></td>

<td><font face="Times">Selects all the text in the first editable Cell of the Matrix (or in the last editable Cell if the message is the result of Shift-Tab).</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>PopUpList</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">popUp:</font></td>

<td><font face="Times">Puts the PopUpList on-screen under the cursor.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>TextField</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">selectText:</font></td>

<td><font face="Times">Selects all the text in the TextField object.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Text</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">selectAll:</font></td>

<td><font face="Times">Makes the Text object the first responder and selects all its text.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">selectText:</font></td>

<td><font face="Times">Makes the Text object the first responder and selects all its text, just as <b>selectAll: </b>does.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">copy:</font></td>

<td><font face="Times">Copies selected text to the pasteboard for the Copy command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">paste:</font></td>

<td><font face="Times">Retrieves text from the pasteboard and replaces the current selection with it, for the Paste command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">delete:</font></td>

<td><font face="Times">Deletes selected text (without putting it in the pasteboard) for the Delete command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">cut:</font></td>

<td><font face="Times">Copies selected text to the pasteboard and deletes it for the Cut command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">changeFont:</font></td>

<td><font face="Times">Dispatches a <b>convertFont:</b> message to the sender, allowing the sender to convert the font of the current selection (or of all the text if the Text object doesn't support multiple fonts).</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">superscript:</font></td>

<td><font face="Times">Raises the current selection above the baseline.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">subscript:</font></td>

<td><font face="Times">Lowers the current selection below the baseline.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">unscript:</font></td>

<td><font face="Times">Returns the current selection to the baseline.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>View</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">printPSCode:</font></td>

<td><font face="Times">Prints the View, including all its subviews.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>Window</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">miniaturize:</font></td>

<td><font face="Times">Miniaturizes the Window.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">deminiaturize:</font></td>

<td><font face="Times">Restores a miniaturized window to the screen.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">orderFront:</font></td>

<td><font face="Times">Places the Window at the front of its tier on-screen.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">orderBack:</font></td>

<td><font face="Times">Puts the Window at the back of its tier on-screen, but in front of the workspace window.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">orderOut:</font></td>

<td><font face="Times">Removes the Window from the screen.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">makeKeyAndOrderFront:</font></td>

<td><font face="Times">Makes the Window the key window and puts it on-screen at the front of its tier.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">performClose:</font></td>

<td><font face="Times">Simulates clicking the close button for the Close command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">performMiniaturize:</font></td>

<td><font face="Times">Simulates clicking the miniaturize button for the Miniaturize command.</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">printPSCode:</font></td>

<td><font face="Times">Prints all the Views within the Window (including the frame view).</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">smartPrintPSCode:</font></td>

<td><font face="Times">Prints all the Views within the Window (including the frame view) and tries to intelligently format the pages.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>The Tag</b></font>

<p><font face="Times">Each Control can be assigned an arbitrary integer as a tag.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myControl setTag:34];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Each ActionCell in a multi-Celled Control can also be assigned a tag:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myMatrix setTag:14 at:rowOne :colFour];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The tag is a convenience for identifying the Control or Cell in the code you write.&nbsp; If a number of different Controls have the same target and the same action selector, the target can use the tag to distinguish among the Controls:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- doReact:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">switch( [sender tag] ) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case 0:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case 1:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case 2:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">default:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>The Sender as an Argument</b></font>

<p><font face="Times">The method for dispatching action messages, <b>sendAction:to:</b>, is defined in the Control class and is therefore available only to Control subclasses.</font>

<p><font face="Times">Nevertheless, one crucial element of the action-message paradigm is emulated throughout the Application Kit and in many application programs:&nbsp; Many objects include their own <b>id</b>s in the messages they send.&nbsp; This serves to reduce the number of arguments that the message requires.&nbsp; Instead of passing every possible value that any receiver might need, each receiver can send messages back to the sender to get just the values it requires.</font>

<p><font face="Times">For example, when a Matrix object tells one of its cells to draw itself, it informs the cell which Matrix sent the message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[aCell drawSelf:&amp;rect inView:self];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The first argument specifies the rectangle where the Cell is to draw; any other information the Cell may need, it can get from the Matrix.</font>

<p><font face="Times">If you define a method that requires information from the sender, it's a good idea to make the sender's <b>id</b> be the method's only argument.&nbsp; This both simplifies the calling sequence and makes the method's selector eligible to be used in action messages.</font>

<p><font face="Times">If you define a method that requires no arguments, it sometimes makes sense to add an object <b>id</b> as an argument anyway.&nbsp; Even though the method won't look at the <b>id</b> it's passed, it too will be eligible to respond to action messages.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Keyboard Alternatives</b></font>

<p><font face="Times">Most graphic objects respond when the user both presses and releases the mouse button as the cursor points to the object.&nbsp; Objects can be programmed to respond in an identical manner to a single keystroke (usually modified by the Command key), no matter where the mouse is pointing.&nbsp; By treating the keystroke as equivalent to a mouse click, they provide users with a <i>keyboard alternative</i> to the mouse.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>From Key Down to Key Equivalent</b></font>

<p><font face="Times">Keyboard alternatives are implemented by translating a key-down event into a <b>performKeyEquivalent:</b> message. <b>performKeyEquivalent:</b> takes a single argument, a pointer to the event record of the key-down event.&nbsp; To implement a keyboard alternative, an object must look into the record to see which character was typed.&nbsp; If the character corresponds to the character cached by the object as its <i>key equivalent</i>, it returns YES; otherwise, it returns NO.&nbsp; For example:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- (BOOL)performKeyEquivalent:(NXEvent *)theEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( theEvent-&gt;data.key.charCode == myKeyEquivalent ) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[self doWhatAMouseClickWouldDo];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">return( YES );</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return( NO );</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method identifies the key equivalent by the character code in the event record; it ignores the character set and key code.&nbsp; The key equivalent is the character that was typed, not the key that was pressed.&nbsp; Uppercase &quot;F&quot; and lowercase &quot;f&quot; are different key equivalents, and both are distinct from Control-F.&nbsp; If the user changes the way keys are mapped to character codes, the key that must be pressed to activate a keyboard alternative may also change.&nbsp; The default keyboard mapping is given in the <i>NeXT Technical Summaries</i> manual.</font>

<p><font face="Times">The Button class implements a <b>performKeyEquivalent:</b> method much like the one shown above, so Buttons have a built-in ability to respond to keyboard alternatives.&nbsp; The Matrix class implements a more elaborate version that gives each ButtonCell (including each MenuCell) the opportunity to have its own key equivalent.&nbsp; You need only name the character.&nbsp; <b>setKeyEquivalent:</b> makes the assignment and <b>keyEquivalent</b> returns the current key equivalent:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned short&nbsp; theKey;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myButton setKeyEquivalent:'f'];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">theKey = [myButton keyEquivalent];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">By default, all other event-handling objects (all Responders) return NO when sent a <b>performKeyEquivalent: </b>message.&nbsp; To have one of these objects respond to a key equivalent, you must override the default with a <b>performKeyEquivalent:</b> method of your own, like the one illustrated above.</font>

<p><font face="Times">Making sure that an object can respond to the appropriate keystroke (by setting its key equivalent or providing it with a <b>performKeyEquivalent:</b> method) is only the first step.&nbsp; You may also have to take some steps to ensure that <b>performKeyEquivalent:</b> messages reach the object.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Command Key-Down Events</b></font>

<p><font face="Times">The Application Kit interprets every key-down event as a potential keyboard alternative, if the Command key was pressed at the time of the event.&nbsp; It distributes the event in a way that's designed to initiate <b>performKeyEquivalent: </b>messages to Views that may have key equivalents.</font>

<p><font face="Times">The first step in this process is for the Application object to pass the event, in the form of a <b>commandKey:</b> message, to the Windows in its window list.</font>

<p><font face="Times">The second step is for a Window to translate the <b>commandKey:</b> message into a <b>performKeyEquivalent:</b> message to its Views.</font>

<p><font face="Times">The third step is to pass the <b>performKeyEquivalent:</b> message down the view hierarchy until it reaches the View that will respond.</font>

<p><br><br>

<p><font face="Helvetica"><b>commandKey: Messages</b></font>

<p><font face="Times">In the main event loop, the Application object checks every key-down event it receives from the Window Server to see whether the Command key flag is set.&nbsp; If it is, instead of dispatching the event like other key-down events, NXApp sends a <b>commandKey:</b> message to each Window in its window list, until one of the Windows returns YES.&nbsp; By default, a Window object does nothing more than return NO, causing NXApp to send the message to the next Window in the list.</font>

<p><font face="Times">In this way, a Command key-down event is distributed to all the Windows in the application, not just to those that would normally respond to keyboard events, and not just to those that are in the screen list.&nbsp; Hidden and miniaturized Windows also get the message.</font>

<p><br><br>

<p><font face="Helvetica"><b>Initiating performKeyEquivalent: Messages</b></font>

<p><font face="Times">By simply returning NO, a Window effectively prevents the objects within its view hierarchy from responding to the event.&nbsp; If there are Views within the Window that might want to handle the key equivalent, its <b>commandKey:</b> method must give them a chance to respond before returning.</font>

<p><font face="Times">The Panel class implements a version of <b>commandKey:</b> that translates the message to a <b>performKeyEquivalent: </b>message for its contentView:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- (BOOL)commandKey:(NXEvent *)theEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return [contentView performKeyEquivalent:theEvent];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method returns the same value that's returned to it by <b>performKeyEquivalent:</b>&nbsp; If <b>performKeyEquivalent: </b>returns YES, <b>commandKey:</b> returns YES to terminate the search for an object that can handle the key equivalent.&nbsp; If <b>performKeyEquivalent:</b> returns NO, <b>commandKey:</b> also returns NO, and the <b>commandKey:</b> message is passed to the next Window in the window list.</font>

<p><br><br>

<p><font face="Helvetica"><b>Passing performKeyEquivalent: Messages</b></font>

<p><font face="Times">View objects inherit a version of <b>performKeyEquivalent:</b> that recursively passes the message down the view hierarchy from subview to subview, stopping only when a subview accepts the key equivalent and returns YES.&nbsp; This default doesn't enable a View to respond to a key equivalent, but it lets the message reach the lowest branches of the view hierarchy, where the Control objects most likely to respond are located.</font>

<p><font face="Times">If a Window knows exactly which of its Views might respond to the Command key-down event, it can send the <b>performKeyEquivalent:</b> message directly to them.&nbsp; If not, it can send the message to its contentView and rely on View's default method to pass the message down the view hierarchy.&nbsp; The Panel method illustrated above does just that.</font>

<p><br><br>

<p><font face="Helvetica"><b>Unhandled Messages</b></font>

<p><font face="Times">Through the combination of <b>commandKey:</b> and <b>performKeyEquivalent:</b> messages described above, a Command key-down event can make its way down the entire window list in search of a View that can respond to the character that was typed.&nbsp; Once that View is found, YES is returned up the chain to the Application object, which originated the <b>commandKey:</b> message.&nbsp; Since a Responder has been found for the key-down event, the Application object does nothing more.</font>

<p><font face="Times">However, if no View is found to handle the Command key-down event, the Application object receives NO in return. Since no object has yet responded to the event, NXApp dispatches it like any other key-down event; it sends the event to the key window, which dispatches a <b>keyDown:</b> message to its first responder.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>View Methods</b></font>

<p><font face="Times">Any View can originate <b>performKeyEquivalent:</b> messages based on the ordinary key-down events it receives. Key-down events are normally passed to the key window's first responder as <b>keyDown:</b> messages.&nbsp; To handle the event as a keyboard alternative, the first responder must translate it to a <b>performKeyEquivalent:</b> message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- keyDown:(NXEvent *)theEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( theEvent-&gt;flags &amp; NX_COMMANDMASK )</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[self performKeyEquivalent:theEvent];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return( self );</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this example, the first responder doesn't do anything with key-down events except treat them as potential keyboard alternatives.&nbsp; It checks to be sure the Command key was pressed at the time of the event and, if it was, initiates the <b>performKeyEquivalent:</b> message.</font>

<p><font face="Times">You may sometimes want objects to respond to keyboard alternatives without the Command key.&nbsp; For example, if you display a graphic keypad on the screen, with a numbered Button for each of the keys, you'd probably want the user to be able to simply press the numbered keys on the keyboard to operate the keypad.&nbsp; You probably wouldn't want to force the user to press the Command key to get the key equivalents to work.&nbsp; In this case the <b>keyDown:</b> method can be simplified:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- keyDown:(NXEvent *)theEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self performKeyEquivalent:theEvent];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Assuming that the first responder in the example above doesn't implement its own version of <b>performKeyEquivalent:</b>, the View version would pass the <b>performKeyEquivalent:</b> message to its first subview, then to each of the subview's subviews, then on to their subviews.&nbsp; If none of them recognized the key equivalent as its own, the message would be passed to the first responder's second subview, and so on, until a View responded YES or the subviews list was exhausted.</font>

<p><font face="Times">If an object has a key equivalent and it also has subviews with their own key equivalents, its version of <b>performKeyEquivalent:</b> should perform the View method so that its subviews can have a chance to respond in case it can't:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- (BOOL)performKeyEquivalent:(NXEvent *)theEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( theEvent-&gt;data.key.charCode == myKeyEquivalent ) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[self doWhatAMouseClickWouldDo];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">return( YES );</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return( [super performKeyEquivalent:theEvent] );</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Changing the Cursor</b></font>

<p><font face="Times">The cursor, usually a small diagonal arrow, sometimes changes to another image.&nbsp; It changes for two very different reasons:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When the cursor is over a particular area of the key window, it may change to indicate the type of operation that's permitted within that area.&nbsp; For example, the cursor changes to an I-beam when it's over selectable text in the key window.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When the active application is busy and unable to accept events, the cursor may change to the &quot;wait cursor&quot; image.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This section explains how to use the Application Kit to change the cursor image.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Defining a Cursor</b></font>

<p><font face="Times">A Cursor is a kind of Bitmap object.&nbsp; For the MegaPixel Display, it should be a bitmap 16 pixels wide by 16 pixels high. Cursors are generally opaque images surrounded by transparent pixels.&nbsp; When it's placed on-screen (by a Sover compositing operation), you see only the irregular opaque shape.</font>

<p><font face="Times">The Application Kit provides three ready-made Cursor objects for commonly used cursor images:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXArrow is the standard arrow cursor.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXIBeam is the I-beam used for selectable text.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXWait is the &quot;wait cursor&quot; that indicates that the application is busy.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">You can create your own Cursor object just as you would any other Bitmap.&nbsp; The example below creates an &quot;X&quot; cursor and puts the hot spot (the point that's aligned with the mouse) where the two lines cross.</font>

<p><font face="Times">First a function that draws a small &quot;X&quot; on a transparent background is defined:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">defineps drawX()</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">0 0 16 16 Clear compositerect</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">1 setalpha</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">0 setgray</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">1 setlinewidth</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">newpath</font><br>
<img src="../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">2 2 moveto 15 15 lineto stroke</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">15 2 moveto&nbsp; 2 15 lineto stroke</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">endps</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Next, the function is used to create the Cursor bitmap:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; myImage;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myImage =[Cursor newSize:16.0 :16.0 type:NX_ALPHABITMAP];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myImage lockFocus];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">drawX();</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myImage unlockFocus];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Finally, the hot spot is set at the upper left corner of the pixel at the center of the image.&nbsp; By default, Cursors are drawn in a flipped coordinate system, with y coordinate values increasing from top to bottom, so that point is (8.0, 8.0):</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXPoint&nbsp; mySpot;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mySpot.x = mySpot.y = 8.0;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myImage setHotSpot:&amp;mySpot];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Cursors can also be created from TIFF files, by imaging bitmap data, or by using any of the other variety of methods provided in the Bitmap class.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Cursor Rectangles</b></font>

<p><font face="Times">If you associate a cursor image with a rectangular area within a window, the Application Kit will change the cursor to that image whenever the window is the key window and the cursor is over the rectangle.&nbsp; For example, if you provide a little scratch pad in a window where the user can doodle, you could change the cursor to a pencil when it's over the pad.</font>

<p><font face="Times">The actual work of changing the cursor is handled by the Kit.&nbsp; Your application need only define a <i>cursor rectangle</i> and associate it with a particular Cursor object.&nbsp; When the cursor passes into the rectangle, it will be changed to the image defined by the object.&nbsp; When it moves out of the rectangle, it will revert to the previous image.</font>

<p><font face="Times">Cursor rectangles are implemented as specially marked tracking rectangles.&nbsp; Mouse-entered and mouse-exited events for the rectangles are translated into cursor-update events.&nbsp; The Kit receives these events and changes the cursor as required; your application should never need to look at them.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Because cursor rectangles are based on tracking rectangles, a window must permit mouse-entered and mouse-exited events in its event mask for automatic cursor updating to work.&nbsp; It doesn't matter whether or not the mask also contains cursor-update events.</font>

<p><font face="Times">A window can have more than one cursor rectangle, but if any two intersect, one of them must be totally inside the other.&nbsp; Cursor rectangles can be nested or they can cover independent areas within the window, but they can't partially overlap.</font>

<p><font face="Times">Cursor rectangles exist only when the window is the key window.&nbsp; When a window ceases to be the key window, its cursor rectangles are discarded.&nbsp; When it becomes the key window again, they're reestablished.&nbsp; The Window object keeps a record of all its cursor rectangles so that it can discard them and reestablish them again--without any help from the application--as it loses and regains key window status.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Registering and Resetting Cursor Rectangles</b></font>

<p><font face="Times">Although cursor rectangles are recorded and maintained by Windows, they're established by Views.&nbsp; Often a View uses its own frame rectangle as a cursor rectangle, or perhaps the frame rectangles of its subviews or Cells.</font>

<p><font face="Times">A Window's set of cursor rectangles is therefore apt to change as its Views change.&nbsp; Any number of circumstances can invalidate a Window's cursor rectangles, including these:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A View is resized.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The window is resized, causing the Views inside it to be resized or to adjust their locations.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The contents of a View are scrolled.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Window's view hierarchy is rearranged.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For example, if a View is removed from the view hierarchy, some cursor rectangles might need to be removed with it. Scrolling a View that contains a cursor rectangle could relocate the rectangle.&nbsp; If the rectangle is scrolled completely out of view, it should be removed from the Window's record of cursor rectangles.&nbsp; If it's partly in view and partly out, it should be updated to reflect only the part that's visible.&nbsp; If the rectangle stays in view, but shifts its position, the Window should record its new location.</font>

<p><font face="Times">It's therefore not enough for a View to register its tracking rectangles just once.&nbsp; It must be prepared to reregister them whenever the need arises.</font>

<p><font face="Times">Before getting an event in the main event loop (or in a modal loop for an attention panel), the Application Kit checks whether the key window's cursor rectangles remain valid.&nbsp; Any of the circumstances listed above might invalidate them.&nbsp; They can also be explicitly invalidated by the application:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow invalidateCursorRectsForView:myView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If any rectangles are invalid, they're discarded and <b>resetCursorRects</b> messages are initiated to reregister the correct rectangles.&nbsp; Each View should define its own version of the <b>resetCursorRects</b> method.&nbsp; Because a new Window is flagged as having invalid cursor rectangles, this method will not only respond to periodic <b>resetCursorRects</b> messages as the application runs, it will also set up the View's cursor rectangles in the first place.&nbsp; To make automatic cursor updating work for your application, all you need to do is implement a <b>resetCursorRects</b> method for any View you want associated with a special cursor.</font>

<p><font face="Times">A <b>resetCursorRects</b> method should contain one or more <b>addCursorRect:cursor:</b> messages to register the View's cursor rectangles with the Window.&nbsp; Each message associates a Cursor object with a particular rectangle.&nbsp; In the example below, <b>resetCursorRects</b> sets up a cursor rectangle equal to the receiving View's bounds rectangle and associates it with the &quot;X&quot; cursor defined above.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- resetCursorRects</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self addCursorRect:&amp;bounds cursor:myImage];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Matrix, Form, and TextField classes use this mechanism to display an I-beam cursor over editable text.&nbsp; You don't have to register these cursor rectangles yourself.</font>

<p><font face="Times">The <b>removeCursorRect:cursor:</b> method removes a cursor rectangle from the Window's record and <b>discardCursorRects</b> removes all the cursor rectangles registered for the View.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView removeCursorRect:&amp;bounds cursor:NXIBeam];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[otherView discardCursorRects];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Window class defines a matching set of methods for adding and removing cursor rectangles.&nbsp; For example:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow addCursorRect:&amp;someRect</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">cursor:myImage</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">forView:myView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">But the Window methods expect the rectangles to be specified in the base coordinate system.&nbsp; For this reason, the View methods are generally easier to use.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Wait Cursors</b></font>

<p><font face="Times">The wait cursor informs users that the active application is busy and will therefore be unresponsive.&nbsp; Its disappearance lets users know that the application is again ready to receive events.</font>

<p><font face="Times">When the wait cursor is removed from the screen, the cursor should revert to whatever image is appropriate for its location and the current state of the application.&nbsp; This is done automatically when a <b>push</b> message is used to set the wait cursor image and a <b>pop</b> message is used to remove it.&nbsp; These messages should bracket the code that the user must wait for:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXWait push];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* code for a task that may take some time to execute */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXWait pop];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The wait cursor should remain on-screen for comparatively short periods of time.&nbsp; To inform users that the application will be busy for an extended period of time, don't rely on the wait cursor, but use an attention panel instead.&nbsp; See &quot;Modal Sessions&quot; under &quot;Modal Event Loops&quot; below.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Modal Event Loops</b></font>

<p><font face="Times">Part of an object's response to an event can be to get another event directly from the Application object:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEvent&nbsp; *myEvent;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myEvent = [NXApp getNextEvent:myMask];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This procedure short-circuits the main event loop, enabling an object to retrieve and respond to an expected event more quickly.&nbsp; When breaking into the main event loop, objects generally set up their own temporary, modal event loops for short periods of time.</font>

<p><font face="Times"><b>getNextEvent:</b> takes an argument, an event mask that limits the types of events it will return.&nbsp; The argument doesn't affect the events sent to the application by the Window Server--that is, it doesn't change any window's event mask.&nbsp; If the next event in the queue isn't one you want <b>getNextEvent:</b> to return, it skips over the event and continues checking until it finds one that matches the mask.&nbsp; Each time <b>getNextEvent:</b> checks for a new event, it begins at the beginning of the event queue and picks the first event matching its mask.&nbsp; The main event loop will pick up any skipped-over events.</font>

<p><font face="Times">When your program breaks into the main event loop to get events on its own, it enters a mode, a period of time when the user's actions are interpreted only by the object getting the events.&nbsp; The object getting the events usually sets up its own event loop as a subloop under the main event loop.&nbsp; The program stays in the mode until the user takes the required action to break out of the loop.</font>

<p><font face="Times">Setting up a modal event loop should be limited to cases where you can be fairly certain that the next event belongs to a limited set.&nbsp; You'd most often do it in response to a <b>mouseDown:</b>, <b>keyDown:</b>, or <b>flagsChanged:</b> message:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When a View receives a mouse-down event, a mouse-dragged or mouse-up event is likely to be the next event of interest.&nbsp; A mouse-up event breaks the loop, so the mode lasts only while the mouse button is held down.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When a View receives a key-down event and there's reason to believe the user has started typing, a key-up event or another key-down event is likely to follow.&nbsp; Any other event type serves to break the loop and end typing mode, so it won't appear to be a mode at all from the user's point of view.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When the application receives a flags-changed event indicating that the user has pressed a modifier key, it can enter a mode until another flags-changed event indicates that the key has been released.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Since the Text, TextField, and Form objects can handle the typing needs of most applications, you generally won't need to set up a modal loop to handle keyboard events.&nbsp; Spring-loaded modes triggered by a modifier key are similarly rare.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Coordinating Mouse Events</b></font>

<p><font face="Times">Mouse-down and mouse-up events often need to be coordinated:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Views shouldn't normally respond to a mouse-up event unless they've also received the mouse-down event that preceded it.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Views receiving a mouse-down event should generally wait until the mouse-up event before committing themselves to an irreversible action.&nbsp; Users are allowed to change their minds after pressing a mouse button.&nbsp; If they move the cursor from the View before releasing the button, the View shouldn't respond.&nbsp; This is especially true of Views that respond in the control-action paradigm of the user interface.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Coordinating mouse-down and mouse-up events is easier if the mouse-up event is received as part of the response to the mouse-down event.&nbsp; When a <b>mouseDown:</b> method breaks into the main event loop to get the next mouse-up event, the application's response to both events is systematically integrated.</font>

<p><font face="Times">There are also reasons why mouse-dragged events are best bracketed by mouse-down and mouse-up events in a modal event loop:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">An application shouldn't ask for mouse-dragged events until it's ready to process them, and it should stop asking for them when it no longer needs them.&nbsp; A mouse-down event signals when it's appropriate to start receiving mouse-dragged events; the succeeding mouse-up event signals when it's appropriate to stop.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">As it waits for the mouse-up event it's interested in, an object may want to keep track of the position of the cursor, so that it can respond appropriately if the user stops pointing at the object that received the mouse-down event.&nbsp; For this reason, it might ask for mouse-dragged (or mouse-exited and mouse-entered) events in addition to mouse-up events.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The following example shows how a <b>mouseDown:</b> method can set up an event loop for mouse-dragged and mouse-up events.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- mouseDown:(NXEvent *)thisEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">register int&nbsp;&nbsp; inside;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shouldLoop = YES;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldMask;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXEvent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nextEvent;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self doMyOwnHighlight];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">oldMask = [window addToEventMask:NX_LMOUSEDRAGGEDMASK];</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while (shouldLoop) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">nextEvent = [NXApp getNextEvent:(NX_LMOUSEUPMASK |</font><br>
<img src="../../Images/sp.gif" width=411 height=1><font face="Courier" size="-1">NX_LMOUSEDRAGGEDMASK)];</font>

<p><img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">inside = NXMouseInRect([self convertPoint:</font><br>
<img src="../../Images/sp.gif" width=404 height=1><font face="Courier" size="-1">&amp;nextEvent-&gt;location</font><br>
<img src="../../Images/sp.gif" width=404 height=1><font face="Courier" size="-1">fromView:nil],</font><br>
<img src="../../Images/sp.gif" width=348 height=1><font face="Courier" size="-1">&amp;bounds,</font><br>
<img src="../../Images/sp.gif" width=348 height=1><font face="Courier" size="-1">[self isFlipped]);</font>

<p><img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">switch (nextEvent-&gt;type) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case NX_LMOUSEUP:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">shouldLoop = NO;</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">if ( inside ) {</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">[self doMyOwnHighlight];</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">[self doMyOwnThing];</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">[self doMyOwnUnhighlight];</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case NX_LMOUSEDRAGGED:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">if ( inside )</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">[self doMyOwnHighlight];</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">[self doMyOwnUnhighlight];</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">default:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[window setEventMask:oldMask];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return(self);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method first declares its local variables and highlights the View in response to the mouse-down event.&nbsp; It then resets the window's event mask to include left mouse-dragged events.&nbsp; (Mouse-up events are included in every window's default event mask; they shouldn't be added to the event mask at the time of the mouse-down event.)&nbsp; But before changing the mask, it stores the window's old event mask in a local variable (<b>oldMask</b>) so that it can be reset later.</font>

<p><font face="Times">Next, the method enters an event loop, looking only for mouse-up and mouse-dragged events.&nbsp; As it receives each event, the location of the mouse is translated to the View's own coordinates (by the <b>convertPoint:fromView:</b> method) and is tested against its bounds rectangle (by the <b>NXMouseInRect()</b> function) to see whether or not it lies inside the View.</font>

<p><font face="Times">The loop continues until the mouse button is released.&nbsp; If it's released while the mouse is pointing to the View, the View performs its <b>doMyOwnThing</b> method.&nbsp; In any case, the loop exits, leaving the Application object's event loop as the only one operating.</font>

<p><font face="Times">As the modal loop waits for a mouse-up event, mouse-dragged events keep track of the location of the mouse.&nbsp; As long as it's pointing within the View, highlighting continues.&nbsp; If it leaves the View, highlighting ends.</font>

<p><font face="Times">After the modal loop exits, the <b>mouseDown:</b> method resets the event mask to make sure that mouse-dragged events will no longer be sent to the Window.</font>

<p><font face="Times">This example is more an outline than an excerpt from a real program.&nbsp; You would need to fill in the details to turn it into a useful method for your application.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Getting and Peeking at Events</b></font>

<p><font face="Times">The <b>getNextEvent:</b> method mentioned above is just one of a set of five methods that you can use to read events from the event queue.&nbsp; All five take an event mask specifying which events they're to return, and all five skip over any events in the queue that don't match the mask.</font>

<p><font face="Times">Some of the methods &quot;get&quot; the event by copying it to NXApp's <b>currentEvent</b> instance variable and removing it from the queue.&nbsp; <b>getNextEvent:</b> is one of those methods:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEvent&nbsp; *eventPtr;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp getNextEvent:(NX_KEYDOWNMASK | NX_KEYUPMASK)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Other methods simply &quot;peek&quot; at the event.&nbsp; They leave it in the queue but copy it to memory provided by the application.&nbsp; Here the event is read into the <b>thisEvent</b> structure:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEvent&nbsp; thisEvent, *eventPtr;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp peekNextEvent:NX_ALLEVENTS into:&amp;thisEvent];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Peeking at an event is appropriate, for example, in modal event loops that handle key-down and key-up events.&nbsp; Since any other event type breaks the loop, the procedure that gets keyboard events must first peek at the next event to make sure it is, in fact, a keyboard event.&nbsp; If it is, the <b>getNextEvent:</b> method can be used to get it.&nbsp; If it's not, it should be left in the queue for another procedure to handle.&nbsp; Always be certain that you can respond to an event before getting it from the queue.</font>

<p><font face="Times">All five methods that read events from the queue return a pointer to the event.&nbsp; After the <b>peekNextEvent:into: </b>message is sent in the example above, <b>eventPtr</b> points to <b>thisEvent</b>.&nbsp; The pointer returned by <b>getNextEvent:</b> is the same one that <b>currentEvent</b> returns:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp currentEvent];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These two &quot;get&quot; and &quot;peek&quot; methods differ in one other respect:&nbsp; If there is no event in the queue (at least none matching the mask passed to the method), <b>getNextEvent:</b> waits for one, but <b>peekNextEvent:into:</b> doesn't wait.&nbsp; It immediately returns a NULL pointer.</font>

<p><font face="Times">A third method, <b>peekAndGetNextEvent:</b>, gets events like <b>getNextEvent:</b>, but, like <b>peekNextEvent:into:</b>, returns immediately if there's no matching event in the queue:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp peekAndGetNextEvent:NX_ALLEVENTS];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">There are also &quot;get&quot; and &quot;peek&quot; methods that let you specify how long they should wait for the next event:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEvent&nbsp; thisEvent, *eventPtr;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp getNextEvent:NX_APPDEFINEDMASK</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">waitFor:10.0</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">threshold:NX_BASETHRESHOLD];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp peekNextEvent:NX_ALLEVENTS</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">into:&amp;thisEvent</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">waitFor:10.0</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">threshold:NX_BASETHRESHOLD];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The time is specified in seconds; in the examples above, <b>getNextEvent:waitFor:threshold:</b> and <b>peekNextEvent:into:waitFor:threshold:</b> will both wait for 10 seconds before returning NULL.&nbsp; If an event which matches the mask is queued before the 10 seconds are up, they'll return with the event immediately.</font>

<p><font face="Times">The last argument to both of these methods is a priority threshold that's explained in the next section.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Scheduling</b></font>

<p><font face="Times">While your application is responding to an event, it can't be doing anything else.&nbsp; Between events, however, it can turn to other tasks.&nbsp; It could:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Execute a timed entry, if one is due.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Respond to a message from another application, if one has been received.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read data from a file descriptor, if there's any data to read.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Whenever the application is ready to get (or peek at) another event, it can call timed entries, procedures to handle messages received at a port, and procedures to read data received at a file descriptor.&nbsp; To be eligible, a procedure must be registered using the appropriate method in the Display PostScript client library:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">DPSAddTimedEntry()</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">DPSAddPort()</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">DPSAddFD()</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A procedure is called only if there's work for it to do--the timed entry must be due, a message must have been received at the port, data must be ready at the file descriptor--and only if it's scheduled.</font>

<p><font face="Times">Whether or not a procedure is scheduled depends largely on its priority level.&nbsp; The priority is an integer between 0 and 30, with 30 as the highest possible priority and 0 as the lowest.&nbsp; The priority of a procedure is set when it's first registered (with the <b>DPSAddTimedEntry()</b>, <b>DPSAddPort()</b>, and <b>DPSAddFD()</b> functions).</font>

<p><font face="Times">Whenever an application gets (or peeks at) the next event, it specifies a priority threshold.&nbsp; Procedures with priorities lower than the threshold are screened out; all those with equal or higher priorities are checked at least once to see whether they should be called before the &quot;get&quot; or &quot;peek&quot; method returns.&nbsp; If the method doesn't return immediately but waits for an event to arrive in the queue, it's possible for a procedure to be checked and called many times over.&nbsp; Even if the method returns without waiting, it's guaranteed that each procedure at or above the threshold will be checked once.</font>

<p><font face="Times">The Application Kit makes use of three priority thresholds and defines a constant for each:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">10</font></td>

<td><font face="Times">NX_MODALRESPTHRESHOLD</font></td></tr>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">5</font></td>

<td><font face="Times">NX_RUNMODALTHRESHOLD</font></td></tr>

<tr valign=top>

<td width=231></td>

<td nowrap><font face="Times">1</font></td>

<td><font face="Times">NX_BASETHRESHOLD</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The main event loop gets events at the lower priority threshold of 1; it's very permissive about what procedures can be called between events.&nbsp; But when a Control, Text object, or other Responder sets up a modal event loop to get its own events, it gets (or peeks at) them at the higher priority threshold of 10.&nbsp; Since its purpose is to narrow the application's focus for a short period of time, a modal loop is more restrictive than the main event loop.</font>

<p><font face="Times">Attention panels also set up modal event loops, but at the less restrictive threshold of 5.&nbsp; These event loops are discussed below under &quot;Modal Windows&quot; and &quot;Modal Sessions.&quot;</font>

<p><font face="Times">A Listener object registers the application's port for receiving messages at the base priority of 1; the application can respond to messages from the Workspace Manager or other applications while it's getting events in the main event loop, but not while it's in a modal event loop.&nbsp; On the other hand, the Text object registers a timed entry to blink the caret at a priority level of 5; the caret will blink even in an attention panel, but not while the Text object is in its modal loop getting and responding to keyboard events, and not while a Button or Slider in the same window is responding to the user's mouse events.</font>

<p><font face="Times">The <b>getNextEvent:</b>, <b>peekNextEvent:into:</b>, and <b>peekAndGetNextEvent:</b> methods discussed earlier all specify a threshold of 10; they're designed for modal event loops.</font>

<p><font face="Times">The remaining two &quot;get&quot; and &quot;peek&quot; methods allow you to specify the threshold:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEvent&nbsp; *eventPtr;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp getNextEvent:NX_ALLEVENTS</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">waitFor:NX_FOREVER</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">threshold:NX_BASETHRESHOLD];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEvent&nbsp; thisEvent, *eventPtr;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">eventPtr = [NXApp peekNextEvent:NX_MOUSEUPMASK</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">into:&amp;thisEvent</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">waitFor:0.0</font><br>
<img src="../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">threshold:NX_BASETHRESHOLD];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Although the highest priority level is 30, the highest threshold that you can specify is 31.&nbsp; This threshold blocks all procedure calls between events.</font>

<p><font face="Times">At the other extreme, assigning a procedure a priority level of 0 effectively blocks it from ever being called between events; the main event loop runs at a threshold of 1.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The priority level of a procedure is compared only to the threshold, not to the priorities of other procedures.&nbsp; If two procedures have priorities at or above the threshold, it doesn't matter that one may have a priority of 29 and the other a priority of 10.&nbsp; Both will be scheduled equally.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Using Timer Events</b></font>

<p><font face="Times">The modal <b>mouseDown:</b> method illustrated under &quot;Coordinating Mouse Events&quot; at the beginning of this section reacted whenever a mouse-up or mouse-dragged event was received.&nbsp; Between events it did nothing, except wait for the next event.</font>

<p><font face="Times">On occasion, however, a modal event loop needs to react even when no event has been received from the Window Server.&nbsp; The absence of an event may indicate that the user is still in the midst of an action, one that generated an earlier event but hasn't produced any new ones.&nbsp; Typically, this occurs while the user is keeping the mouse stationary and holding a mouse button down in order to:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Press an object (such as a button) that has a repeating or continuous action.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Automatically scroll the contents of a View after dragging outside it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Because the mouse isn't moving and the mouse button isn't going up or down, these actions don't generate events. Nevertheless, the modal event loop must continue to respond to the action as if events were being received.&nbsp; It does this by making sure that it will continue to get a stream of events even if none are being generated by the Window Server. The events it arranges for are called <i>timer events</i> because they come at regular intervals.</font>

<p><font face="Times">The <b>NXBeginTimer()</b> function starts up a timed entry that puts timer events in the event queue at specified intervals. In the example below, it asks for timer events every 0.05 seconds after a delay of 0.1 second:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXTrackingTimer&nbsp; myTimer;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXBeginTimer(&amp;myTimer, 0.1, 0.05);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The first argument to <b>NXBeginTimer()</b> is a pointer to an NXTrackingTimer structure, defined in the Application Kit's <b>timer.h</b> header file.&nbsp; This structure is for the internal use of the timed entry; you don't have to initialize it.&nbsp; If you pass a NULL pointer, memory will be allocated for the structure.&nbsp; Since timer events are usually needed only within a modal event loop, it's generally better to declare the structure as a local variable on the stack as shown above.&nbsp; This avoids the expense of calling <b>malloc()</b> to get memory for it.</font>

<p><font face="Times"><b>NXEndTimer()</b> stops the flow of timer events:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXEndTimer(&amp;myTimer);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXBeginTimer()</b> returns a pointer to the NXTrackingTimer structure it uses, so even if you pass it a NULL pointer, you'll have access to the pointer required by <b>NXEndTimer()</b>.</font>

<p><br><br>

<p><font face="Helvetica"><b>Timer Example</b></font>

<p><font face="Times">The following code shows how the earlier <b>mouseDown:</b> example would change to include timer events.&nbsp; That example focused on highlighting and unhighlighting an object depending on the location of the cursor.&nbsp; This example focuses on autoscrolling the contents of a View when the user drags outside it.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- mouseDown:(NXEvent *)thisEvent</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shouldLoop = YES;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldMask;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXTrackingTimer&nbsp;&nbsp; myTimer;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXEvent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nextEvent, *lastEvent;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">oldMask = [window addToEventMask:NX_LMOUSEDRAGGEDMASK];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">lastEvent = thisEvent;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXBeginTimer(&amp;myTimer, 0.05, 0.05);</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while (shouldLoop) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">nextEvent = [NXApp getNextEvent:(NX_LMOUSEUPMASK</font><br>
<img src="../../Images/sp.gif" width=397 height=1><font face="Courier" size="-1">| NX_LMOUSEDRAGGEDMASK</font><br>
<img src="../../Images/sp.gif" width=397 height=1><font face="Courier" size="-1">| NX_TIMERMASK)];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">switch (nextEvent-&gt;type) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case NX_LMOUSEUP:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">shouldLoop = NO;</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case NX_LMOUSEDRAGGED:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">lastEvent = *nextEvent;</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">case:NX_TIMER:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">[self autoscroll:&amp;lastEvent];</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">default:</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXEndTimer(&amp;myTimer);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[window setEventMask:oldMask];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return(self);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">It isn't necessary to change the Window's event mask to get timer events, since they're not sent across the connection from the Window Server.&nbsp; You do have to include them in the mask given to <b>getNextEvent:</b>, however.</font>

<p><font face="Times">The <b>autoscroll</b> method only scrolls when the cursor is outside the receiving View's frame rectangle.&nbsp; It finds the location of the cursor from the event record of the mouse event passed as an argument.&nbsp; Since <b>autoscroll</b> messages are sent in response to timer events, the last true mouse event is cached in the <b>lastEvent</b> variable.</font>

<p><br><br>

<p><font face="Helvetica"><b>Avoiding Spin Loops</b></font>

<p><font face="Times">With timer events, you can write modal event loops that respond only to events; between events, the loop gives up control of the CPU to other applications.&nbsp; This is exactly the behavior required by a multitasking environment.</font>

<p><font face="Times">In a multitasking environment, each application must cooperate with other applications and share processing time with them.&nbsp; You should never write a modal loop that constantly executes instructions without pause, if those instructions do no useful work.&nbsp; For example, a loop that repeatedly peeked for the next event without waiting for one to appear in the queue would spin uselessly between events.&nbsp; As it spins, the loop would arrogate to itself system resources that may be in demand by other tasks.&nbsp; All applications suffer when this happens, including the spinning application.</font>

<p><font face="Times">A modal loop that spins without pause is also at the mercy of the processor it's being run on.&nbsp; On a fast processor, the loop will be executed quickly; on a slower processor it will take more time.&nbsp; A timer event, on the other hand, paces the application's response to a steady user action at the same rate on all processors.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Modal Windows</b></font>

<p><font face="Times">Sometimes an application needs to set up a modal event loop at the Window level, one step removed from the objects that are actually responding to the events.&nbsp; This can be done through the <b>runModalFor:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp runModalFor:myWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Window, <b>myWindow</b>, should be an attention panel, and it must have an event mask that accepts key-down events (so that it can become the key window).</font>

<p><font face="Times">The <b>runModalFor:</b> method puts the panel on-screen, in front of even the main menu, and makes it the key window.&nbsp; It then sets up an event loop that filters the events the Application object receives from the Window Server.&nbsp; It distributes mouse events only if they're associated with the panel; other mouse events are removed from the queue and don't generate event messages.&nbsp; This means that the user can't use the mouse to select any other window in the application (though it can be used to move windows and activate another application).</font>

<p><font face="Times">In this way the panel can command the user's attention until some condition is met--usually the user clicking on one of the panel's buttons.</font>

<p><br><br>

<p><font face="Helvetica"><b>Breaking the Loop</b></font>

<p><font face="Times">The modal loop that <b>runModalFor:</b> begins can be terminated by sending the Application object a <b>stopModal</b> message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp stopModal];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">It can also be terminated with an <b>abortModal</b> message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp abortModal];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the response to an event includes a <b>stopModal</b> message, the Window's event loop will be broken.&nbsp; The <b>runModalFor:</b> method won't attempt to get another event, but it will finish responding to the current one.&nbsp; In contrast, an <b>abortModal:</b> message breaks the event loop immediately.&nbsp; Without returning, it raises an exception that causes the <b>runModalFor:</b> method to return at once.</font>

<p><font face="Times">Use <b>abortModal</b> rather than <b>stopModal</b> to break the loop from within code that executes between events--such as a timed entry or a method that responds to a remote message.&nbsp; In these cases, <b>stopModal</b> won't work, because <b>runModalFor:</b> will check the exit condition only after getting and responding to one more event.</font>

<p><br><br>

<p><font face="Helvetica"><b>Return Codes</b></font>

<p><font face="Times">It's often necessary to know why a Window's modal loop has ended.&nbsp; For example, if an attention panel displays three different buttons, any of which can dismiss the panel, the function or method that placed the panel on-screen may want to know which button the user clicked.&nbsp; By using a third method to break the event loop, <b>stopModal:</b>, you can pass a return code that identifies the reason why the modal loop is being terminated.&nbsp; Usually the code is an arbitrary integer that identifies the button that was clicked:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp stopModal:2];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This integer is passed to and returned by the <b>runModalFor:</b> method.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp; why;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">why = [NXApp runModalFor:myWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When the modal loop is terminated by an <b>abortModal</b> message, <b>runModalFor:</b> returns an integer identified by the NX_RUNABORTED constant.&nbsp; When <b>stopModal</b> (without a colon) terminates the loop, <b>runModalFor:</b> returns NX_RUNSTOPPED.</font>

<p><font face="Times">Only the <b>stopModal:</b> method (with a colon) permits you to specify your own return codes.&nbsp; The code should be an integer above -1000; integers less than -999 are reserved by NeXT.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Modal Sessions</b></font>

<p><font face="Times">On occasion, applications need to carry out time-consuming operations that are not responsive to events--an extensive calculation, perhaps, or moving a large amount of data from one location to another.&nbsp; From the point of view of the user interface, these operations can be divided into three categories:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Those that prevent the user from doing anything else, but that might be interrupted, aborted, or otherwise controlled by the user.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Those that prevent the user from doing anything else and cannot be interrupted or aborted.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Those that shouldn't prevent the user from carrying out other tasks.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Operations in the third category should be placed in a separate Mach thread and performed in the background.&nbsp; Those in the first two categories require you to run an attention panel while carrying out the operation.&nbsp; For the first category, the panel would give the user some control over the operation--notably the ability to terminate it.&nbsp; For the second category, the panel would let the user know what was happening, but would offer no opportunity to abort it.</font>

<p><font face="Times">The <b>runModalFor:</b> method can't run this type of panel.&nbsp; Since the modal event loop it sets up controls all the application's activities, it would be impossible to carry out the concurrent operation.</font>

<p><font face="Times">Instead, the application must carry out the operation within a modal session bracketed by <b>beginModalSession:for:</b> and <b>endModalSession:</b> messages to the Application object.&nbsp; While in the session, a modal event loop--similar to the one set up by <b>runModalFor:</b>--is run repeatedly for short periods of time.&nbsp; The rest of the time is available for the concurrent operation.&nbsp; The method that runs the loop, <b>runModalSession:</b>, gets events as long as there are any in the event queue, and then returns.&nbsp; An application should send <b>runModalSession:</b> messages often enough, at least two or three times a second, to be responsive to the user.</font>

<p><font face="Times">A modal session is identified by an NXModalSession structure.&nbsp; A pointer to the structure is passed as an argument to all three methods mentioned above.&nbsp; The structure isn't one that you need to initialize.&nbsp; If you pass a null pointer to <b>beginModalSession:for:</b>, it will create the structure for you and return a pointer that you can pass to <b>runModalSession:</b> and <b>endModalSession:</b>.&nbsp; However, it's more efficient to declare the structure as a local variable and avoid the necessity of allocating memory for it.</font>

<p><font face="Times">An example of how these methods might be used is given below:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXModalSession&nbsp; theSession;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp beginModalSession:&amp;theSession for:myWindow];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">while ( someCondition ) {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( [NXApp runModalSession:&amp;theSession] == NX_RUNSTOPPED )</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* code that performs the concurrent operation */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow orderOut:self];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp endModalSession:&amp;theSession];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">As the example shows, <b>runModalSession:</b> returns the codes set by <b>stopModal:</b>, <b>stopModal</b>, and <b>abortModal</b>, just as <b>runModalFor:</b> does.&nbsp; However, <b>runModalSession:</b> usually returns when there are no more events to process, not because the loop has been broken.&nbsp; When it returns without being stopped or aborted, its return value is NX_RUNCONTINUES.</font>

<p><font face="Times">Periodic <b>runModalSession:</b> messages are required even if the panel isn't one that accepts the users events--for example a panel without buttons that simply informs the user of a lengthy operation that can't be aborted.&nbsp; The messages have three purposes in addition to allowing users to manipulate controls within the panel.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">They clear unwanted events out of the event queue.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">They permit the application to respond to system-defined and kit-defined events, including application-deactivated and window-moved subevents.&nbsp; They thus keep the application responsive to the user.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">They permit the application to receive and respond to remote messages and to execute timed entries.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Drawing in the View Hierarchy</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">An application draws through its View objects.&nbsp; Each View has:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">An area of the screen, a frame rectangle, where it can draw</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A coordinate system within which it can draw</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A method, <b>drawSelf::</b>, that does the drawing</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To get a View to draw, you send it a message to display itself.&nbsp; For example:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView display];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView display:&amp;rect :1];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Under certain circumstances (described later in this section), the Application Kit generates its own display messages to Views.</font>

<p><font face="Times">The display message brings the View into focus by constructing a PostScript clipping path around its frame rectangle and making its coordinate system the current coordinate system for the application.&nbsp; It then has the View perform its <b>drawSelf::</b> method.&nbsp; The display method repeats these steps for each of the View's subviews.&nbsp; The <b>display</b> and <b>display::</b> messages in the example above would each display <b>myView</b> and all the Views below it in the view hierarchy.</font>

<p><font face="Times">Objects that are displayed only through their subviews perform an empty version of <b>drawSelf::</b> inherited from the View class.&nbsp; Objects that do any of their own drawing implement a version of <b>drawSelf::</b> that overrides the default. <b>drawSelf::</b> is always performed indirectly, in response to a display message; it should never appear in a direct message to a View.</font>

<p><font face="Times">The <b>drawSelf::</b> method defines a View's static appearance on the screen.&nbsp; Views can also add other methods for <i>dynamic drawing</i> in response to the user's actions.&nbsp; These methods might be used to highlight the View, drag it from one place to another, or animate it.&nbsp; They draw outside the display mechanism outlined above.&nbsp; You must first bring the View into focus with a <b>lockFocus</b> message, then send it a message to perform the dynamic-drawing method.</font>

<p><font face="Times">The following sections describe focusing, View coordinate systems, <b>drawSelf::</b>, <b>lockFocus</b>, the display methods, and other aspects of drawing on the NeXT computer.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>View Coordinate Systems</b></font>

<p><font face="Times">As discussed under &quot;View&quot; in the previous chapter, each View's coordinate system is tied to the location and orientation of its frame rectangle:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The point that locates the View in its superview's coordinate system, <b>frame.origin</b>, becomes the origin of the View's own default coordinate system.&nbsp; When the View is brought into focus, this point is made the origin of the current coordinate system.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The x- and y-axes of the View's default coordinate system are parallel to the sides of its frame rectangle.&nbsp; If the frame rectangle has been rotated, its default coordinate system rotates with it.&nbsp; When the View is brought into focus, the current coordinate system is rotated around <b>frame.origin</b> so that it matches the rotation of the frame rectangle.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Tying the View's coordinate system to the location and orientation of its frame rectangle has some far-reaching consequences for how Views are displayed.&nbsp; Three of the most important are listed below:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Each View's coordinate system is a transformation of its superview's.&nbsp; This follows from <b>frame</b> being defined in the superview's coordinates.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">None of a View's drawing instructions (in <b>drawSelf::</b> or the dynamic-drawing methods) need to be aware of the View's location or orientation.&nbsp; Since coordinate values are interpreted relative to the View frame rectangle, a View doesn't compensate for its movement or rotation on the screen when it draws.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Changes in a superview's coordinate system are passed through to its subviews.&nbsp; If a View scales its drawing coordinates, for example, all its subviews will grow or shrink accordingly.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The default coordinate system was illustrated in Figure 6-8, &quot;Default Coordinates,&quot; in the previous chapter.&nbsp; Figure 7-7, below, illustrates it in an even more diagrammatic way.&nbsp; It shows that <b>frame.origin</b> becomes (0.0, 0.0) in the View's default bounds rectangle.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F6.gif" width=377 height=311></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-7</b></font><font face="Times">.&nbsp; Default Coordinates of an Unrotated View</font>

<p><br><br>

<p><font face="Times">The bounds rectangle expresses the View's location and size in its own drawing coordinates.&nbsp; In Figure 7-7 above, the bounds and frame rectangles enclose exactly the same area.&nbsp; The only difference is that <b>bounds</b> records the rectangle in the reference coordinate system that the View uses for drawing inside the rectangle, and <b>frame</b> records values that define the rectangle in the superview's coordinate system.&nbsp; In this diagram, and similar ones that follow, <b>bounds</b> values are placed inside the subview's frame rectangle, where the subview will draw; <b>frame</b> values are placed outside the subview's frame rectangle, in the environment provided by the superview.</font>

<p><font face="Times">The default coordinate system illustrated in Figures 6-8 and 7-7 can be altered through methods that translate, scale, and rotate it, or that flip the polarity of its y-axis.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Flipping the Coordinate System</b></font>

<p><font face="Times">By default, Windows and Views inherit the orientation of the screen coordinate system; the positive x-axis extends rightward and the positive y-axis extends upward.&nbsp; Views (but not Windows) can opt to flip this coordinate system so that the positive y-axis extends downward.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setFlip:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>frame</b> instance variable of a flipped View is no different from that of a View that isn't flipped:&nbsp; The width and height of the View are expressed by positive values, and the point locating the View in its superview's coordinates is the one with the smallest x and y values.</font>

<p><font face="Times">The <b>bounds</b> instance variable of a flipped View also remains the same:&nbsp; Its width and height are expressed by positive values, and it records the rectangle corner with the smallest x and y values in the View's reference coordinate system. Because the polarity of the y-axis is flipped, this corner will (barring rotation) be the upper left corner of the View, rather than the lower left corner.</font>

<p><font face="Times">Figure 7-8 illustrates the same two Views as Figure 7-7, except that here the subview's coordinate system has been flipped.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F7.gif" width=377 height=312></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-8</b></font><font face="Times">.&nbsp; Flipped Coordinates</font>

<p><br><br>

<p><font face="Times">Note that the frame rectangle continues to locate the View in its superview's unflipped coordinate system, but the bounds rectangle in which the View draws has been flipped.&nbsp; <b>frame.origin</b> and <b>bounds.origin</b> are no longer located at the same point.</font>

<p><font face="Times">Flipped coordinates are an inherent property of the View, not a transient feature that can be turned on and off.&nbsp; A View should receive only one <b>setFlip:</b> message during its life, before it's first displayed, preferably in the class method that creates it.&nbsp; All of the View's drawing should assume its flipped coordinates.</font>

<p><font face="Times">The <b>isFlipped</b> method returns whether or not the receiving View is flipped:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; flipState;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">flipState = [myView isFlipped];</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Transitivity</b></font>

<p><font face="Times">Flipped coordinates are an exception to the rule stated above, that transformations of a superview's coordinate system carry over to its subviews.&nbsp; Flipping a parent View doesn't flip its subviews.&nbsp; A View won't become flipped when it's made the subview of a flipped View, and a flipped View won't flip again, back to the original orientation, if it's made the subview of another View with flipped coordinates.&nbsp; A View has flipped coordinates <i>only</i> if it receives a <b>setFlip: </b>message with YES as the argument.</font>

<p><br><br>

<p><font face="Helvetica"><b>Unflipping</b></font>

<p><font face="Times">The argument passed to <b>setFlip:</b> is almost always YES.&nbsp; Passing NO as the argument would unflip the View, but Views are unflipped by default, and once a View has been flipped, it should stay that way.</font>

<p><font face="Times">There's just one situation where NO is an appropriate argument to <b>setFlip:</b>.&nbsp; If you define a subclass and inherit a class method that includes a <b>setFlip:</b> message to flip the instances it creates, you'll need to cancel that message with another <b>setFlip:</b> message to make objects belonging to the subclass unflipped.</font>

<p><font face="Times">For example, if this is the superclass method,</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">+ newView</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">self = [super new];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self setFlip:YES];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* flips its coordinates */</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">the subclass method might look like this:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">+ newView</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">self = [super newView];&nbsp;&nbsp; /* inherits the flip */</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self setFlip:NO];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* cancels it */</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Drawing Text</b></font>

<p><font face="Times">Flipped coordinates are mainly useful to objects that draw multiple lines of text.&nbsp; Coordinate values increase, rather than decrease, as more lines are added from the top of the View to the bottom.&nbsp; In the Application Kit, the Text and TextField objects both use flipped coordinates, as do Matrices, Forms, Buttons, Sliders, Scrollers, and ScrollViews. (But a View doesn't have to be flipped to be scrollable.)</font>

<p><font face="Times">When drawing text in a View with flipped coordinates, you must use a font with a matrix that flips the y-axis of the characters that are drawn.&nbsp; Fonts have higher y-coordinate values at the top of the character outline and lower y-coordinate values at the bottom (with values of exactly 0.0 at the baseline).&nbsp; Unless the font matrix flips this polarity to match the flipped View, the characters will be displayed upside down.</font>

<p><font face="Times">A flipped matrix is specified when first setting the font through the <b>newFont:size:style:matrix:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; myFont;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myFont = [Font newFont:&#34;Courier-Bold&#34;</font><br>
<img src="../../Images/sp.gif" width=229 height=1><font face="Courier" size="-1">size:12.0</font><br>
<img src="../../Images/sp.gif" width=229 height=1><font face="Courier" size="-1">style:0</font><br>
<img src="../../Images/sp.gif" width=229 height=1><font face="Courier" size="-1">matrix:NX_FLIPPEDMATRIX];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The constant NX_FLIPPEDMATRIX is defined in the interface file for the Font class.&nbsp; It specifies a font matrix with these six values:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1.0, 0.0, 0.0, -1.0, 0.0, 0.0</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">An unflipped matrix is specified by another constant, NX_IDENTITYMATRIX.&nbsp; An identity matrix has only positive values:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">1.0, 0.0, 0.0, 1.0, 0.0, 0.0</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the text you draw appears upside down, the culprit is likely to be the wrong matrix.</font>

<p><br><br>

<p><font face="Helvetica"><b>Notifying Superviews</b></font>

<p><font face="Times">Sometimes a View needs to let its ancestors know that it's flipped so they can adjust the display accordingly.&nbsp; (In the Application Kit, this is important mainly to the ClipView that contains a scrollable document View.)</font>

<p><font face="Times">If a View receives a <b>notifyWhenFlipped:</b> message with YES as the argument,</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView notifyWhenFlipped:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">it will send its superview a <b>descendantFlipped:</b> message when <b>setFlip:</b> flips its coordinates.&nbsp; The default implementation of <b>descendantFlipped:</b> simply passes the message on to the receiver's superview, so the message will simply climb the view hierarchy until it runs out of Views.&nbsp; A View that needs to know whenever one of its descendants is flipped can override the default to do whatever is necessary.&nbsp; The argument passed in <b>descendantFlipped:</b> messages identifies the flipped View.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Modifying Default Coordinates</b></font>

<p><font face="Times">A View can alter its coordinate system with methods that parallel the standard PostScript transformations:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXCoord&nbsp; x, y, width, height;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp;&nbsp;&nbsp; angle;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView translate:x :y];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView scale:width :height];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView rotate:angle];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>translate::</b> moves the View's coordinate origin to (<b>x</b>, <b>y</b>).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>scale::</b> makes the View's x-coordinate unit equal to <b>width</b>, and its y-coordinate unit equal to <b>height</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>rotate:</b> turns the View's coordinate axes by <b>angle</b> from their present angle of orientation.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Like the PostScript operators, these methods affect the coordinate system incrementally.&nbsp; If a View is sent a message to rotate 60</font>&#176;<font face="Times">, sending it another message to rotate 60</font>&#176; <font face="Times">turns it 120</font>&#176; <font face="Times">from its original orientation.</font>

<p><font face="Times">Unlike the PostScript operators, however, they don't have an immediate effect on the current coordinate system. Alterations to a View's coordinate system take effect only when it's next brought into focus.</font>

<p><font face="Times">Three other methods modify a View's coordinate system to a more absolute specification:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setDrawOrigin:x :y];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setDrawSize:width :height];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setDrawRotation:angle];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>setDrawOrigin::</b> translates the View's coordinate system so that (<b>x</b>, <b>y</b>) designates the same point on-screen as <b>frame.origin</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>setDrawSize::</b> scales the View's coordinate system so that <b>width</b> and <b>height</b> describe the size of the frame rectangle.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>setDrawRotation:</b> rotates the View's coordinate system so that <b>angle</b> is the difference between its frame and the coordinate axes it uses for drawing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These three methods are not incremental.&nbsp; If a View is sent a <b>setDrawRotation:</b> message to rotate 60</font>&#176;<font face="Times">, sending it the same message again would leave its coordinate system at the same angle of orientation, just 60</font>&#176; <font face="Times">from the angle of orientation of its frame.</font>

<p><font face="Times">The six methods listed above affect only the coordinate system used for drawing; they don't affect the location, size, or rotation of the View's frame rectangle.</font>

<p><br><br>

<p><font face="Helvetica"><b>Rotated Bounds</b></font>

<p><font face="Times">Although scaling and translating a View's coordinate system affect the values stored in its <b>bounds</b> instance variable, the area covered by the bounds rectangle remains identical to the area covered by the frame rectangle.&nbsp; Rotating a View's coordinates, on the other hand, can change the orientation of the bounds rectangle so that it no longer matches the frame rectangle.&nbsp; Unless the rotation is an exact multiple of 90</font>&#176;<font face="Times">, the bounds rectangle will be somewhat larger than the frame rectangle.&nbsp; This is illustrated in Figure 7-9.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F8.gif" width=390 height=311></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-9</b></font><font face="Times">.&nbsp; Rotated Bounds Rectangle</font>

<p><br><br>

<p><font face="Times">Figure 7-9 shows a View whose drawing coordinates have been rotated counterclockwise 15</font>&#176;<font face="Times">.&nbsp; The bounds rectangle is defined in the rotated coordinates; the sides of the rectangle are parallel to the rotated x- and y-axes.&nbsp; This rectangle must be larger than the frame rectangle for it to encompass all of the View.</font>

<p><font face="Times">The <b>boundsAngle</b> method returns the rotation of the bounds rectangle relative to the frame rectangle.&nbsp; For the example in Figure 7-9, it would return 15.0 degrees.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp; rotation;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">rotation = [myView boundsAngle];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>setDrawOrigin::</b> and <b>setDrawSize::</b> methods specify values that describe a View's frame rectangle in the View's own coordinate system.&nbsp; They therefore usually set the values in the <b>bounds</b> instance variable, since the bounds rectangle usually designates the same area as the frame rectangle.&nbsp; However, if the View has a rotated coordinate system, the bounds rectangle won't match the frame rectangle, so <b>bounds</b> won't have the values set by these methods.</font>

<p><font face="Times">Since the visible rectangle and the bounds rectangle are both stated in the View's reference coordinate system, the visible rectangle rotates with the bounds rectangle.&nbsp; This is illustrated in Figure 7-10.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F9.gif" width=426 height=311></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-10</b></font><font face="Times">.&nbsp; Rotated Visible Rectangle</font>

<p><br><br>

<p><font face="Times">For a rotated rectangle to enclose all the visible area of a View, it must also contain some areas that are not visible and some that may not even be in the View.&nbsp; Considerations of efficiency would therefore recommend against rotating the reference coordinate system for a View, but to do any rotation necessary within the View's drawing code.</font>

<p><br><br>

<p><font face="Helvetica"><b>Transitivity</b></font>

<p><font face="Times">Modifications to a View's coordinate system can affect the size and placement of its subviews.&nbsp; They can also affect the coordinate system that a subview draws in.</font>

<p><font face="Times">By default, subview coordinate systems reflect the superview's rotation and scaling.&nbsp; But because each subview's default coordinate system is translated to the point designated by <b>frame.origin</b>, the subview overrides any translation done by the superview.</font>

<p><font face="Times">Two methods let you know whether a View's coordinate system has been rotated or scaled, either directly or through any ancestor Views above it in the view hierarchy:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; rotated, modified;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">rotated = [myView isRotatedFromBase];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">modified = [myView isRotatedOrScaledFromBase];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If these methods return NO, the View has the orientation and scaling of the base and screen coordinate systems.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Basic and Temporary Coordinate Systems</b></font>

<p><font face="Times"><b>setFlip:</b> and the six methods that transform a View's coordinate system should be used only to set up the basic coordinate system for the View, the one that's the starting point for the drawing instructions in the View's <b>drawSelf:: </b>method.</font>

<p><font face="Times">It's typical, while drawing in the PostScript language, to alter the coordinate system repeatedly for temporary effects--to scale it to draw an oval, to rotate it to draw text at an angle, or to repeatedly translate it so that a single procedure can draw a figure in more than one position.&nbsp; These temporary changes to the coordinate system should be done directly in PostScript code, through <b>pswrap</b>-generated functions called by <b>drawSelf::</b> (or by the dynamic drawing methods).&nbsp; They shouldn't be done through View methods.&nbsp; See &quot;Drawing Methods,&quot; below, for more on how drawing methods like <b>drawSelf::</b> can change the graphics state.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Converting Coordinates</b></font>

<p><font face="Times">Because each View has its own coordinate system, it's often necessary to convert a point or an area specified in one View's coordinate system to the coordinate system of another View.&nbsp; The View class defines methods that can convert NXPoint, NXSize, and NXRect structures from one View to another:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView convertPoint:&amp;point toView:anotherView];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView convertSize:&amp;size toView:anotherView];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView convertRect:&amp;rect toView:anotherView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These methods assume that the first argument refers to a structure with values in the receiving View's (<b>myView</b>'s) coordinate system.&nbsp; They alter those values to the coordinate system of the second argument (<b>anotherView</b>), provided the two Views belong to the same window.&nbsp; If the second argument is <b>nil</b>, the conversion is to the window's base coordinate system.&nbsp; On-screen locations and areas aren't altered, only the coordinate systems that they're expressed in.</font>

<p><font face="Times">Three other methods convert in the opposite direction, from the coordinate system of a specified View to the coordinate system of the receiver:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[yourView convertPoint:&amp;point fromView:secondView];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[yourView convertSize:&amp;size fromView:secondView];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[yourView convertRect:&amp;rect fromView:secondView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the View specified in the second argument is <b>nil</b>, the three methods above convert the NXPoint, NXSize, or NXRect structure from the base coordinate system to the receiving View's coordinate system.</font>

<p><font face="Times">There are also methods that optimize for the special case when one View is the other View's superview:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView convertRectFromSuperview:&amp;point];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView convertRectToSuperview:&amp;rect];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[yourView convertPointFromSuperview:&amp;point];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[yourView convertPointToSuperview:&amp;rect];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Window class defines methods for converting an NXPoint structure from the base coordinate system to the screen coordinate system, and from the screen coordinate system to the base coordinate system:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow convertBaseToScreen:&amp;point];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow convertScreenToBase:&amp;point];</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Focusing on a View</b></font>

<p><font face="Times">Before a View draws, it's necessary to lock the focus on it:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView lockFocus];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">After it's finished drawing, the focus should be unlocked:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView unlockFocus];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Locking the focus ensures that the View draws in the correct window, place, and coordinate system.&nbsp; It makes the View's reference coordinate system the current coordinate system for the application.&nbsp; Unlocking the focus returns to the coordinate system of the View that was previously in focus.</font>

<p><font face="Times">The <b>isFocusView</b> method returns whether the focus is currently locked on the receiving View:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; canDraw;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">canDraw = [myView isFocusView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Application object's <b>focusView</b> method returns the last View that was brought into focus:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp; currentView;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">currentView = [NXApp focusView];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If a View draws through the display mechanism, you don't have to explicitly lock and unlock the focus; the display methods perform <b>lockFocus</b> and <b>unlockFocus</b> for you.&nbsp; For dynamic drawing that's done outside of the display mechanism, however, explicit <b>lockFocus</b> and <b>unlockFocus</b> messages are required.&nbsp; The display methods are discussed in a later section of this chapter.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>How Focusing Works</b></font>

<p><font face="Times">The Application Kit takes the following steps to bring a View into focus:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">It constructs a clipping path around the View.&nbsp; This ensures that the View won't draw outside its frame rectangle.</font></td></tr>

<tr valign=top>

<td width=105 height=20></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">It makes the View's coordinate system the current coordinate system for the application, as recorded in the current transformation matrix (CTM) of the current graphics state.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Views are brought into focus by working down the view hierarchy, from superview to subview.&nbsp; Since each View keeps track of its own coordinate system as a modification of its superview's, a View can be brought into focus only after its superview.&nbsp; To focus on the superview, the superview's superview might first have to be brought into focus, and so on all the way up to the View at the root of the view hierarchy (the frame view).&nbsp; If a View must be focused from scratch, the Application Kit begins with the base coordinate system of the window and frame view, brings the content view into focus, then brings a subview of the content view into focus, and continues to work down the hierarchy to the target View.</font>

<p><font face="Times">The Application Kit doesn't take these steps if they're unnecessary; the focusing mechanism has been optimized and is quite efficient.&nbsp; Focusing begins with the window's base coordinate system only if there's no View with a determinate coordinate system closer to the target View.&nbsp; Usually there is, either the View that's currently in focus or a View with a coordinate system specified by its own graphics state object.&nbsp; (Assigning graphics state objects to Views is discussed below under &quot;Drawing Methods.&quot;)</font>

<p><font face="Times">Because each View is clipped to its frame rectangle, focusing down the view hierarchy means that a subview can't draw outside the area allotted to its superview.&nbsp; In the PostScript language, each additional clipping path only further constrains the area where images can appear, so if a subview lies outside the frame rectangle of <i>any</i> ancestor View, it won't be displayed.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Clipping</b></font>

<p><font face="Times">Of the steps that are taken to bring a View into focus, clipping to its frame rectangle is perhaps the most time-consuming.&nbsp; A View that doesn't require a clipping path to ensure that it won't draw outside its allotted area can skip this step by sending itself a <b>setClipping:</b> message with NO as the argument:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[self setClipping:NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">As the Application Kit focuses from superview to subview down the view hierarchy, whenever it encounters a View that has received this message, it skips the step that constructs a clipping path around the View's frame rectangle.</font>

<p><font face="Times">A View should avoid clipping only if it can be assured that it and all its subviews won't attempt to draw outside its frame rectangle.&nbsp; Many of the View subclasses defined in the Application Kit--Button, Text, Scroller, and ScrollView--don't clip.</font>

<p><font face="Times">The <b>doesClip</b> method returns whether the receiver will be clipped during focusing:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; clips;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">clips = [myView doesClip];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Like <b>setFlip:</b>, <b>setClipping:</b> determines a permanent property of a View.&nbsp; A View should receive the <b>setClipping: </b>message before it draws or modifies its coordinate system; it's best to include it in the class method that creates the View.&nbsp; Once clipping has been turned off, it shouldn't be turned back on again.</font>

<p><font face="Times">However, if you define a subclass and inherit a class method with a <b>setClipping:</b> message that turns clipping off, you can cancel that message by sending another <b>setClipping:</b> message in the subclass's method, this time with YES as its argument.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">+ newView</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">self = [super new];&nbsp;&nbsp;&nbsp; /* the new method that prevents clipping */</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self setClipping:YES];/* the remedy */</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Using the Superview's Coordinates</b></font>

<p><font face="Times">A View can opt to use the same coordinate system as its superview:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView drawInSuperview];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This avoids the overhead of transforming the superview's coordinate system to focus on the View.&nbsp; It also makes the View's <b>bounds</b> instance variable identical to <b>frame</b>, as shown in Figure 7-11.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F10.gif" width=377 height=312></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-11</b></font><font face="Times">.&nbsp; Drawing in the Superview's Coordinates</font>

<p><br><br>

<p><font face="Times">Because its superview's coordinate system doesn't have to be transformed to bring the View into focus, less PostScript code is sent to the Window Server.&nbsp; A View that receives both <b>drawInSuperview</b> and <b>setClipping:</b> messages can avoid both steps that are taken to focus on it from its superview, the clipping path and coordinate transformations.</font>

<p><font face="Times">After receiving a <b>drawInSuperview</b> message, a View's drawing instructions must take into account the View's location within its superview (<b>bounds.origin</b>) and the width and height of its frame rectangle (<b>bounds.size</b>).</font>

<p><font face="Times">Like <b>setFlip:</b> and <b>setClipping:</b>, <b>drawInSuperview</b> establishes an inherent attribute of the View, one that should be set as soon as the View is created and shouldn't be changed thereafter.&nbsp; In particular, a <b>drawInSuperview</b> message shouldn't be sent to a View that also receives messages to transform its default coordinate system.</font>

<p><font face="Times">The Text object is the only object defined in the Application Kit that draws in its superview's coordinate system.</font>

<p><br><br>

<p><font face="Helvetica"><b>Modifying drawInSuperview Coordinates</b></font>

<p><font face="Times">If a View receives a <b>drawInSuperview</b> message after its coordinate system has been scaled or rotated, the message will have no effect.&nbsp; If it receives the message after it has been translated (but not scaled or rotated), the message will have no effect until the translation is reversed.</font>

<p><font face="Times">The sole purpose of a <b>drawInSuperview</b> message is to avoid the overhead of having to focus on the View independently of its superview.&nbsp; Once it has been translated, scaled, or rotated, a View has its own coordinate system; there's no point in sending it a <b>drawInSuperview</b> message.</font>

<p><font face="Times">Nevertheless, if messages to modify the View's coordinate system are sent after the <b>drawInSuperview</b> message, they modify the coordinate system that <b>drawInSuperview</b> established for the View.&nbsp; (Despite the fact that the View was using its superview's coordinate system, the modifications affect only the View itself, not its superview.)</font>

<p><br><br>

<p><font face="Helvetica"><b>Flipping drawInSuperview Coordinates</b></font>

<p><font face="Times">A View can both draw in its superview's coordinates and be flipped:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView drawInSuperview];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setFlip:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Text object is such a View.</font>

<p><font face="Times">The <b>setFlip:</b> message affects only the View that receives it, not its superview.&nbsp; Flipping the coordinates in this way doesn't negate all the effects of <b>drawInSuperview</b>; reversing the polarity of the y-axis is the only transformation that's needed to focus on the View independently of its superview.</font>

<p><font face="Times">Similarly, if a View draws in its flipped superview's coordinates, it won't itself automatically be flipped.&nbsp; Although the <b>drawInSuperview</b> message makes the <b>bounds</b> and <b>frame</b> instance variables identical, <b>bounds.origin</b> and <b>frame.origin</b> will refer to two different points.&nbsp; This is illustrated in Figure 7-12.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F11.gif" width=377 height=312></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-12</b></font><font face="Times">.&nbsp; Drawing in a Flipped Superview</font>

<p><br><br>

<p><font face="Times">A View is flipped only if it receives a <b>setFlip:</b> message; it can't inherit this feature from its superview, even if it draws in its superview's coordinates.&nbsp; Therefore, to have a subview draw in exactly the same coordinate system as its flipped superview, it must receive both a <b>drawInSuperview</b> message and a <b>setFlip:</b> message, as illustrated above.&nbsp; This avoids any and all coordinate transformations to focus on the View.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Locking and Unlocking the Focus</b></font>

<p><font face="Times">A <b>lockFocus</b> message makes the receiving View's coordinate system the application's current coordinate system. Each <b>lockFocus</b> message must be paired with an eventual <b>unlockFocus</b> message to the same View, after the View has finished drawing:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView lockFocus];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* drawing code goes here */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView unlockFocus];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If a View is already in focus when a <b>lockFocus</b> message is sent, <b>lockFocus</b> saves the current graphics state (with the PostScript <b>gsave</b> operator) before bringing the receiving View into focus.&nbsp; The <b>unlockFocus</b> message later restores the saved graphics state (with the PostScript <b>grestore</b> operator).&nbsp; This returns the focus to the View that had it before the <b>lockFocus</b> message.</font>

<p><font face="Times">An <b>unlockFocus</b> message can balance only one previous <b>lockFocus</b>.</font>

<p><font face="Times">Matching <b>lockFocus</b> and <b>unlockFocus</b> messages must bracket all the drawing that a View does.&nbsp; Like braces in C code, they can be nested.&nbsp; In the example below, the <b>doDynamicDrawing</b> method locks the focus on the receiver (<b>self</b>), then locks and unlocks the focus on a companion View before unlocking the focus on the receiver.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- doDynamicDrawing</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self lockFocus];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self drawFirstPart];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( companionView ) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[companionView lockFocus];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[companionView doOtherDrawing];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[companionView unlockFocus];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self drawSecondPart];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self unlockFocus];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">When the companion View receives an <b>unlockFocus</b> message, the focus immediately returns (through <b>grestore</b>) to <b>self</b>.</font>

<p><font face="Times">It's possible to focus repeatedly on the same View, without intervening <b>unlockFocus</b> messages.&nbsp; Successive <b>lockFocus</b> messages to the same View don't generate any additional PostScript code (except for <b>gsave</b>); since the View is already in focus, it doesn't have to be brought into focus again.&nbsp; However, if something in the graphics state has changed or the View has altered its frame rectangle, it will be refocused.</font>

<p><font face="Times">The <b>lockFocus</b> method returns boolean YES if it doesn't need to do anything to bring the receiving View into focus. This lets the drawing method know that it has the same graphics state as before, so that it can avoid reinitializing graphics state parameters.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Drawing Methods</b></font>

<p><font face="Times">The method that draws a View is <b>drawSelf::</b>.&nbsp; <b>drawSelf::</b> messages are generated when the View, or one its ancestors in the view hierarchy, receives a display message.&nbsp; You must implement a <b>drawSelf::</b> method for each custom View that you want to draw according to your own specifications, but you should rely on display messages to perform the method.</font>

<p><font face="Times">Since display messages are often generated by the Application Kit in response to user actions, <b>drawSelf::</b> must be able to reach all the code necessary to render the View.&nbsp; Typically, <b>drawSelf::</b> calls <b>pswrap</b>-generated functions to send PostScript code to the Window Server.&nbsp; It may also send messages to Bitmap objects to composite source images stored in off-screen windows.&nbsp; If a View uses a Cell to do any of its drawing, <b>drawSelf::</b> will send messages to perform the Cell's drawing methods, <b>drawSelf:inView:</b> and <b>drawInside:inView:</b>.</font>

<p><font face="Times">The <b>drawSelf::</b> method draws the neutral, static appearance of a View.&nbsp; It can be matched by dynamic drawing methods that temporarily alter the View's appearance in response to events.&nbsp; Messages to perform dynamic drawing methods should be generated within the event-handling code you write.</font>

<p><font face="Times"><b>drawSelf::</b> and the dynamic drawing methods operate in an environment specific to a View.&nbsp; The View determines the window, the area within the window, and the initial coordinate system for drawing.&nbsp; Focusing on the View makes the current graphics state reflect the View's attributes:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current window is the window where the View is located.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current clipping path enforces the restricted area within the window where the View can draw.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The current transformation matrix (CTM) records the View's initial coordinate system for drawing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These View-specific factors aren't the whole story, however.&nbsp; The current graphics state includes other parameters, such as line width and halftone screen, and there may be further restrictions on where it's appropriate for the View to draw.&nbsp; The sections below discuss the factors that define the drawing environment.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Drawing Rectangles</b></font>

<p><font face="Times">The two arguments passed to <b>drawSelf::</b> indicate how much of the View needs to be drawn.&nbsp; The first argument is a pointer to an array of rectangles (NXRect *) specified in the View's reference coordinate system, and the second argument (an <b>int</b>) indicates how many rectangles are in the array.</font>

<p><font face="Times">Usually there's just one rectangle in the array, but there may be three.&nbsp; When there are three, the first rectangle is the union of the second and third--that is, it's the smallest rectangle that completely encloses the other two.&nbsp; Specifying the area that needs to be displayed as the sum of two rectangles is a natural consequence of some user actions, such as resizing a window so that it's larger or scrolling a View at an angle.&nbsp; In Figure 7-13, the two rectangles that need to be displayed after the user has scrolled are shown in white.&nbsp; Their union, the first rectangle in the array, would be a rectangle as large as the View.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F12.gif" width=252 height=315></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-13</b></font><font face="Times">.&nbsp; Update Rectangles</font>

<p><br><br>

<p><font face="Times">The drawing rectangles specify an area that, at its largest, is identical to the View's visible rectangle.&nbsp; They often specify an area smaller than the visible rectangle, but in no case do they specify any area falling outside the visible rectangle.&nbsp; Just as the bounds rectangle defines the largest area on the screen that a method should attempt to draw in, the drawing rectangles define the minimal area that should be redrawn.&nbsp; A <b>drawSelf::</b> method should be sure to cover at least the area specified in the drawing rectangles it's passed.</font>

<p><font face="Times">A View that's not scrolled and that almost certainly lies within the frame rectangles of all its ancestors can safely ignore the drawing rectangles and draw everything within its bounds rectangle.&nbsp; However, considerations of efficiency require most Views to limit their drawing to the smallest possible area.&nbsp; It's wasteful to redraw areas that don't require updating or to send drawing code to the Window Server if it won't be rendered.&nbsp; Views that are scrolled, especially large Views, should stay as close to the drawing rectangles as possible.</font>

<p><font face="Times">Dynamic drawing methods aren't passed an array of drawing rectangles by the Application Kit.&nbsp; These methods should use information from the event record and the visible rectangle to determine where to draw.&nbsp; The <b>getVisibleRect: </b>method supplies the visible rectangle:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp;&nbsp;&nbsp; isVisible;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; drawingArea;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">isVisible = [myView getVisibleRect:&amp;drawingArea];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>getVisibleRect:</b> determines how much of the receiving View's bounds rectangle lies within the frame rectangles of all its ancestor Views.&nbsp; If none of the receiving View lies within its ancestors, none of it is visible and <b>getVisibleRect: </b>returns NO.&nbsp; Otherwise, <b>getVisibleRect:</b> returns YES and places the View's visible rectangle in the structure referred to by its argument.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Graphics State Parameters</b></font>

<p><font face="Times">All of a View's drawing methods, including <b>drawSelf::</b> and the methods used to do dynamic drawing, assume the View's coordinate system as a starting point.&nbsp; They also assume other aspects of the graphics state--such as the halftone screen, line cap, and clipping path.&nbsp; A drawing method is free to change any graphics state parameter as long as it restores the original value when it's finished.&nbsp; Failure to do so may mean that other drawing methods won't function properly.&nbsp; This can adversely affect the methods defined in Application Kit classes such as Text, Button, and Scroller, as well as the methods you define in View subclasses.</font>

<p><font face="Times">However, not all graphics state parameters have a presumed value.&nbsp; Some--such as the current path, line width, and color--are altered so frequently by Views that there's no point in defining a default value.&nbsp; A drawing method can't rely on an initial value for these parameters; it must be careful to set them to their required values before drawing.&nbsp; It also has no responsibility for restoring their initial values later.</font>

<p><font face="Times">The chart below lists the parameters of the graphics state and their assumed values in the Application Kit.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Parameter</b></font></td>

<td><font face="Helvetica"><b>Presumed Value</b></font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">current transformation</font></td>

<td><font face="Times">The reference coordinate system for the View matrix (CTM)</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">color</font></td>

<td><font face="Times">No presumed value</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">position</font></td>

<td><font face="Times">No presumed value</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">path</font></td>

<td><font face="Times">No presumed value</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">clipping path</font></td>

<td><font face="Times">A path that's constructed around the frame rectangle and the drawing rectangles, as instructed by <b>setClipping:</b> and <b>display:::</b> messages sent to the View and its superviews</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">font</font></td>

<td><font face="Times">No presumed value</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">line width</font></td>

<td><font face="Times">No presumed value</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">line cap</font></td>

<td><font face="Times">The initial PostScript value, 0, for a square butt end</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">line join</font></td>

<td><font face="Times">The initial PostScript value, 0, for mitered joins</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">halftone screen</font></td>

<td><font face="Times">A device-dependent, type 3 halftone dictionary</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">flatness</font></td>

<td><font face="Times">The initial PostScript value, 1.0</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">miter limit</font></td>

<td><font face="Times">The initial PostScript value, 10</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">dash pattern</font></td>

<td><font face="Times">The initial PostScript value, a normal solid line</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">device</font></td>

<td><font face="Times">The current window</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">stroke adjustment</font></td>

<td><font face="Times">True</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">alpha</font></td>

<td><font face="Times">1.0 (opaque)</font></td></tr>

<tr valign=top>

<td width=124 height=10></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">instance drawing mode</font></td>

<td><font face="Times">False</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The last two items on this list are NeXT additions to the graphics state.&nbsp; Stroke adjustment is an addition of the Display PostScript system.</font>

<p><font face="Times">There are two recommended ways to restore a value that's been changed.&nbsp; The first is to save the current graphics state before drawing and restore it when you're through:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times">gsave</font><br>
<font face="Times"><i>PostScript code that changes graphics state parameters</i></font><br>
<font face="Times">grestore</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The second is to put the current value of the parameter that will change on the operand stack before you start and restore it when you're done:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times">currentlinecap  % Puts it on the operand stack</font><br>
<font face="Times"><i>PostScript code that changes the line cap</i></font><br>
<font face="Times"><i>PostScript code that adjusts the stack</i></font><br>
<font face="Times">setlinecap  % Uses the value on the stack</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To save and restore the halftone screen, use the <b>currenthalftone</b> and <b>sethalftone</b> operators (or <b>gsave</b> and <b>grestore</b>) instead of <b>currentscreen</b> and <b>setscreen</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The Display Methods</b></font>

<p><font face="Times">Five methods can be used to display a View and its subviews:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView display];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView display:&amp;bounds :1];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView display:&amp;bounds :1 :NO];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView displayIfNeeded];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView displayFromOpaqueAncestor:&amp;bounds :1 :NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Collectively, these five methods are referred to as the &quot;display methods.&quot;&nbsp; The first three are standard, general purpose methods.&nbsp; They're at the heart of the View display mechanism.&nbsp; The second two methods are more specialized. They're used in common, but quite specific situations.</font>

<p><font face="Times">The first three messages shown in the list above are all equivalent.&nbsp; Although the first two methods are the ones most commonly used, they're each simplified versions of the third method; <b>display</b> and <b>display::</b> both work by sending a <b>display:::</b> message to <b>self</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The <b>display::</b> method passes its two arguments on to <b>display:::</b> and adds NO as the third argument.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The <b>display</b> method is the same as <b>display:::</b> with a pointer to the receiving View's visible rectangle as the first argument, 1 as the second argument, and NO as the third argument.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The precise meaning of each argument is discussed in the section titled &quot;Display Method Arguments&quot; below.&nbsp; Most programs can ignore the arguments and safely use <b>display</b> in all situations.</font>

<p><font face="Times">The fourth method, <b>displayIfNeeded</b>, is like <b>display</b>, but it displays only those Views and subviews that have changed since they were last drawn on-screen and therefore need to be redisplayed.&nbsp; It's discussed in the next section, &quot;Managing a Window's Display.&quot;</font>

<p><font face="Times">The fifth method, <b>displayFromOpaqueAncestor:::</b>, is similar to <b>display:::</b>, but it ensures that any Views that draw in the background of the receiving View are also displayed.&nbsp; It's discussed in the section titled &quot;Displaying Background Views&quot; below.</font>

<p><font face="Times">No matter which display method is used, the essential work is done in four steps:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">The focus is locked on the receiving View.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">A message is sent for it to perform its <b>drawSelf::</b> method.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">3.</font></td>

<td><font face="Times">Its subviews are displayed.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">4.</font></td>

<td><font face="Times">The focus is unlocked.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The third step makes the display process recursive.&nbsp; If the receiving View has any subviews, the focus is locked on each subview in turn and a message is sent for the subview to perform its <b>drawSelf::</b> method.&nbsp; If the subview has subviews of its own, the focus is locked on each of them and they perform their own <b>drawSelf::</b> methods.&nbsp; Subviews are picked in the order that they appear in the View's <b>subviews</b> list, which usually reflects the order in which they were made subviews of the View.&nbsp; A View is sent an <b>unlockFocus</b> message only after all of its descendants have been displayed.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Order of Display</b></font>

<p><font face="Times">These steps are significant; they mean that Views draw in a particular order:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Subviews draw on top of (after) their superviews.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A subview that's further down in the subviews list draws on top of (after) sibling subviews that are earlier in the list.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Note that the order in which <b>hitTest:</b> attempts to associate mouse-down events with subviews is exactly opposite to the order of display.&nbsp; Displaying starts at the beginning of the subviews list; <b>hitTest:</b> starts at the end.&nbsp; If two sibling subviews overlap on the screen and a mouse-down event occurs in the overlapped area, the subview that draws on top will get the event.</font>

<p><font face="Times">Views can be reordered in the subviews list by methods defined in the View class and described under &quot;The Core Framework&quot; in the previous chapter.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Display Method Arguments</b></font>

<p><font face="Times">The two arguments to <b>display::</b> (the first two arguments to <b>display:::</b> and <b>displayFromOpaqueAncestor:::</b>) limit the amount of drawing code that's sent to the Window Server.&nbsp; The first argument is a pointer to an array of rectangles (NXRect *) that specify the areas to be displayed; the second argument (an <b>int</b>) indicates how many rectangles are in the array.&nbsp; With some modifications, the display methods pass these arguments on to the View's <b>drawSelf::</b> method.</font>

<p><font face="Times">It's assumed that the rectangles are specified in the same coordinate system as the View that receives the display message.&nbsp; There can be 0, 1, or 3 rectangles in the array.&nbsp; If it's 3, the first rectangle should be the union of the second and third, as described under &quot;Drawing Rectangles&quot; above.</font>

<p><font face="Times">If the rectangle pointer (the first argument) is NULL or the number of rectangles (the second argument) is 0, the display methods substitute a pointer to the visible rectangle for the first argument and 1 for the second.&nbsp; The visible rectangle encloses the smallest area that needs to be displayed to guarantee that everything visible in the View is drawn.</font>

<p><font face="Times">If any rectangles are passed to a display method, the method intersects each of them with the View's visible rectangle to ensure, to the extent possible, that they designate only areas lying within the View.&nbsp; The display methods then use the array of rectangles in three ways:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">They pass the rectangles on as arguments to the View's <b>drawSelf::</b> method.&nbsp; <b>drawSelf::</b> can ignore the arguments or use them to optimize the drawing it does.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">They don't display any subviews that lie entirely outside the areas that need to be displayed.&nbsp; If there's one rectangle in the array, only subviews that lie partially or wholly within the rectangle will be displayed.&nbsp; If there are three rectangles, only subviews that fall partially or wholly within the second or third rectangles will be displayed. The display methods do nothing with the first rectangle in the array, the union of the other two.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>display:::</b> constructs a clipping path around the rectangles if requested to do so in its third argument.&nbsp; This clipping is in addition (and prior) to the clipping done when focusing on the View.&nbsp; Only the View that receives the initial <b>display:::</b> message is clipped in this way; its subviews are not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Before each subview is recursively displayed, the display methods intersect each of the rectangles with the subview's frame rectangle and translate the results to the subview's coordinate system.&nbsp; Each View that's displayed is guaranteed to be passed drawing rectangles that:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Are in its own coordinate system.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Designate no areas outside of its visible rectangle.&nbsp; The drawing rectangles may designate an area to draw in that's smaller than the visible rectangle, however.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">See &quot;Drawing Rectangles&quot; above for information on how to use these rectangles in a <b>drawSelf::</b> method.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Displaying Background Views</b></font>

<p><font face="Times">When a View surrenders a portion of a window--either because it becomes smaller or because it moves to a new location--it isn't enough that it just display itself again.&nbsp; Any Views that it covered in the areas it abandoned must also be given a chance to redisplay themselves.&nbsp; A <b>display:::</b> message to its superview gives the superview and any sibling subviews this chance:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[superview display:&amp;myOldFrame :1 :NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The message above is appropriate for a View that shrank.&nbsp; If it had moved, it would have passed an array of its old and new frame rectangles (and their union).</font>

<p><font face="Times">For a similar reason, when a View draws against a background provided by another View, it's not enough that it send just itself a display message.&nbsp; The View that provides the background must also be given the opportunity to redisplay itself.&nbsp; In fact, any View that doesn't erase or redraw everything within the drawing rectangles should make sure that the Views behind it are redisplayed.&nbsp; Instead of sending itself a <b>display:::</b> message, it should use the <b>displayFromOpaqueAncestor:::</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[self displayFromOpaqueAncestor:&amp;bounds :1 :NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The three arguments to <b>displayFromOpaqueAncestor:::</b> are identical to the three arguments to <b>display:::</b>.&nbsp; The first is an array of rectangles specifying the area to be redisplayed; the second is the number of rectangles in the array.&nbsp; The third indicates whether to construct a clipping path around those rectangles.</font>

<p><font face="Times">The <b>displayFromOpaqueAncestor:::</b> method treats its arguments a bit differently than <b>display:::</b>, however.&nbsp; It first searches up the view hierarchy for the nearest ancestor View that guarantees that it will cover all the pixels within its frame rectangle with a fresh coat of opaque paint.&nbsp; <b>displayFromOpaqueAncestor:::</b> then translates the drawing rectangles to this View's coordinate system and sends it a <b>display:::</b> message.&nbsp; If no View lower in the hierarchy meets the requirement, the <b>display:::</b> message is sent to the frame view at the root of the view hierarchy (the content view's superview).&nbsp; The frame view erases the content area to the Window's background color.</font>

<p><font face="Times">If the receiving View itself guarantees that it draws all its pixels in opaque paint, <b>displayFromOpaqueAncestor:::</b> is no different than <b>display:::</b>.</font>

<p><font face="Times">This procedure ensures that the areas that need to be updated are completely redrawn.&nbsp; The View that received the <b>displayFromOpaqueAncestor:::</b> message will get a message to display itself after the Views behind it have been displayed.</font>

<p><br><br>

<p><font face="Helvetica"><b>Registering as an Opaque View</b></font>

<p><font face="Times">If a View paints all the pixels within its frame rectangle with opaque paint, it should be registered as an opaque View:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setOpaque:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A NO argument to <b>setOpaque:</b> would unregister the View.&nbsp; The <b>isOpaque</b> method returns whether or not the receiver is currently registered:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; erases;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">erases = [myView isOpaque];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Once it's registered as opaque, the View becomes a potential recipient of a display message from <b>displayFromOpaqueAncestor:::</b>.</font>

<p><font face="Times">Views are generally opaque because they erase before drawing, perhaps using the <b>NXRectFill()</b> or <b>NXEraseRect() </b>functions to fill their entire frame rectangles with a solid color before drawing detailed images.&nbsp; Box, ScrollView, and the Window's frame view are the principal opaque Views.&nbsp; A Text object becomes an opaque View after it receives a <b>setOpaque:</b> message with YES as the argument.</font>

<p><font face="Times">By displaying itself through the <b>displayFromOpaqueAncestor:::</b> method, a View can rely on other Views to erase for it.</font>

<p><br><br>

<p><font face="Helvetica"><b>Finding the Background View</b></font>

<p><font face="Times">The <b>opaqueAncestor</b> method returns the receiver, if it's opaque, or the nearest opaque View above it in the view hierarchy:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp; backgroundView;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">backgroundView = [myView opaqueAncestor];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In other words, <b>opaqueAncestor</b> returns the View that <b>displayFromOpaqueAncestor:::</b> would send a <b>display::: </b>message to.&nbsp; You can bypass <b>displayFromOpaqueAncestor:::</b> by sending your own display messages to the opaque View.</font>

<p><font face="Times"><b>opaqueAncestor</b> may return the frame view:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; isFrameView;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">isFrameView = ![[self opaqueAncestor] superview];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">While you can send the frame view display messages, you should be careful not to alter it in any way.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Window's Display Methods</b></font>

<p><font face="Times">In addition to the display methods defined in the View class, Window has two display methods:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow display];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow displayIfNeeded];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Both methods pass display messages on to the Views in the Window's view hierarchy.&nbsp; The <b>display</b> method displays all the Views in the view hierarchy, from the frame view on down.&nbsp; It's usually used to set up the Window's initial display. The <b>displayIfNeeded</b> method displays just those Views that need to be redisplayed.&nbsp; It's discussed under &quot;Managing a Window's Display&quot; below.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Automatic Display Messages</b></font>

<p><font face="Times">An application can send display messages to its Views at any time, but display messages are also initiated automatically, either as the result of a user action or as a corollary to some change in the View.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">After it has been resized by the user, a Window sends a <b>display</b> message to its frame view.&nbsp; Every View in the view hierarchy will redisplay itself to fit the window's new size.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When a Window receives a window-exposed subevent (of the kit-defined event), it sends a <b>display::</b> message to its frame view.&nbsp; The message specifies a single rectangle enclosing just the areas of the Window that need to be redrawn.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When a View is scrolled, the Application Kit copies the portions of the display that remain in view to their new locations.&nbsp; It then sends the View a <b>display::</b> message to have it redraw the update areas (as illustrated above in Figure 7-13, &quot;Update Rectangles&quot;).&nbsp; If the user scrolls the contents of a View vertically or horizontally, there will be a single area to be updated.&nbsp; If the user scrolls the View at an angle, there will be two update rectangles in the array.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When a View attribute changes, the View may send itself a <b>display</b> message to make the change visible.&nbsp; See &quot;Updating Views&quot; in the section below.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Whenever a Window is updated automatically, it may respond by sending its Views display messages.&nbsp; See &quot;Updating Windows&quot; below.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When a Window receives a <b>display</b> message, every View in its hierarchy is displayed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Because a View must be prepared to redisplay itself at any time in response to automatic display messages, all the code necessary to completely redraw the View should be contained in (or called by) its <b>drawSelf::</b> method.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Managing a Window's Display</b></font>

<p><font face="Times">The Window and View classes define some methods to help applications keep their on-screen displays current and make more efficient use of the display mechanism.&nbsp; They include:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Methods for updating a Window automatically</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A convention for automatically displaying Views when they change, and methods for temporarily suspending the automatic display</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A way of temporarily suspending the display mechanism within a Window</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A way of temporarily suspending the part of the display mechanism that automatically flushes a window buffer to the screen</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The sections below discuss each of these topics.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Updating Windows</b></font>

<p><font face="Times">Just before an off-screen Window is moved on-screen, it's sent an <b>update</b> message so that it can bring its display up-to-date with the current state of the application.</font>

<p><font face="Times">Window's default version of the <b>update</b> method simply returns <b>self</b>.&nbsp; A subclass can implement its own version to keep its display current.&nbsp; Menus use <b>update</b> messages to modify commands (from &quot;Undo&quot; to &quot;Redo,&quot; for example), and to disable and reenable them, as appropriate.</font>

<p><br><br>

<p><font face="Helvetica"><b>On-Screen Windows</b></font>

<p><font face="Times">The automatic <b>update</b> message lets an off-screen Window alter its display before becoming visible.&nbsp; But Windows that are already visible also need to be updated periodically; the main menu, for example, is always on-screen.&nbsp; The Application object's <b>updateWindows</b> method fills this need by sending every on-screen Window in the window list an <b>update</b> message.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp updateWindows];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">You can send NXApp an <b>updateWindows</b> message at appropriate times for your application, or you can arrange to have it performed automatically after every event:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[NXApp setAutoupdate:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If NXApp receives the message above, it sends each visible Window an <b>update</b> message after each event has been processed in the main event loop or in a modal event loop for an attention panel.&nbsp; A NO argument to <b>setAutoupdate: </b>stops the flow of automatic <b>update</b> messages to on-screen Windows.&nbsp; (Off-screen Windows continue to receive them.)</font>

<p><font face="Times">Note that automatic <b>update</b> messages are sent only after NXApp dispatches an event from the event loops set up by <b>run</b> and <b>runModalFor:</b> messages.&nbsp; If an application sets up a modal event loop in response to an event, no <b>update </b>messages will be sent until the modal loop ends.&nbsp; If the modal loop is for an attention panel, no <b>update</b> message will be sent until after the first event is dispatched in the loop.&nbsp; Therefore, this mechanism can't be used to disable menu items upon entering the mode.</font>

<p><br><br>

<p><font face="Helvetica"><b>Updating Menus</b></font>

<p><font face="Times">For a Menu to respond to <b>update</b> messages, at least one of its MenuCells must be assigned a method that can determine how the MenuCell should be displayed.&nbsp; The <b>setUpdateAction:</b> method makes the assignment:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[menuItem setUpdateAction:@selector(fixMe:)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>updateAction</b> method returns the method selector that was assigned:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">SEL&nbsp; theMethod;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">theMethod = [menuItem updateAction];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A different method can be assigned to each MenuCell.&nbsp; The method should take just one argument, the <b>id</b> of the MenuCell, and it should be implemented by the Menu's delegate.&nbsp; (Menus inherit the delegate defined in the Window class.)&nbsp; The method's job is to check the current state of the application and alter the MenuCell accordingly.&nbsp; It should return boolean YES if the MenuCell needs to be redisplayed, and NO if it doesn't.</font>

<p><font face="Times">Whenever a Menu receives an <b>update</b> message, it has its delegate perform the updating methods for each of its MenuCells.&nbsp; If a method has been assigned to more than one MenuCell, it will perform once for each MenuCell it's assigned to.&nbsp; There is no default updating method; you must assign one with the <b>setUpdateAction:</b> method and implement the method in the Menu's delegate.</font>

<p><font face="Times">You can temporarily suspend updating for a particular Menu, while leaving it in place for all other Windows, by sending the Menu a <b>setAutoupdate:</b> message with NO as the argument:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myMenu setAutoupdate:NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This disables the Menu's <b>update</b> method.&nbsp; By default, updating is enabled if an updating method has been assigned to any of the Menu's MenuCells; <b>setUpdateAction:</b> sends a <b>setAutoupdate:</b> message to the Menu with YES as its argument, thus automatically enabling the updating mechanism.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Updating Views</b></font>

<p><font face="Times">In general, when a View changes its state, it should display the change immediately.&nbsp; For example:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- setTitle:(char *)aString</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">title = aString;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self display];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">There may be times, however, when it's best to postpone updating the display.&nbsp; For example, if several View attributes change at once, you probably want to wait until the last change is made to redisplay the View, rather than redisplay it after each change.</font>

<p><font face="Times">To temporarily prevent a View from being automatically displayed, you can send it a <b>setAutodisplay:</b> message with NO as its argument:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setAutodisplay:NO];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The same message with a YES argument reinstates automatic displaying.&nbsp; By default, all Views are created with the automatic display flag turned on.&nbsp; The <b>isAutodisplay</b> method returns the current state of the flag:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; doesDisplay;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">doesDisplay = [myView isAutodisplay];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For this scheme to work, methods that alter View attributes must check whether it's OK to display the View.&nbsp; The <b>setTitle:</b> method shown above would need to be implemented more like this:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- setTitle:(char *)aString</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">title = aString;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( [self isAutodisplay] )</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[self display];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If a method changes a View but doesn't redisplay it because the automatic display flag is off, it can set another flag (<b>vFlags.needsDisplay</b>) indicating that the View still needs to be displayed:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setNeedsDisplay:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This method works only while the View can't be automatically displayed (while the <b>isAutodisplay</b> method returns NO).</font>

<p><font face="Times">Other methods can check this flag to see whether they should display the View:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; outOfDate;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">outOfDate = [myView needsDisplay];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">One method that checks the flag is <b>setAutodisplay:</b>.&nbsp; When it turns automatic displaying back on (when its argument is YES), it checks whether the receiving View needs to be displayed.&nbsp; If it does, <b>setAutodisplay:</b> sends the View a display message.&nbsp; Displaying the View clears its <b>needsDisplay</b> flag; thereafter the <b>needsDisplay</b> method returns NO.</font>

<p><font face="Times">Another method that checks the flag is <b>displayIfNeeded</b>.&nbsp; It works its way down the view hierarchy, displaying only those Views that have their <b>needsDisplay</b> flags turned on.&nbsp; For more on this method, see &quot;Displaying If Needed&quot; later in this section.</font>

<p><font face="Times">With this refinement, the <b>setTitle:</b> method illustrated above would look more like this:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- setTitle:(char *)aString</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">title = aString;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( [self isAutodisplay] )</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[self display];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[self setNeedsDisplay:YES];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">For convenience, the conditional statements in the <b>setTitle:</b> method illustrated above have been segregated into a separate View method, <b>update</b>.&nbsp; This last version of <b>setTitle:</b> can be simplified to three lines:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- setTitle:(char *)aString</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">title = aString;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self update];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">It's recommended that all Views use the <b>update</b> method and follow the conventions it depends on.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Suspending Display</b></font>

<p><font face="Times">Just as it's sometimes a good idea to suspend the automatic updating of Views, it can also be a good idea to suspend all the displaying done within a Window for a short period of time.&nbsp; Suppose, for example, that several Views are changing and need to be redisplayed.&nbsp; You want the changes to be displayed all at once, not in piecemeal fashion.&nbsp; Rather than turn off the automatic display feature of each View, it's more convenient to suspend the display mechanism for the entire Window.</font>

<p><font face="Times">Similarly, if an off-screen Window is undergoing a series of changes, with some of the changes cancelling others, you may want to wait until the Window receives an <b>update</b> message (just before it's placed on-screen) to display the changes.&nbsp; This could save on the volume of PostScript code sent to the Window Server.</font>

<p><font face="Times">The <b>disableDisplay</b> method suspends displaying within a Window:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow disableDisplay];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This message prevents the display methods defined in the View class from displaying any View within the Window.&nbsp; It should always be balanced with a <b>reenableDisplay</b> message when it's again OK to display the Window's Views.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow reenableDisplay];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Because there can be many reasons to suspend the display methods, pairs of <b>disableDisplay</b> and <b>reenableDisplay </b>messages can be nested.&nbsp; Displaying isn't reinstated until the last <b>reenableDisplay</b> message is sent.</font>

<p><font face="Times">While displaying is disabled, display messages that reach any of the Window's Views have no effect except to set the View's <b>needsDisplay</b> flag.&nbsp; This makes it easy to find the Views that couldn't be displayed and to redisplay them when it's again possible.</font>

<p><font face="Times">The <b>isDisplayEnabled</b> method returns whether or not displaying is currently suspended for the receiving Window:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">BOOL&nbsp; canDraw;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow isDisplayEnabled];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All the display methods defined in the View class and Window class are disabled by <b>disableDisplay</b>, except one.&nbsp; The <b>display</b> method defined in the Window class reenables displaying before sending a display message to its frame view.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Suspending flushWindow</b></font>

<p><font face="Times">The <b>disableDisplay</b> method described above prevents the display methods from sending any drawing code to the Window Server.&nbsp; On occasion, you may want a less severe suspension of the display mechanism.&nbsp; It might be more efficient to continue rendering images in the window's backup buffer, but wait to have them flushed to the screen.</font>

<p><font face="Times">For those occasions, <b>disableFlushWindow</b> and <b>reenableFlushWindow</b> can be used instead of <b>disableDisplay</b> and <b>reenableDisplay</b>.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow disableFlushWindow];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* code that displays Views within the Window goes here */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow reenableFlushWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>disableFlushWindow</b> prevents Window's <b>flushWindow</b> method from flushing the backup buffer of the receiving Window.&nbsp; After reenabling the method, the window buffer should be explicitly flushed:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow flushWindow];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Since <b>flushWindow</b> is used by the display methods, disabling it lets a number of images accumulate in the buffer before they're shown to the user.</font>

<p><font face="Times"><b>disableFlushWindow</b> works only if the receiving Window object manages a buffered window.&nbsp; Of the three buffering types (nonretained, retained, and buffered), only buffered windows require drawing to be flushed to the screen.</font>

<p><font face="Times">Like <b>disableDisplay</b> and <b>reenableDisplay</b>, pairs of <b>disableFlushWindow</b> and <b>reenableFlushWindow</b> messages can be nested.&nbsp; Window's <b>display</b> method doesn't automatically reenable flushing, however.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Displaying If Needed</b></font>

<p><font face="Times">A View's <b>needsDisplay</b> flag is set automatically when:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">An <b>update</b> message is unable to display the View (because automatic displaying is disabled).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A display message is unable to display the View because displaying has been disabled for the Window where the View is located.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A display message is sent to the View when the View isn't associated with a window.&nbsp; A View isn't associated with a window if it hasn't been assigned to a view hierarchy or if the Window Server hasn't yet created a window for the Window object.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In each case, the flag is a signal that there has been an unsuccessful attempt to display the View, which likely means that the appearance of the View doesn't reflect its current state.&nbsp; You can also set the flag directly using the <b>setNeedsDisplay:</b> method.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setNeedsDisplay:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The View class defines a <b>displayIfNeeded</b> method that displays a View only if its <b>needsDisplay</b> flag is on.&nbsp; It's thus a much more efficient way of choosing which Views to update than the other display methods.</font>

<p><font face="Times">The Window class also defines a <b>displayIfNeeded</b> method, which simply passes the <b>displayIfNeeded</b> message on to the Window's frame view.&nbsp; As the message works its way down the view hierarchy, only flagged Views are displayed. Displaying the View turns the flag off.</font>

<p><font face="Times">If a number of changes need to be made within a window, you can disable the display mechanism, make the changes, reenable the display mechanism, and then send the Window a <b>displayIfNeeded</b> message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow disableDisplay];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* make whatever changes are needed */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow reenableDisplay];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myWindow displayIfNeeded];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the methods that make the changes include automatic <b>update</b> messages, every altered View will be flagged and only those Views will be redisplayed.&nbsp; If <b>update</b> messages aren't sent automatically, you can send them yourself, or flag the Views directly with the <b>setNeedsDisplay:</b> method.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Modifying the Frame Rectangle</b></font>

<p><font face="Times">A View's initial frame rectangle is set by the class method that creates it.&nbsp; Slider's <b>newFrame:</b> method is an example:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySlider;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; rect;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSetRect(&amp;rect, 20.0, 300.0, 15.0, 150.0);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mySlider = [Slider newFrame:&amp;rect];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">After a View is created, its frame rectangle can be relocated and resized by methods that insert new values in the View's <b>frame</b> instance variable:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setFrame:&amp;newRect];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView moveTo:40.0 :100.0];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView sizeTo:30.0 :200.0];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Two other methods alter the current values by a specified amount:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView moveBy:1.0 :1.0];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView sizeBy:-5.0 :10.0];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These two methods simply add the values recorded in the <b>frame</b> instance variable to the values they're passed and perform the <b>sizeTo:</b> and <b>moveTo:</b> methods to set the new values.</font>

<p><font face="Times">The <b>getFrame:</b> method provides the View's current frame rectangle:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; rect;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView getFrame:&amp;rect];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Views can also be rotated around the point recorded in <b>frame.origin</b>.&nbsp; Here a View is first rotated counterclockwise 108 from its superview's coordinates, then turned back 36 clockwise:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView rotateTo:108.0];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView rotateBy:-36.0];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Rotation turns the whole frame rectangle so that its sides are no longer aligned with its superview's coordinate system. This was illustrated earlier in Figures 6-7, &quot;View Frame Rotation,&quot; and 6-8, &quot;Default Coordinates.&quot;</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The <b>rotateTo:</b> and <b>rotateBy:</b> methods rotate the View itself, not its default coordinate system.&nbsp; In contrast, the <b>rotate:</b> method described earlier under &quot;Modifying Default Coordinates&quot; rotates the View's coordinate system, but not the View.</font>

<p><font face="Times">The <b>frameAngle</b> method returns the angle between the x- and y-axes of the superview's coordinate system and the sides of the frame rectangle:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp; rotation;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">rotation = [myView frameAngle];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If <b>frameAngle</b> returns 0.0, the View isn't rotated from its superview.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Resizing Subviews</b></font>

<p><font face="Times">When a Window is resized, the Application Kit automatically resizes the frame view and content view to fit the new dimensions of the window.&nbsp; You should never resize these Views yourself.</font>

<p><font face="Times">When a View is resized, especially if it's the content view, it may be necessary to adjust the size or position of its subviews.</font>

<p><font face="Times">An application could explicitly adjust all Views with newly altered superviews whenever it resizes a Window or View. It could do the same when it receives a <b>windowDidResize:</b> message indicating that the window, and therefore the content view, has been resized.</font>

<p><font face="Times">The Application Kit provides a simpler solution, however.&nbsp; You can specify how you want a subview to adjust to a resized superview and let the adjustment happen automatically.</font>

<p><font face="Times">A superview will automatically adjust its subviews if it's sent a <b>setAutoresizeSubviews:</b> message with YES as the argument:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[parentView setAutoresizeSubviews:YES];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Each subview must be told how to adapt with a <b>setAutosizing:</b> message:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setAutosizing:(NX_WIDTHSIZABLE | NX_HEIGHTSIZABLE)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The argument is a mask formed from the constants illustrated in Figure 7-14 below.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F13.gif" width=397 height=146></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-14</b></font><font face="Times">.&nbsp; Resizing Constants</font>

<p><br><br>

<p><font face="Times">The constants specify what should be made to shrink or grow, both horizontally and vertically, to compensate for changes in the superview.&nbsp; In each direction, there are three choices:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Resize the subview itself (NX_WIDTHSIZABLE and NX_HEIGHTSIZABLE).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Resize the margin separating the edge of the superview from the sides of the subview with the lowest coordinate values (NX_MINXMARGINSIZABLE and NX_MINYMARGINSIZABLE).</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Resize the margin separating the edge of the superview from the sides of the subview with the highest coordinate values (NX_MAXXMARGINSIZABLE and NX_MAXYMARGINSIZABLE).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The effect of different masks can be illustrated if a few changes are made to the Little demonstration program listed under &quot;Setting Up Event-Handling Objects&quot; earlier in this chapter.&nbsp; First, the Window is given a resize bar and enlarged a little, and the Text object is centered in the content view so that it's bordered by a uniform gray margin between it and the edge of the Window.&nbsp; This is shown in the first pane of Figure 7-15 below.&nbsp; Next, the content view is sent a <b>setAutoresizeSubviews:</b> message and the Text object is sent the <b>setAutosizing:</b> message illustrated above with a mask formed from NX_WIDTHSIZABLE and NX_HEIGHTSIZABLE.&nbsp; This tells the subview to resize itself while keeping its margins constant, as shown in the second pane of Figure 7-15.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="F14.gif" width=466 height=207></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Figure 7-15</b></font><font face="Times">.&nbsp; Resizing Subviews</font>

<p><br><br>

<p><font face="Times">It's also possible to resize the margins but keep the subview itself constant:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[myView setAutosizing:(NX_MINXMARGINSIZABLE</font><br>
<img src="../../Images/sp.gif" width=271 height=1><font face="Courier" size="-1">| NX_MINYMARGINSIZABLE</font><br>
<img src="../../Images/sp.gif" width=271 height=1><font face="Courier" size="-1">| NX_MAXXMARGINSIZABLE</font><br>
<img src="../../Images/sp.gif" width=271 height=1><font face="Courier" size="-1">| NX_MAXYMARGINSIZABLE)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The result is illustrated in the third pane of Figure 7-15.</font>

<p><font face="Times">Other combinations are also possible, including resizing both the margins and the subviews proportionally.&nbsp; Each mask should specify something to resize in both the horizontal and the vertical directions.&nbsp; If not, the margins with the greatest coordinate values will be the ones that change.</font>

<p><font face="Times">The method that actually does the resizing is <b>superviewSizeChanged:</b>.&nbsp; You can override it for a View that needs to be resized in a special way.&nbsp; The argument passed to <b>superviewSizeChanged:</b> is a pointer to an NXSize structure containing the old size of the superview.&nbsp; The receiving subview can get the superview's new size directly from the superview by sending it a <b>getFrame:</b> message.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Printing</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">There are many different software components involved in printing with the NeXT computer.&nbsp; Printing begins in an application using the Application Kit connected to the Window Server.&nbsp; In response to a user's menu choice, the application, in conjunction with the Application Kit, generates the PostScript code required for rendering the images to be printed and sends it to the printing daemon, <b>npd</b>.&nbsp; <b>npd</b> establishes its own connection to the Window Server, prepares that Display PostScript context for imaging to the printer, and sends the Server the PostScript code, page by page.</font>

<p><font face="Times">The application's role in this chain of events is to work with the Application Kit to generate correct PostScript code which can be spooled to the printer via <b>npd</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Generating PostScript Code</b></font>

<p><font face="Times">One of the architectural features of the NeXT computer is that it uses PostScript to draw on the display as well as the printer.&nbsp; This single imaging model simplifies printing, since if applications can draw their images on the screen, they are immediately capable of drawing them on the printer too.</font>

<p><font face="Times">When an application prints, it's usually printing all or part of a certain View, or possibly an entire window.&nbsp; One common case is for a document-oriented application to want to print the View containing the document in the key window.&nbsp; A View is printed by sending it a <b>printPSCode:</b> message, similar to how a View is displayed by sending it a display message.&nbsp; In fact, the printing machinery sends one or more display messages for various parts of the View. It's therefore essential that a View be able to successfully regenerate its image when sent a display message.&nbsp; The code to do this should be located in the <b>drawSelf::</b> method that's performed in response to display messages.&nbsp; If this criterion is met, basic printing should be fairly easy for any application to achieve, and more advanced applications should have sufficient hooks to tune the default printing process.</font>

<p><font face="Times">Although both the display and printer are driven by PostScript code, there are a few subtle differences between the PostScript code used to draw on the screen and the code generated while printing.&nbsp; One difference is that the PostScript code normally sent to the Window Server is an unbroken stream of PostScript commands, whereas the file of PostScript code created when printing &quot;conforms&quot; to a set of &quot;Document Structuring Conventions.&quot;&nbsp; Most of these conventions involve special comments inserted into the PostScript stream.&nbsp; An important convention that the files created by the Application Kit follow is that the PostScript code is divided into a &quot;prologue&quot; and a &quot;script&quot; section.&nbsp; The prologue contains definitions used by the document, but no imaging code, and the script contains order-independent pages marked by various comments.&nbsp; The Application Kit provides a convenient framework for generating conforming files. (For more information, see the <i>Adobe Systems Document Structuring Conventions</i>.)</font>

<p><font face="Times">Although the application has full access to its state when generating the PostScript code, when that file is actually imaged on the printer, the application will be completely uninvolved.&nbsp; Here &quot;state&quot; includes any state the application has created for itself within its PostScript execution context within the Window Server, or any state it has stored in PostScript shared VM in the Server.&nbsp; Also, the code may be printed via a network on a completely different machine than the one it was created on, with a completely different file system.&nbsp; For these reasons, the PostScript file that an application generates should not rely on any definitions outside itself, or any other state that cannot be guaranteed when the file is actually interpreted.&nbsp; For example, it isn't possible in the printing code to composite bits from an off-screen window that was created earlier in the application, since that window will not exist when the file is actually imaged.</font>

<p><font face="Times">It should be possible to print a file generated with the Application Kit on a PostScript device other than a NeXT computer and 400 dpi Laser Printer.&nbsp; To ensure this compatibility, you should be careful not to use Display PostScript extensions to draw while printing.&nbsp; This includes compositing operators, operators referring to windows or events, instance drawing operators, and graphics state operators.&nbsp; A few operators will be predefined in the template prologue generated by the Application Kit, and will thus be usable during printing.&nbsp; It's certain that <b>rectclip</b>, <b>rectstroke</b>, and <b>rectfill</b> will be simulated exactly in this prologue, and that the operators listed below will be defined to be a NULL operations.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">flushgraphics</font></td>

<td><font face="Times">hidecursor</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">execuserobject</font></td>

<td><font face="Times">revealcursor</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">defineuserobject</font></td>

<td><font face="Times">obscurecursor</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">setcursor</font></td>

<td><font face="Times">showcursor</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Other operators may be predefined in the future.&nbsp; Applications may use the global variable NXDrawingStatus (described in the next section) to determine if they are displaying to the screen or printing.</font>

<p><font face="Times">Another important difference between displaying on the screen and printing is the data format.&nbsp; Almost all communication with the Window Server happens in an efficient, binary format, facilitated by the <b>pswrap</b> tool and the <b>dpsclient</b> library.&nbsp; When printing, ASCII PostScript code is written to a disk file.&nbsp; Fortunately, most applications will be unaffected by this format difference, since the Application Kit does sufficient setup to make the <b>dpsclient</b> library convert outgoing PostScript code from binary to ASCII when printing.&nbsp; Therefore, the same <b>pswrap</b>-generated functions can be used for displaying and printing.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Application Kit Printing Architecture</b></font>

<p><font face="Times">The printing machinery in the Application Kit is structured to take advantage of the object-oriented environment.&nbsp; All Views and Windows inherit a method named <b>printPSCode:</b>, which should do a reasonable default job of generating a PostScript file for that View or Window.&nbsp; Almost all of what <b>printPSCode:</b> does is call other support methods in View. Applications modify the printing behavior of that View by overriding these other methods.&nbsp; Since the various functions of printing are broken out into these other separate methods, it's easy to change any aspect of printing by overriding a simple method.&nbsp; When overriding many of these methods, an application will be able to affect the desired change to the default behavior, and still call upon the View superclass for most of the method's implementation.</font>

<p><font face="Times">For example, let's say you want to insert the title of the document your application is printing into the conforming PostScript file as a &quot;%%Title&quot; comment.&nbsp; You also want to add some conforming comments to the spooled file's header.&nbsp; As your View generates its prologue, it calls a method whose charter is to generate the start of the prologue. You could override this method as follows:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- beginPrologueBBox:(NXRect *)boundingBox</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">creationDate:(char *)dateCreated</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">createdBy:(char *)anApplication</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">fonts:(char *)fontNames</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">forWhom:(char *)user</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">pages:(int)numPages</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">title:(char *)aTitle</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[super beginPrologueBBox:boundingBox</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">creationDate:dateCreated</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">createdBy:anApplication</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">fonts:fontNames</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">forWhom:user</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">pages:numPages</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">title:&lt;title of current window's document&gt;];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">DPSPrintf( &#34;%%%%SomeComment: %d&#34;, someNumber );</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">During printing, various parameters control aspects of the printing job, such as how many pages are printed, and the size of the paper being printed on.&nbsp; This information can be set by the user through the PageLayout and Print panels, and is stored in an object of class PrintInfo.&nbsp; While a given print command is being executed, this information can be retrieved from a global PrintInfo kept by the application.&nbsp; For example, to find out the last page requested to print by the user, you could use the expression:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">[[NXApp printInfo] lastPage];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Simple applications will probably be content with having a single PrintInfo object that's created and initialized by the Application Kit.&nbsp; More advanced, document-oriented applications will probably want to store some pieces of the PrintInfo's data with their document, such as the paper type the document was created for.&nbsp; Such applications will need to ensure that the correct PrintInfo object is present in the Application object for all that ask for it.&nbsp; This could be done by either overriding Application's <b>printInfo</b> method and returning an appropriate object, or by setting the current PrintInfo object every time the active document changes.</font>

<p><font face="Times">One other useful piece of global information available to the application is the variable NXDrawingStatus, which can be NX_DRAWING, NX_PRINTING, or NX_COPYING.&nbsp; This variable reflects whether the program is generating PostScript code for the display, the printer, or the pasteboard.&nbsp; Sometimes applications will need to do some conditional drawing based on whether they're printing or not.&nbsp; NXDrawingStatus can be tested in a View's <b>drawSelf::</b> method to know the current drawing mode.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Pagination</b></font>

<p><font face="Times">When the Application Kit is printing, it loops through all the pages being printed, determines the portion of the View being printed that belongs on the current page, and tells the View to display that portion of itself.&nbsp; The goal of pagination is to determine what parts of the View should appear on which page.</font>

<p><font face="Times">Pagination happens in two modes.&nbsp; In the first mode, the Application Kit applies a recursive algorithm to the View being printed, which allows the View and its subviews to participate in how they are split up onto various pages.&nbsp; By default, a View tries to alter the pagination boundaries so that it's not split in two.&nbsp; Some Views will want to override the <b>adjustPageWidthNew:left:right:limit:</b> or <b>adjustPageHeightNew:top:bottom:limit:</b> method to change how they're broken up when they cross a page boundary.&nbsp; For example, Text uses the second method to make sure that lines of text are not cut in half when the Text object crosses a page boundary.</font>

<p><font face="Times">In the second mode of pagination, the application tells the Kit where the various pages lie.&nbsp; This mode will be used by advanced applications that do their own pagination, and know where their page breaks lie.&nbsp; In this mode, the Application Kit will ask the application for the rectangle for a given page with the <b>getRect:forPage:</b> method, and will later tell the View to display this same rectangle.</font>

<p><font face="Times">The first of these pagination modes is the default.&nbsp; It's fairly automatic, and should produce reasonable results for many applications.&nbsp; Views can override the <b>knowsPagesFirst:last:</b> method to tell the Application Kit that they will use the second method, and be responsible for their own pagination.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Image Placement on the Page</b></font>

<p><font face="Times">Pagination determines what rectangle of the View told to print will be drawn on a given page.&nbsp; Before the View is told to display that rectangle, the Application Kit must know how to place that image on the physical page.</font>

<p><font face="Times">For each page printed, the View told to print is sent the <b>placePrintRect:offset:</b> message.&nbsp; This method is passed the rectangle being printed in page coordinates, and is to return the offset from the lower left corner of the page that should be used to position the image.&nbsp; The area of the paper being used can be obtained from the PrintInfo object with the <b>paperRect</b> method.</font>

<p><font face="Times">The default implementation of <b>placePrintRect:offset:</b> uses some bits in the PrintInfo object to determine whether to center the image, or to align it with the top and left margins on the page.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Display PostScript Contexts</b></font>

<p><font face="Times">The Display PostScript system has facilities for controlling the concurrent execution of multiple execution contexts within the Window Server.&nbsp; The <b>dpsclient</b> library extends the concept of a Display PostScript context for clients to be any output channel to which the library sends PostScript code.&nbsp; During normal operation, the application has a single binary connection to the Window Server through which it gets all events and performs all drawing.&nbsp; This connection is represented by the context instance variable of the Application object.&nbsp; When printing is begun, the Application Kit creates a second DPSContext whose output is in ASCII format.&nbsp; This context is stored in the PrintInfo object during printing.&nbsp; During printing, this new context is made the current context, and hence the PostScript generated by the application is sent to that file, and not to the Window Server.</font>

<p><font face="Times">Sometimes an application needs to communicate briefly with the Window Server while generating PostScript code. For example, it may need to read some data from the Window Server as part of doing some drawing.&nbsp; In these cases, the normal server DPSContext can be made the current context temporarily.&nbsp; After communicating with the Window Server, the context should be reset back to the context used for printing:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">DPSSetContext( [NXApp context] );</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* talk to the Window Server here */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">DPSSetContext( [[NXApp printInfo] context] );</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* resume generating PostScript code to be printed */</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Panels</b></font>

<p><font face="Times">There are three panels by which the user controls the various parameters of printing.&nbsp; The first is a PageLayout object. This panel is used to set properties that affect printing that affect how a WYSIWYG document is displayed on the screen.&nbsp; Applications will want to save most items from this panel with their documents.</font>

<p><font face="Times">The second panel is a PrintPanel object.&nbsp; The PrintPanel holds attributes of a given printing session that affect how the document is printed.&nbsp; Applications will not want to save these attributes with their documents.</font>

<p><font face="Times">The third panel is a ChoosePrinter object.&nbsp; It's invoked from the PrintPanel and permits the user to choose a printer to print on.</font>

<p><font face="Times">Each application has only one copy of each of these panels.&nbsp; If a panel has already been created, requests sent to the class object for a new panel will return the one already created.</font>

<p><font face="Times">Both of these panels load their contents from the global PrintInfo in the Application object when they come up, and save their values back to the same PrintInfo.&nbsp; The PrintInfo object is where to go for parameters for the current print job, not the various controls in the panels.</font>

<p><font face="Times">Applications will sometimes want to add extra controls and features to these panels specific to themselves.&nbsp; The controls should be contained in a View that's added to the panel with the <b>setAccessoryView:</b> method.&nbsp; You can define a subclass of the PrintInfo object to store information set by the accessory View and redefine the panel's <b>writePrintInfo</b> method to put it there.&nbsp; To initialize the display in the accessory View with information stored in the PrintInfo object, you can redefine the panel's <b>readPrintInfo</b> method.</font>

<p><font face="Times">When using Interface Builder to create your application's interface, you can easily make use of the Application Kit's printing panels.&nbsp; For the PageLayout panel, you should create a menu item in your Window menu called &quot;Page Layout...&quot;, and have it send a message to either your subclass of Application or a custom object of your own design. This object should then get the PageLayout panel, and run it.&nbsp; For example, if the menu item's action is a <b>doPageLayout:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- doPageLayout:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[[PageLayout new] runModal];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">You'll rarely invoke the PrintPanel in such a direct manner, since it's run by the <b>printPSCode:</b> message.&nbsp; However, you still must determine which View or Window to send the <b>printPSCode:</b> message to when the user chooses the print command.&nbsp; You should put a &quot;Print...&quot; menu item in your main menu.&nbsp; If you have a simple application that always prints the same View or Window, you can set this item's target to be that object, and its action to be <b>printPSCode:</b>.&nbsp; If you have a more advanced application, you may need to send your subclass of Application (or a custom object) a message you invent.&nbsp; For example, you might set the menu item's action to be <b>doPrinting:</b> and implement the following method to print the window containing the active document:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- doPrinting:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[[self mainWindow] printPSCode:sender];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>



<p><br><br><br><br><br><br><br><br><br>

</body>
</html>
