<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/Concepts/Pre3.0_Concepts/10_Support.rtfd -->
<!-- Date: Sun Jun 28 19:38:08 1998 -->
<head>
<title>10_Support</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Release 3.3 Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Helvetica" size="+3"><b>10</b></font></td>

<td><font face="Times" size="+3"><i>Support Objects and Functions</i></font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>This information, although fundamentally correct, has not been updated for release 3.0.&nbsp; For up-to-date information on:</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=143></td>

<td nowrap><font face="Times"><b>Section</b></font></td>

<td><font face="Times"><b>New Documentation</b></font></td></tr>

<tr valign=top>

<td width=143></td>

<td nowrap><font face="Times">Defaults</font></td>

<td><font face="Times">/NextLibrary/Documentation/NextDev/GeneralRef/ApB_Defaults</font></td></tr>

<tr valign=top>

<td width=143></td>

<td nowrap><font face="Times">Exception Handling</font></td>

<td><font face="Times">/NextLibrary/Documentation/NextDev/Concepts/ExceptionHandling.rtf</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>For up-to-date information on the various classes mentioned below (Font, Storage, and so on), see the appropriate section of the <i>NeXTSTEP General Reference</i> manual (available online in /NextLibrary/Documentation/NextDev/GeneralRef).</b></font><br>
<font face="Times">_____________________________________________</font>

<p><br><br><br>

<p><font face="Times">In addition to a program structure for applications that use the NeXT window system and a variety of preprogrammed user-interface objects, the Application Kit offers a number of other program support facilities.&nbsp; Some are implemented as class definitions and some as standard C functions and macros.&nbsp; All are designed to work well with the Kit's program structure and user-interface objects.&nbsp; They include:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A set of functions for writing and reading data to streams.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A set of functions that allow you to save data structures, including objects, in an archive file and load them from the file into an application.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A system for specifying program defaults.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A Pasteboard object that supports cut, copy, and paste operations.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A Font and a FontManager object that help applications get information about a specific font and serve as a vehicle for setting the font in the Window Server.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">List, Storage, and HashTable objects that act as general memory allocators.&nbsp; The StreamTable object is a specialized storage class.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A mechanism for handling errors.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Other Application Kit objects depend on these support facilities.&nbsp; For example, the Text class uses a variety of Font objects and the Pasteboard for cut and paste operations.&nbsp; Program support facilities aren't confined to a behind-the-scenes role, however.&nbsp; You can make direct use of them in your program.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Streams</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">A stream is a sequence of data into or out of a program.&nbsp; It acts as a channel, connecting an application with a source of data or a destination for data.&nbsp; If you use a stream (rather than a file, for example) for the input or output of data, you can read or write data without regard to its source or destination.&nbsp; For example, suppose you designed an object that writes data to a stream.&nbsp; You can save that data in a file, or send it to another process using a Mach port, without changing the object.&nbsp; You only need to call the function that connects a stream to a file or a Mach port and then pass the connected stream to the object.</font>

<p><font face="Times">The Application Kit writes instances of its classes to a special kind of stream, a typed stream.&nbsp; Typed streams are particularly useful for writing and reading objects and other complex data structures.&nbsp; See &quot;Archiving to a Typed Stream&quot; later in this chapter for more information.</font>

<p><font face="Times">When using a stream, you can select memory, a file, or a Mach port as the source or destination by calling the appropriate function to create the stream.&nbsp; You can also implement the functions needed to connect a stream to a different source or destination, such as a Text object, thereby creating your own type of stream.</font>

<p><font face="Times">Memory and file streams allow two-way data flow--that is, you can use the same stream for both writing and reading. In addition, you can set the position of the next input or output operation on these streams.&nbsp; For example, you can read the first few bytes of data from a memory stream, skip to the middle to read some more, and then write data at the end of the stream.</font>

<p><font face="Times">The next section discusses how to write data to and read it from a stream.&nbsp; Then the steps needed to connect the stream to memory, a file, or a Mach port are presented.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Writing and Reading</b></font>

<p><font face="Times">The functions that write to or read from a stream can be grouped into three categories, depending on whether they:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Write or read single characters at a time,</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Write or read a specified number of bytes of data, or</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Convert data according to a format string as it's read or written.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">These functions are modeled after the standard C library functions for input and output.&nbsp; If you are familiar with those standard C functions, you know in a general way what the corresponding NeXT-defined functions do.</font>

<p><font face="Times">The NeXT functions for writing and reading take a pointer to a stream as an argument.&nbsp; These functions can be used with a stream connected to any source or destination.&nbsp; In the examples shown below, this stream has already been connected and is referred to as <b>stream</b>.&nbsp; See the section &quot;Connecting Streams to a Source or Destination&quot; below for details on connecting a stream.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Writing and Reading Characters</b></font>

<p><font face="Times">The macros for writing and reading single characters at a time are similar to the corresponding standard C functions: <b>NXPutc()</b> and <b>NXGetc()</b> work like <b>putc()</b> and <b>getc()</b>.&nbsp; <b>NXPutc()</b> appends a character to the stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXPutc(stream, 'c');</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The second argument specifies the character to be written to the stream.&nbsp; <b>NXGetc()</b> retrieves the next character from the stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned char&nbsp; aCharacter;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">aCharacter = NXGetc(stream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>unsigned char</b> type should be used for portability.</font>

<p><font face="Times">To reread a character, call <b>NXUngetc()</b>.&nbsp; This function puts the last character read back onto the stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned char&nbsp; aCharacter;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXUngetc(stream);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">aCharacter = NXGetc(stream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Note that <b>NXUngetc()</b> doesn't take a character as an argument as <b>ungetc()</b> does.&nbsp; <b>NXUngetc()</b> can only be called once between any two calls to <b>NXGetc()</b> (or any other reading function).</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Writing and Reading Bytes of Data</b></font>

<p><font face="Times">The functions <b>NXWrite()</b> and <b>NXRead()</b> write multiple bytes of data to and read them from a stream.&nbsp; In the following example, an NXRect structure is written to a stream.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; myRect;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSetRect(&amp;myRect, 0.0, 0.0, 100.0, 200.0);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWrite(stream, &amp;myRect, sizeof(NXRect));</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The second and third arguments for <b>NXWrite()</b> give the location and amount of data (measured in bytes) to be written to the stream.&nbsp; To read data from a stream, call <b>NXRead()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; myRect;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRead(stream, &amp;myRect, sizeof(NXRect));</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXRead()</b> reads the number of bytes specified by its third argument from the given stream and places the data in the location specified by the second argument.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Writing and Reading Formatted Data</b></font>

<p><font face="Times">Four functions convert strings of data as they're written to or read from a stream.&nbsp; <b>NXPrintf()</b> and <b>NXScanf()</b> take a character string that specifies the format of the data to be written or read as an argument.&nbsp; <b>NXPrintf()</b> interprets its arguments according to the format string and writes them to the stream.&nbsp; Similarly, <b>NXScanf()</b> reads characters from the stream, interprets them as specified in the format string, and stores them in the locations indicated by the last set of arguments.&nbsp; The conversion characters in the format string for both functions are the same as those used for the standard C library functions, <b>printf()</b> and <b>scanf()</b>.&nbsp; The examples below illustrate the use of some of these conversion characters.&nbsp; For detailed information on these characters and how conversions are performed, see the UNIX manual pages for <b>printf()</b> and <b>scanf()</b>.</font>

<p><font face="Times">The following writes data of the form &quot;Please send 500 bucks before Friday&quot; to a stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; amt = 500;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp; *day = &#34;Friday&#34;;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXPrintf(stream, &#34;Please send %d bucks before %s&#34;, amt, day);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The call</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; numint;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp; numflo;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp;&nbsp; name[15];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXScanf(stream,&#34;%d%f%s&#34;, &amp;numint, &amp;numflo, name);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">with the stream of data</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">5&nbsp; 19.61&nbsp; Jacqueline</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">will assign 5 to the variable <b>numint</b>, 19.61 to <b>numflo</b>, and &quot;Jacqueline&quot; to <b>name</b>.</font>

<p><font face="Times">Two related functions, <b>NXVPrintf ()</b> and <b>NXVScanf()</b>, are exactly the same as <b>NXPrintf()</b> and <b>NXScanf()</b>, respectively, except that instead of being called with a variable number of arguments, they are called with a <b>va_list </b>argument list, which is defined in the header file <b>stdarg.h</b>.&nbsp; This header file also defines a set of macros for advancing through a <b>va_list</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Flushing and Filling</b></font>

<p><font face="Times">File and Mach port streams are buffered, which means that data is initially written to a buffer rather than to the file or the port itself.&nbsp; If you write more data than the buffer can hold, the buffer is flushed, sending all the data to the destination that the stream is connected to.&nbsp; Also, before a stream is disconnected from its destination, the buffer is flushed to ensure that all data actually gets sent to the destination.&nbsp; Usually you won't need to flush the buffer yourself. However, if you don't want to disconnect the stream but your code depends on knowing that all data has been sent to the stream's destination, call <b>NXFlush()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXFlush(stream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If <b>NXFlush()</b> is called with a memory stream, more memory is made available for writing.&nbsp; However, you don't need to call this function with a memory stream since more memory is automatically allocated as needed.</font>

<p><font face="Times">When reading from a file or Mach port stream, data is loaded into a buffer and then read from the buffer.&nbsp; This buffer is automatically filled after you've read all the data in it.&nbsp; To explicitly fill the buffer yourself, call <b>NXFill()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXFill(stream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Calling this function with a memory stream has no effect.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Seeking</b></font>

<p><font face="Times">Stream functions for writing and reading start at the current position of the stream, so you may need to manipulate the position of the stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSeek(stream, 0, NX_FROMSTART);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXSeek()</b> moves forward by the number of bytes specified by its second argument relative to the position indicated by its last argument, which can be NX_FROMSTART, NX_FROMCURRENT, or NX_FROMEND.&nbsp; In the example, the current position is set to the beginning of the stream.&nbsp; The function <b>NXTell()</b> returns an <b>int</b> that specifies the current position in the stream given as its argument.&nbsp; This value, which is measured in bytes from the beginning of the stream, can be used in a call to <b>NXSeek()</b>.</font>

<p><font face="Times">Position within some streams--for example, Mach port streams--is undefined, so these two functions shouldn't be used with such streams.&nbsp; They can be used with memory or file streams, but they should be avoided if the stream will ever be connected to an unseekable source or destination.&nbsp; The NX_CANSEEK flag, defined in the header file <b>streams/streams.h</b>, indicates whether a stream is seekable.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Connecting Streams to a Source or Destination</b></font>

<p><font face="Times">Functions are provided to open a stream on memory, a file, or a Mach port.&nbsp; Opening a stream involves connecting it to a source or destination and specifying whether it will be used for writing or reading (or both).&nbsp; Regardless of what the source and destination are, you can use the functions described above for writing data to and reading it from the stream. When you're finished with the stream, use the appropriate function to close it.&nbsp; The functions for closing a stream disconnect it from its source or destination and release storage used by the stream.&nbsp; (The NXStream structure used below is defined in the header file <b>streams/streams.h</b>.)</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Connecting to Memory</b></font>

<p><font face="Times">A memory stream is a temporary buffer for writing or reading data.&nbsp; To open a memory stream, call <b>NXOpenMemory()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXStream&nbsp; *stream;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">stream = NXOpenMemory(NULL, 0, NX_WRITEONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If NX_WRITEONLY is specified, the first two arguments should be NULL and 0 to allow the amount of memory available to be automatically adjusted as more data is written.&nbsp; If NX_READONLY is specified, a memory stream will be set up for reading the data beginning at the location specified by the first argument.&nbsp; The second argument indicates how much data will be read.&nbsp; To use the stream for both writing and reading, you can either use NULL and 0 or specify the location and amount of data to be read.</font>

<p><font face="Times">When you're finished with a memory stream, close it by calling <b>NXCloseMemory()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXCloseMemory(stream, NX_FREEBUFFER);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Usually, you'll use NX_FREEBUFFER as the second argument to free all storage used by the stream, but there are two other constants that can be used.&nbsp; If you've used the stream for writing, more memory may have been made available than was actually used; the constant NX_TRUNCATEBUFFER indicates that any unused pages of memory should be freed.&nbsp; (Calling <b>NXClose()</b> with a memory stream is equivalent to calling <b>NXCloseMemory()</b> and specifying NX_TRUNCATEBUFFER.)&nbsp; NX_SAVEBUFFER doesn't free the memory that had been made available.</font>

<p><font face="Times">Before you close a memory stream, you can save data written to the stream in a file.&nbsp; To do this, call <b>NXSaveToFile()</b>, giving it the stream and a pathname as arguments:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">const char&nbsp; *home = NXHomeDirectory();</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSaveToFile(stream, home);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXSaveToFile()</b> writes the contents of the memory stream into the file, creating it if necessary.&nbsp; After saving the data, close the stream using <b>NXCloseMemory()</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Connecting to a File</b></font>

<p><font face="Times">Two functions are available to connect a stream to a file.&nbsp; <b>NXMapFile()</b> maps a file into memory and then opens a memory stream; <b>NXOpenFile()</b> connects a stream to the file.&nbsp; Memory mapping allows efficient random and multiple access of the data in the file, so <b>NXMapFile()</b> should be used whenever the file is stored on disk.&nbsp; (The <i>NeXT Operating System Software</i> manual discusses memory mapping in more detail.)&nbsp; If you want to connect a stream to a pipe or a socket, use <b>NXOpenFile()</b>.&nbsp; This function takes a file descriptor as an argument.</font>

<p><font face="Times">To map a file into memory, call <b>NXMapFile()</b>, giving it the pathname for the file and indicating whether you'll be writing, reading, or both:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXStream&nbsp; *stream;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">stream = NXMapFile(&#34;aPathname&#34;, NX_READONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This function opens a memory stream and initializes it with the contents of the file.&nbsp; Then you can use the functions described above for writing and reading.&nbsp; If you use the stream only for reading, just close the memory stream when you're finished.&nbsp; If you write to the stream, you need to explicitly save the data written before closing:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSaveToFile(stream, &#34;aPathname&#34;);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXCloseMemory(stream, NX_FREEBUFFER);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To open a file stream using a file descriptor, call <b>NXOpenFile()</b>, giving it the descriptor and specifying how the stream will be used:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXStream&nbsp; *stream;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">stream = NXOpenFile(fd, NX_WRITEONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If the file descriptor was obtained through the system call <b>open()</b>, one of three flags (0_WRONLY, 0_RDONLY, or 0_RDWR) was used to open the file for writing, reading, or both.&nbsp; The meaning of this flag must match that used in the call to <b>NXOpenFile()</b>.&nbsp; See the UNIX manual page on <b>open()</b> for more information about its arguments.</font>

<p><font face="Times">You can use <b>NXOpenFile()</b> to connect to <b>stdin</b>, <b>stdout</b>, and <b>stderr</b> by obtaining their file descriptors using the standard C library function <b>fileno()</b>.&nbsp; (For more information on this function, see its UNIX manual page.)&nbsp; The following example allows you to read from <b>stdin</b>.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileDescriptor;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXStream&nbsp; *stream;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">fileDescriptor = fileno(stdin);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">stream = NXOpenFile(fileDescriptor, NX_READONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">After you've finished with the file stream, you need to disconnect it from the file and free the storage used by the stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXClose(stream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXClose()</b> saves any data you wrote to the stream in the file, but it doesn't release the file descriptor.&nbsp; To release the descriptor, use the system call <b>close()</b>, giving it the descriptor as an argument.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Connecting to a Mach Port</b></font>

<p><font face="Times">In Mach, tasks and threads communicate among themselves and with the operating system kernel by sending messages.&nbsp; These messages must adhere to a certain structure.&nbsp; They're sent to a Mach port using the Mach function <b>msg_send()</b>, where they're queued until read by the receiver using <b>msg_receive()</b>.&nbsp; Rather than setting up this message structure yourself, you can connect a stream to a Mach port using <b>NXOpenPort()</b>.&nbsp; Then when you use <b>NXWrite()</b> or <b>NXRead()</b> (depending on whether you are sending or receiving data), the data you send or receive will be sent to or dequeued from the port you specify.&nbsp; Mach ports and messages are described in more detail in the <i>NeXT Operating System Software</i> manual.</font>

<p><font face="Times">Mach port streams can't be opened for both writing and reading, so you need to connect one stream to a port to send data and another stream to the same port to read that data.&nbsp; The following paragraphs show how to set up such a pair of streams.</font>

<p><font face="Times">To send data to a Mach port, first open a stream using <b>NXOpenPort()</b>.&nbsp; A port must be previously allocated using the Mach function <b>port_allocate()</b>; see the <i>NeXT Operating System Software</i> manual for more information about using this function.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp; thePort;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXStream&nbsp; *outStream;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">outStream = NXOpenPort(thePort, NX_WRITEONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Since this is the sender's stream, it's opened for writing.&nbsp; Now, using any of the functions for writing described above, write to the opened stream the data you want to send to the port.&nbsp; You should close the stream after you finish writing to it:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXClose(outStream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This ensures that all data is actually sent to the port by flushing the buffer associated with the stream.&nbsp; If you want to keep the stream open, you can flush the buffer using <b>NXFlush()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXFlush(outStream);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">To read this data, the receiver opens a stream on the same port for reading.&nbsp; This can be done independently of when the sender's stream was opened and when the data was sent.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp; thePort;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXStream&nbsp; *inStream;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">inStream = NXOpenPort(thePort, NX_READONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The functions for reading data will wait until it's available and then read it into the specified location.&nbsp; After the data has been read, the stream can be closed:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXClose(inStream);</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Archiving to a Typed Stream</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><i>Archiving</i> is the process of preserving a data structure, especially an object, for later use.&nbsp; An archived data structure is usually stored in a file, but it can also be written to memory, copied to the pasteboard, or sent to another application. Archiving involves writing data to a special kind of data stream, called a <i>typed stream</i>.&nbsp; During unarchiving, memory is allocated for the data structure, and it's initialized with values read from a typed stream.</font>

<p><font face="Times">Typed streams are an abstraction built on the streams abstraction discussed earlier in this chapter.&nbsp; Because of this relationship, data can be written to and read from a typed stream without regard to what destination or source the stream is connected to.&nbsp; Once you've written the code to archive a data structure, you can use that code to store the data structure in a file, write it to memory, or send it to a Mach port.</font>

<p><font face="Times">Typed streams are used for archiving because they provide some protection against future changes that might affect the ability to unarchive a data structure.&nbsp; When a typed stream is used, the data type is archived along with the data and, in the case of objects, the object's class hierarchy and version are also archived.&nbsp; This additional information is checked when a data structure is unarchived, and an exception is raised if necessary.&nbsp; Typed streams also provide some degree of data portability between machines.</font>

<p><font face="Times">The archiving functions make it easy to write structures consisting of several different data types, including objects. Archiving with a typed stream also ensures that objects are written only once even if several members of a data structure refer to the same object.&nbsp; In addition, when archiving an object, you can limit the scope of what's archived by deciding which objects referred to by <b>id</b> instance variables should be archived.&nbsp; Classes defined in the Application Kit and the common classes archive themselves using typed streams.&nbsp; If you include instances of these classes (or subclasses) in a data structure, you'll want to archive it using typed streams.</font>

<p><font face="Times">All functions mentioned in this section are described in the <i>NeXTstep Reference</i> manuals.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Archiving a Data Structure</b></font>

<p><font face="Times">To write data to a typed stream, you use any of several functions.&nbsp; Two of these, <b>NXWriteType()</b> and <b>NXWriteTypes()</b>, allow you to specify the data type or types being written.&nbsp; Other functions write a specific data type; for example, <b>NXWritePoint()</b> writes an NXPoint structure.&nbsp; The archiving functions are listed below and discussed in the following sections.&nbsp; The functions for unarchiving are similar to these, and they're listed and described later.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Function</b></font></td>

<td><font face="Helvetica"><b>Data Type</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteType()</font></td>

<td><font face="Times">Single specified type</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteTypes()</font></td>

<td><img src="../../Images/sp.gif" width=101 height=1><font face="Times">Multiple specified types</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteArray()</font></td>

<td><font face="Times">An array</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWritePoint()</font></td>

<td><font face="Times">An NXPoint structure</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteSize()</font></td>

<td><font face="Times">An NXSize structure</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteRect()</font></td>

<td><font face="Times">An NXRect structure</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteObject()</font></td>

<td><font face="Times">An <b>id</b></font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXWriteObjectReference()</font></td>

<td><font face="Times">An <b>id</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All these functions take a pointer to a typed stream as their first argument.&nbsp; Since you can write to a typed stream without knowing what it's connected to, opening a typed stream and writing to it are described separately.&nbsp; The &quot;Opening and Closing a Typed Stream&quot; section below explains how to obtain a typed stream pointer.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Archiving Arbitrary Data</b></font>

<p><font face="Times"><b>NXWriteType()</b> and <b>NXWriteTypes()</b> write strings of data to a typed stream.&nbsp; (These functions are similar to the <b>printf()</b> standard C function, which is described in its UNIX manual page.)&nbsp; They take a pointer to a typed stream, a character string indicating the format of the data to be read or written, and the address of the data as arguments.&nbsp; The format string characters and their corresponding data types are listed below.&nbsp; They're described in more detail in <i>NeXTstep Reference, Volume 2</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Format Character</b></font></td>

<td><font face="Helvetica"><b>Data Type</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">c</font></td>

<td><font face="Times">char</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">s</font></td>

<td><font face="Times">short</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">i</font></td>

<td><font face="Times">int</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">f</font></td>

<td><font face="Times">float</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">d</font></td>

<td><font face="Times">double</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">@</font></td>

<td><font face="Times">id</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">*</font></td>

<td><font face="Times">char *</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">%</font></td>

<td><font face="Times">NXAtom</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">:</font></td>

<td><font face="Times">SEL</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">#</font></td>

<td><font face="Times">class</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">!</font></td>

<td><font face="Times">int; corresponding data won't be read or written</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">{<i>type</i>}</font></td>

<td><font face="Times">struct</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">[<i>count type</i>]</font></td>

<td><font face="Times">array</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXWriteType()</b> writes data as the single data type specified by its format string.&nbsp; <b>NXWriteTypes()</b> writes multiple types of data.&nbsp; The types are listed in the format string using the appropriate format characters shown above, and pointers to matching data are listed as the last arguments.&nbsp; This example shows three different data types being written to a typed stream:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp;&nbsp; aFloat = 3.0;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp; anInt = 5;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp;&nbsp; *aCharStar = &#34;foo&#34;;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteTypes(typedStream, &#34;fi*&#34;, &amp;aFloat, &amp;anInt, &amp;aCharStar);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If <b>NXWriteType()</b> had been used, three lines of code would have been necessary, one for each data type.&nbsp; Both functions take pointers to the data to be written, unlike <b>printf()</b>; this implementation results in the corresponding archiving and unarchiving functions taking the same arguments.</font>

<p><font face="Times">Both functions are particularly useful for writing structures consisting of several kinds of data.&nbsp; For example, this structure</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">float&nbsp; aFloat;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; anInt;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp; *aCharStar;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} MyStruct;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">would be written as follows:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteType(typedStream, &#34;{fi*}&#34;, &amp;MyStruct);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Both <b>NXWriteType()</b> and <b>NXWriteTypes()</b> write objects if the &quot;@&quot; format character is used, which is equivalent to calling <b>NXWriteObject()</b>.&nbsp; The section &quot;Archiving Objects&quot; below explains the issues involved in writing objects and the different ways of archiving them.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Archiving Arrays and NXPoint, NXSize, and NXRect Structures</b></font>

<p><font face="Times">For convenience, several functions are provided to archive specific kinds of data structures.&nbsp; These structures can all be written using <b>NXWriteType()</b> or <b>NXWriteTypes()</b>, but it's easier to use the specialized functions.</font>

<p><font face="Times"><b>NXWriteArray()</b> writes an array to the typed stream passed as its first argument.&nbsp; You specify the number of elements in the array and their type.&nbsp; The following is an example of an integer array being written.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp; myArray[4];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myArray [0] = 0; myArray [1] = 11;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myArray [2] = 22; myArray [3] = 33;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteArray(typedStream, &#34;i&#34;, 4, myArray);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Note that <b>NXWriteArray()</b> takes an array, not a pointer to an array, as an argument.</font>

<p><font face="Times"><b>NXWritePoint()</b>, <b>NXWriteSize()</b>, and <b>NXWriteRect()</b> work through <b>NXReadType()</b> to write NXPoint, NXSize, or NXRect structures to a typed stream.&nbsp; The following example shows these three data structures being archived.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXPoint&nbsp; zeroPoint = {0.0, 0.0};</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSize&nbsp;&nbsp; rectSize = {100.0, 200.0};</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp;&nbsp; aRect = {zeroPoint, rectSize};</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWritePoint(typedStream, &amp;zeroPoint);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteSize(typedStream, &amp;rectSize);</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteRect(typedStream, &amp;aRect);</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Archiving Objects</b></font>

<p><font face="Times">Archiving an object begins with a call to either <b>NXWriteRootObject()</b> or <b>NXWriteObject()</b>.&nbsp; These functions take a pointer to a typed stream and an object's <b>id</b> as arguments.&nbsp; They send the object a <b>write:</b> message, passing it the typed stream.&nbsp; The <b>write:</b> method contains the code that writes the values of the object's instance variables to the typed stream.&nbsp; (Note that <b>NXWriteObject()</b> is equivalent to using <b>NXWriteType()</b> or <b>NXWriteTypes()</b> and specifying &quot;@&quot; in the format string; in the following discussion, <b>NXWriteObject()</b> will be used as a proxy for all these equivalent methods of writing objects.)</font>

<p><font face="Times"><b>NXWriteRootObject()</b> and <b>NXWriteObject()</b> differ in how they expect the object's <b>write:</b> method to handle its <b>id </b>instance variables.&nbsp; <b>NXWriteObject()</b> expects to be able to archive every object referred to by <b>id</b> instance variables, as well as objects referred to by those objects, and so on.&nbsp; <b>NXWriteRootObject()</b> allows you to limit the scope of what's archived by letting some <b>id</b> instance variables point to <b>nil</b> when they're unarchived.&nbsp; The next sections describe how to set up a <b>write:</b> method and when to use these two functions.</font>

<p><font face="Times">A third function, <b>NXWriteRootObjectToBuffer()</b>, also begins the process of archiving a given object.&nbsp; This function doesn't take a typed stream as an argument.&nbsp; Instead, it opens a typed stream on memory, writes the object to it, and returns a pointer to the memory buffer.&nbsp; This function is discussed in more detail below under &quot;Opening and Closing a Typed Stream.&quot;</font>

<p><br><br>

<p><font face="Helvetica"><b>The write: Method</b></font>

<p><font face="Times">Any Application Kit class or Common Class that declares instance variables already has a <b>write:</b> method that archives those instance variables.&nbsp; You need to supply a <b>write:</b> method for any class you create that adds instance variables. However, not every single instance variable needs to be archived.&nbsp; If an instance variable can be initialized by using the values of other instance variables, you don't need to archive its value.</font>

<p><font face="Times">Note that <b>write:</b> messages shouldn't be sent directly to objects.&nbsp; They should only be generated by the functions <b>NXWriteRootObject()</b> and <b>NXWriteObject()</b>.</font>

<p><font face="Times">Every <b>write:</b> method should begin with a message to <b>super</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- write:typedStream {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[super write:typedStream];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .&nbsp; /* code for writing instance variables declared in this</font><br>
<img src="../../Images/sp.gif" width=222 height=1><font face="Courier" size="-1">class */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This ensures that the object's class hierarchy and its inherited instance variables are archived.&nbsp; The body of the <b>write: </b>method uses the appropriate functions to archive the instance variables declared in that class.&nbsp; You can use any of the functions listed above in the &quot;Archiving a Data Structure&quot; section.&nbsp; If the object being archived has <b>id</b> instance variables, they're archived as described below.</font>

<p><br><br>

<p><font face="Helvetica"><b>Archiving id Instance Variables</b></font>

<p><font face="Times">An object's <b>id</b> instance variables can be archived in one of two ways, depending on whether the object referred to by the instance variable is an intrinsic part of the object being archived.&nbsp; If it is intrinsic, use <b>NXWriteObject()</b>, <b>NXWriteType()</b>, or <b>NXWriteTypes()</b>, which are all equivalent.&nbsp; If it's not intrinsic, use <b>NXWriteObjectReference()</b>.&nbsp; The following paragraphs explain the differences among these functions.</font>

<p><font face="Times">An object's <b>id</b> instance variables may contain inherent properties of the object to which they belong, or they might be necessary for the object to be usable.&nbsp; For example, a View's subview list is an intrinsic part of that View, just as a ButtonCell is needed for a Button to work properly.&nbsp; These kinds of instance variables are archived using <b>NXWriteObject()</b>.&nbsp; The following shows part of a View's <b>write:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- write:(NXTypedStream *) typedStream {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[super write:typedStream];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXWriteObject(typedStream, subviews);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .&nbsp; /* code for writing other instance variables */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">If you design a subclass of View that defines instance variables, you'll need to create a <b>write:</b> method that archives those instance variables.&nbsp; Since your method will begin with a message to <b>super</b>, the subviews list will be archived along with the View.&nbsp; Button objects don't define instance variables, so they inherit Control's <b>write:</b> method, which archives the <b>cell</b> instance variable.</font>

<p><font face="Times">In some cases, an object's <b>id</b> instance variables refer to other objects that act at the discretion of the object, such as its target or delegate, or that aren't inherently part of the object.&nbsp; A View's <b>superview</b> and <b>window</b> instance variables aren't considered intrinsic to the View since you might want to hook up the View to another superview or to a different Window.&nbsp; These kinds of instance variables are archived using <b>NXWriteObjectReference()</b>.</font>

<p><font face="Times"><b>NXWriteObjectReference()</b> specifies that a pointer to <b>nil</b> should be written for the <b>id</b> passed in unless that object is an intrinsic part of some member of the data structure being archived.&nbsp; If the object is intrinsic, it will be archived and the pointer will point to the archived object.</font>

<p><br><br>

<p><font face="Helvetica"><b>Archiving an Object with id Instance Variables</b></font>

<p><font face="Times">When an object that includes any calls to <b>NXWriteObjectReference()</b> is archived, <b>NXWriteRootObject()</b> must be used to archive the object instead of <b>NXWriteObject()</b>.&nbsp; If the object being archived is based on the Application Kit, <b>NXWriteRootObject()</b> should be used since several Application Kit classes use <b>NXWriteObjectReference()</b>.&nbsp; Using <b>NXWriteRootObject()</b> will always give the desired result whether <b>NXWriteObjectReference()</b> is called or not. However, <b>NXWriteObject()</b> will raise an exception if used to archive an object that calls <b>NXWriteObjectReference()</b>.</font>

<p><font face="Times"><b>NXWriteRootObject()</b> makes two passes through the data structure being written.&nbsp; The first time, it defines the limits of the data to be written by including instance variables intrinsic to the data structure and by making a note of which instance variables are written with <b>NXWriteObjectReference()</b>.&nbsp; On the second pass, <b>NXWriteRootObject() </b>archives the data structure.&nbsp; Because of this two-pass implementation, <b>write:</b> methods are performed twice; therefore, <b>write:</b> methods shouldn't contain any code that has side effects.</font>

<p><font face="Times">As an example, consider a View that has a Button as one subview and a TextField, which is the target of the Button, as another subview.&nbsp; If you archive the Button, its ButtonCell will be written.&nbsp; The archived ButtonCell's <b>target</b> instance variable will point to <b>nil</b>.&nbsp; If you archive the View, however, the Button and the TextField will be archived since they're subviews.&nbsp; The ButtonCell will be archived since it's needed by the Button.&nbsp; The ButtonCell's <b>target</b> instance variable will point to the TextField since it's an intrinsic part of the View.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Unarchiving a Data Structure</b></font>

<p><font face="Times">The functions for unarchiving data are similar to the functions for writing:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Function</b></font></td>

<td><font face="Helvetica"><b>Data Type</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadType()</font></td>

<td><font face="Times">Single specified type</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadTypes()</font></td>

<td><font face="Times">Multiple specified types</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadArray()</font></td>

<td><font face="Times">An array</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadPoint()</font></td>

<td><font face="Times">An NXPoint structure</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadSize()</font></td>

<td><font face="Times">An NXSize structure</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadRect()</font></td>

<td><font face="Times">An NXRect structure</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXReadObject()</font></td>

<td><img src="../../Images/sp.gif" width=101 height=1><font face="Times">An <b>id</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">With the exception of <b>NXReadObject()</b>, these functions take the same arguments as their counterparts for archiving. Rather than writing the data pointed to by the arguments, however, the unarchiving functions read data from the typed stream into locations specified by the function's arguments.&nbsp; <b>NXReadObject()</b> takes only a typed stream as an argument and returns the unarchived object's <b>id</b>.&nbsp; The section &quot;Unarchiving Objects&quot; below contains more information about reading an object from a typed stream and initializing it.</font>

<p><font face="Times">In the following example, a <b>float</b>, an <b>int</b>, and a <b>char</b> * are read from a typed stream and stored in the locations specified by the last three arguments to <b>NXReadTypes()</b>.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp; aFloat;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; anInt;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp; *aCharStar;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXReadTypes(typedStream, &#34;fi*&#34;, &amp;aFloat, &amp;anInt, &amp;aCharStar);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All the functions for reading check the type of data on the stream and raise an exception if the type isn't what's expected.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Unarchiving Objects</b></font>

<p><font face="Times">Unarchiving an object from a typed stream is initiated by a call to <b>NXReadObject()</b>.&nbsp; Because an object's class hierarchy is archived with the object, <b>NXReadObject()</b> can determine the object's class and allocate enough memory for a new instance of that class.&nbsp; It then initializes the object's instance variables by sending it a <b>read:</b> message, which reads values for the instance variables from the typed stream.</font>

<p><br><br>

<p><font face="Helvetica"><b>The read: Method</b></font>

<p><font face="Times"><b>read:</b> methods have already been defined for all Application Kit classes and common classes that declare instance variables.&nbsp; You need to supply a <b>read:</b> method for any class you create that adds instance variables.&nbsp; As with <b>write: </b>methods, <b>read:</b> messages shouldn't be sent directly to objects.&nbsp; They should only be generated by <b>NXReadObject()</b>.</font>

<p><font face="Times">Every <b>read:</b> method should begin with a message to <b>super</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- read:typedStream {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[super read:typedStream];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .&nbsp; /* code for reading instance variables declared in this</font><br>
<img src="../../Images/sp.gif" width=222 height=1><font face="Courier" size="-1">class */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This ensures that the object's inherited instance variables are unarchived.&nbsp; The body of the <b>read:</b> method uses the appropriate functions to unarchive the instance variables declared in that class, in the order in which they were archived in the <b>write:</b> method.&nbsp; Any of the functions listed above in the &quot;Unarchiving a Data Structure&quot; section can be used to read values for instance variables.</font>

<p><font face="Times">Unarchived <b>id</b> instance variables are initialized to point either to an object or to <b>nil</b>, depending on whether the referenced object was archived.&nbsp; If <b>NXWriteObjectReference()</b> was used for the <b>id</b> instance variable and if the referenced object isn't an intrinsic part of any member of the structure that was archived, then the instance variable will point to <b>nil</b>.&nbsp; Otherwise, it'll point to the object.&nbsp; See &quot;Archiving Objects&quot; earlier for more information.</font>

<p><font face="Times">Values for other instance variables may not have been archived because they can be derived from others.&nbsp; Values for these instance variables should be computed in the <b>read:</b> method.&nbsp; Other initialization needed can be performed as described in the next section.</font>

<p><font face="Times">If you create a class, archive an instance of it, and later create a new version of that class (for example, you decide to add an instance variable), you can set up your <b>read:</b> method to read both versions.&nbsp; When a class is created, its version should be set using Object's <b>setVersion:</b> method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">@implementation MyClass:MySuperClass</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">+ initialize</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[MyClass setVersion:MYCLASS_CURRENT_VERSION];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>read:</b> method for this class can then check the version being unarchived by using <b>NXTypedStreamClassVersion()</b> and, if necessary, use different code for reading an old version:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- read:(NXTypedStream *)typedStream</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[super read:typedStream];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (NYTypedStreamClassVersion(typedStream, &#34;MyClass&#34;) ==</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[MyClass version] {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* read code for current version */</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* read code for old version */</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>Initializing an Object</b></font>

<p><font face="Times">Immediately after an object has been read from a typed stream, <b>NXReadObject()</b> sends it an <b>awake</b> message.&nbsp; This gives the object a chance to perform initialization tasks that can't be done in the <b>read:</b> method--that is, those tasks that require the entire object to be unarchived and in a usable state.&nbsp; For example, Window's <b>awake</b> method has the Window Server redisplay the window and assign it a window number.&nbsp; If you override any of the Application Kit's <b>awake</b> methods, your version should begin by sending an <b>awake</b> message to <b>super</b>.</font>

<p><font face="Times">After sending an <b>awake</b> message, <b>NXWriteObject()</b> sends the object a <b>finishUnarchiving</b> message.&nbsp; The purpose of this method is to allow you to replace the just-unarchived object with another one.&nbsp; If you implement a <b>finishUnarchiving</b> method, it should free the unarchived object and return the replacement object.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Opening and Closing a Typed Stream</b></font>

<p><font face="Times">The functions for archiving and unarchiving take an already opened typed stream as an argument.&nbsp; You can use one of three functions to open a typed stream, depending on whether you're archiving to or unarchiving from a file, memory, or some other destination or source:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXOpenTypedStreamForFile()</b> returns a pointer to a typed stream opened on a specified file.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXWriteRootObjectToBuffer()</b> opens a typed stream on memory and writes the given object to it using <b>NXWriteRootObject()</b>.&nbsp; The corresponding function for unarchiving, <b>NXReadObjectFromBuffer()</b>, opens a memory stream and reads an object from it.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>NXOpenTypedStream()</b> takes an already opened NXStream structure as an argument and returns a pointer to a typed stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Regardless of what the typed stream is opened on, the same archiving code (or unarchiving code) can be used for a given data structure.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>A Typed Stream on a File</b></font>

<p><font face="Times"><b>NXOpenTypedStreamForFile()</b>'s two arguments are the pathname of a file and a constant that indicates whether you'll be archiving or unarchiving:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXTypedStream&nbsp; *typedStream;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedStream = NXOpenTypedStreamForFile(&#34;yourPathname&#34;, NX_WRITEONLY);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">This function returns a pointer to a typed stream on memory and makes note of the fact that the stream is associated with a file.&nbsp; If you open the stream for archiving--by specifying NX_WRITEONLY--you can use any of the functions described above in &quot;Archiving a Data Structure.&quot;&nbsp; When you've finished, call <b>NXCloseTypedStream()</b>.&nbsp; This function saves the contents of the typed stream in the file, creating it if necessary, and closes the stream.</font>

<p><font face="Times">If NX_READONLY is specified, the typed stream is initialized with the contents of the file specified.&nbsp; You unarchive data by using any of the functions described above in &quot;Unarchiving a Data Structure.&quot;&nbsp; Then call <b>NXCloseTypedStream()</b> to close the typed stream.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>A Typed Stream on Memory</b></font>

<p><font face="Times"><b>NXWriteRootObjectToBuffer()</b> and <b>NXReadObjectFromBuffer()</b> both open a stream on memory.&nbsp; They're particularly useful for archiving an object, writing it to the pasteboard, and then unarchiving it from the pasteboard.&nbsp; See &quot;The Pasteboard&quot; later in this chapter for an example of using these functions in conjunction with the pasteboard.</font>

<p><font face="Times"><b>NXWriteRootObjectToBuffer()</b> opens a memory stream, writes the object given as its argument by calling <b>NXWriteRootObject()</b>, and then closes the stream.&nbsp; It returns the size of the object written, in the location specified by the second argument, and a pointer to the memory buffer.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp; *data;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; length;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">data = NXWriteRootObjectToBuffer(anId, &amp;length);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXReadObjectFromBuffer()</b>'s two arguments should be taken from a previous call to <b>NXWriteRootObjectToBuffer()</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; someId;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">someId = NXReadObjectFromBuffer(data, length);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXReadObjectFromBuffer()</b> calls <b>NXReadObject()</b> to read the object and then closes the typed stream and returns the object's <b>id</b>.</font>

<p><font face="Times">When you finish with the memory buffer, after a call to either <b>NXWriteRootObjectToBuffer()</b> or <b>NXReadObjectFromBuffer()</b>, free the buffer by calling <b>NXFreeObjectBuffer()</b>.&nbsp; This function takes the same arguments as <b>NXReadObjectFromBuffer()</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Using an NXStream Structure</b></font>

<p><font face="Times">In addition to the functions described above for opening a typed stream on file or memory, you can open a typed stream by passing <b>NXOpenTypedStream()</b> a pointer to an NXStream structure.&nbsp; NXStream structures can be opened on Mach ports, memory, files, or even objects.&nbsp; To obtain an NXStream pointer, use the functions described in &quot;Streams&quot; earlier in this chapter.</font>

<p><font face="Times"><b>NXOpenTypedStream()</b>'s second argument should be NX_READONLY or NX_WRITEONLY to specify whether you'll be archiving or unarchiving.&nbsp; This constant should be the same as that used to open the NXStream structure. When you finish archiving or unarchiving, you need to close the NXStream structure and the typed stream.&nbsp; The section on &quot;Streams&quot; describes how to close NXStream structures.&nbsp; Use <b>NXCloseTypedStream()</b> to close the typed stream.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>The Defaults System</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Through the defaults system, you can allow users to customize your application to match their preferences.&nbsp; For example, you can let users express a preference for where the main menu of your application should come up the next time it's launched.&nbsp; This preference will override the default location of the main menu that users can set with the Preferences application.&nbsp; An application records such preferences by assigning default values to a set of parameters. Each user has a defaults database named <b>.NextDefaults</b>, which resides in the <b>.NeXT</b> subdirectory in the user's home directory, for storing these default values.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=34></td>

<td nowrap><font face="Helvetica"><b>Warning:</b></font></td>

<td><font face="Times">The <b>.NeXTDefaults</b> file should never be accessed directly.&nbsp; Values in it can be read and written using the functions and commands described in this section.</font></td></tr>

<tr valign=top>

<td width=34 height=10></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Times">Since the defaults database is a system resource, it isn't owned by any single application.&nbsp; In fact, any application can store values for parameters or get values stored by another application.&nbsp; For example, the ChoosePrinter panel writes to the defaults database to store the name of the printer selected by the user.&nbsp; Another application may want to obtain this printer specification from the database.&nbsp; Applications can use the functions discussed below to read values from and write them to the database.&nbsp; These functions are described in detail in <i>NeXTstep Reference, Volume 2</i>.</font></td></tr>

<tr valign=top>

<td width=34 height=50></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Helvetica" size="+1"><b>Creating a Registration Table</b></font></td></tr>

<tr valign=top>

<td width=34 height=10></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Times">The registration table allows an application to efficiently read default values for a set of parameters without having to open and close the <b>.NextDefaults</b> database to obtain each value.&nbsp; The table consists of a list of pairs; each pair is composed of a parameter name and a corresponding default value.&nbsp; The registration table is created at run time by opening the database once to read default values for the parameters the application will use.&nbsp; Every application should create its registration table early in the program, before any default values are needed.</font></td></tr>

<tr valign=top>

<td width=34 height=10></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Times">To create this table, call <b>NXRegisterDefaults()</b> and give it two arguments:&nbsp; a character string specifying the name of an application, or owner, and an NXDefaultsVector structure.&nbsp; Like the registration table, this structure consists of a list of pairs of parameter names and default values.&nbsp; (It's defined in the header file <b>appkit/defaults.h</b>.)</font></td></tr>

<tr valign=top>

<td width=34 height=10></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Times">The NXDefaultsVector structure serves two purposes.&nbsp; First, it provides a complete list of all parameters that the application will use.&nbsp; Values for all the parameters specified are placed in the registration table at once, so the database doesn't need to be opened and closed for subsequent uses of the parameters.&nbsp; (However, if the application later asks for values for parameters that aren't registered, the database will be opened, read, and closed again.)&nbsp; Second, the structure allows the programmer to suggest values for the parameters.&nbsp; These values are used if the user hasn't stated a preference for a specific value.</font></td></tr>

<tr valign=top>

<td width=34 height=10></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Times">A good place to call <b>NXRegisterDefaults()</b> is in the <b>initialize</b> method of the class that will use the parameters.&nbsp; The following example registers the values in <b>WriteNowDefaults</b> for the owner <b>WriteNow</b>:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">+ initialize</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">static NXDefaultsVector WriteNowDefaults = {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">{&#34;NXFont&#34;, &#34;Helvetica&#34;},</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">{&#34;NXFontSize&#34;, &#34;12.0&#34;},</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">{NULL}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRegisterDefaults(&#34;WriteNow&#34;, WriteNowDefaults);</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXRegisterDefaults()</b> creates a registration table that contains a value for each of the parameters listed in the NXDefaultsVector structure.&nbsp; (Note that NULL is used to signal the end of the NXDefaultsVector structure.)&nbsp; This value will be the one listed in the structure if there's no value for that parameter in the database, as described below.</font>

<p><font face="Times">A user's database may contain values for parameters stored multiple times, each with a different owner.&nbsp; For example, the NXFont parameter can have the value Ohlfs with a GLOBAL owner, Times for the owner WriteNow, and Courier for the owner Mail.&nbsp; When searching a user's database for the parameters listed in the NXDefaultsVector structure, <b>NXRegisterDefaults()</b> ignores values owned by an application different from the one used as its argument.&nbsp; If it finds a parameter and owner that matches those passed to it as arguments, the corresponding value from the user's database rather than the value from the NXDefaultsVector structure is placed in the registration table.&nbsp; If no parameter-owner match is found, <b>NXRegisterDefaults()</b> searches the database's global parameters--that is, those owned by GLOBAL--for a match, and, if it finds one, places the corresponding value in the registration table.&nbsp; (Global parameters are discussed in a later section.)&nbsp; If a parameter isn't found in the user's database, the parameter-value pair listed in the NXDefaultsVector structure is placed in the registration table.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">When creating their own parameters, applications should use the full market name of their product as the owner of the parameter to avoid colliding with already existing parameters.&nbsp; Noncommercial applications might use the name of the program and the author or institution.</font>

<p><font face="Times">If the application was launched from the command line, any parameter values specified there will be used, overriding values listed in the database and the NXDefaultsVector structure.&nbsp; See &quot;The Command Line&quot; below for more information.</font>

<p><font face="Times">To summarize, this is the precedence ordering used to obtain a value for a given parameter for the registration table:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">1.</font></td>

<td><font face="Times">The command line</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">2.</font></td>

<td><font face="Times">The defaults database, with a matching owner</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">3.</font></td>

<td><font face="Times">The defaults database, with the owner listed as GLOBAL</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times">4.</font></td>

<td><font face="Times">The NXDefaultsVector structure passed to <b>NXRegisterDefaults()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Reading Default Values</b></font>

<p><font face="Times">To get a value for a parameter, you typically call <b>NXGetDefaultValue()</b>.&nbsp; This function takes an owner and a parameter as arguments, as shown below, and returns a <b>char</b> pointer to the default value for that parameter.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp; *myDefaultFont;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myDefaultFont = NXGetDefaultValue(&#34;WriteNow&#34;, &#34;NXFont&#34;);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXRegisterDefaults()</b> should already have been called, so <b>NXGetDefaultValue()</b> first looks in the registration table, where usually it will find a matching parameter and value.&nbsp; If <b>NXGetDefaultValue()</b> doesn't find a match in the registration table (which would only be the case if you hadn't listed all parameters when you called <b>NXRegisterDefaults()</b>), it searches the <b>.NextDefaults</b> database for the owner and parameter.&nbsp; If still no match is found, it searches for a matching global parameter, first in the registration table and then in the database.&nbsp; If the value is found in the database rather than the table, <b>NXRegisterDefaults()</b> registers that value for subsequent use.</font>

<p><font face="Times">Occasionally, you may want to search only the database for a default value and ignore the command line and the registration table.&nbsp; For example, you might want a value that another application may have changed after the table was created.&nbsp; In these rare cases, call <b>NXReadDefault()</b>, which takes an owner and the parameter as arguments and looks in the database for an exact match.&nbsp; It doesn't look for a global parameter unless GLOBAL is specified as the owner. If a match is found, a <b>char</b> pointer to the default value is returned; if no value is found, NULL is returned.</font>

<p><font face="Times">After obtaining a value from the database with <b>NXReadDefault()</b>, you may want to write it into the registration table with <b>NXSetDefault()</b>, which is described below.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Writing Default Values</b></font>

<p><font face="Times">If you have allowed a user to customize an application, you probably want to write new values into the user's <b>.NextDefaults</b> database to store these preferences.&nbsp; You probably also want to put the values in the registration table for efficient access by <b>NXGetDefaultValue()</b>.&nbsp; In addition, at various points in your program, you may want to update the registration table with any recent changes to the database.&nbsp; The following paragraphs explain the functions that manipulate the contents of the database and the registration table.</font>

<p><font face="Times"><b>NXWriteDefault()</b> writes a default value into both the database and the registration table.&nbsp; It takes an owner, a parameter, and a default value for that parameter as arguments:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteDefault(&#34;WriteNow&#34;, &#34;NXFont&#34;, &#34;Helvetica&#34;);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this example, the NXFont parameter and its value Helvetica are written into both the database and the registration table for the owner <b>WriteNow</b>.</font>

<p><font face="Times">Similarly, <b>NXWriteDefaults()</b> writes a vector of default values for the given owner into the database and registers them.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">static NXDefaultsVector WriteNowDefaults = {</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">{&#34;NXFont&#34;, &#34;Times&#34;};</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">{&#34;NXFontSize&#34;, &#34;12.0&#34;};</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">{NULL};</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXWriteDefaults(&#34;WriteNow&#34;, WriteNowDefaults);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Both <b>NXWriteDefault()</b> and <b>NXWriteDefaults()</b> return the number of successfully written values.&nbsp; To maximize efficiency, you should use one call to <b>NXWriteDefaults()</b> rather than several calls to <b>NXWriteDefault()</b> to write multiple values.&nbsp; This will save the time required to open and close the database each time a value is written.</font>

<p><font face="Times"><b>NXSetDefault()</b> takes an owner, a parameter, and a value for that parameter as arguments:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXSetDefault(&#34;WriteNow&#34;, &#34;NXFont&#34;, &#34;Helvetica&#34;);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The parameter and its default value are placed in the registration table, but they aren't written into the <b>.NextDefaults </b>database.</font>

<p><font face="Times">Since other applications can write to the database, at various points the database and the registration table might not agree on the value of a given parameter.&nbsp; (The user can also write to the database, as described in the next section.) You can update the registration table with any changes that have been made to the database since the table was created by calling <b>NXUpdateDefault()</b> or <b>NXUpdateDefaults()</b>.&nbsp; Both functions compare the table and the database. If a value is found in the database that is newer than the corresponding value in the registration table, the new value is written into the registration table.</font>

<p><font face="Times"><b>NXUpdateDefault()</b> updates the value for the single parameter and owner given as its arguments:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXUpdateDefault(&#34;WriteNow&#34;, &#34;NXFont&#34;);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>NXUpdateDefaults()</b>, which takes no arguments, updates the entire registration table.&nbsp; It checks every parameter in the registration table, determines whether a newer value exists in the database, and puts any newer values it finds in the registration table.</font>

<p><font face="Times"><b>NXRemoveDefault()</b> removes a specified parameter for the given owner from the <b>.NextDefaults</b> database.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRemoveDefault(&#34;WriteNow&#34;, &#34;NXFontSize&#34;);</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Changing the Defaults Database from a Shell Window</b></font>

<p><font face="Times">In addition to the functions described above, the following three commands can be used in a Terminal or Shell window to read and write default values:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>dread -l</b> reads all the values in the defaults database and sends them to <b>stdout</b>.&nbsp; Instead of the <b>-l</b> option, you can specify a particular owner and a parameter; if no owner is specified, it's assumed to be GLOBAL.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>dwrite</b> takes an owner, a parameter, and a value as arguments and writes the value into the defaults database.&nbsp; If the <b>-g</b> option is used, the owner is assumed to be GLOBAL.&nbsp; If no arguments are given, input is taken from <b>stdin</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>dremove</b> removes the parameter named as an argument from the database.&nbsp; If an owner is specified as the first argument, <b>dremove</b> removes that owner's parameter-value pair; if the <b>-g</b> option is used, the owner is assumed to be GLOBAL.&nbsp; If no arguments are given, input is taken from <b>stdin</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">All arguments for these commands should be separated by spaces.&nbsp; For more information on using these commands, see their UNIX manual pages.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The Command Line</b></font>

<p><font face="Times">Without changing the <b>.NextDefaults</b> database, you can temporarily override values in the database or supply values for parameters that don't exist in the database.&nbsp; To do this, specify the desired values when launching an application from a Shell or Terminal window, as shown below:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">Edit -WidthInChars 100 -HeightInChars 120 SomeFile.m &amp;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this example, Edit will be launched, in a window that's 100 characters wide and 120 characters high.&nbsp; When <b>NXRegisterDefaults()</b> is called, the command-line values will be placed in the registration table, overriding values specified by the database and the NXDefaultsVector structure.&nbsp; However, these values will not be written into the database.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>System and Global Parameters</b></font>

<p><font face="Times">The Application Kit registers values for system and global parameters.&nbsp; System parameters are used by all applications for such things as determining which printer to use and which font to use in attention panels.&nbsp; Values for system parameters should remain constant across the system, so applications shouldn't overwrite system values.&nbsp; Values for global parameters are used by applications if there's no application-specific value.&nbsp; Global parameters determine the location of the main menu and the font used to display text, for example.&nbsp; Applications are encouraged to declare their own, application-specific, values for global parameters.</font>

<p><font face="Times">The following sections list the system and global parameters and describe their meaning.&nbsp; Parameters owned by the Workspace Manager are also discussed since they sometimes affect multiple applications.&nbsp; The parameters owned by Edit, Shell, and Terminal are described in the <i>NeXT Development Tools</i> manual.&nbsp; (All parameter names and their values are character strings; for simplicity, they're shown below without quotation marks.)</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>System Parameters</b></font>

<p><font face="Times">Applications obtain values for system parameters by specifying &quot;System&quot; as the owner in one of the functions described above for reading default values.&nbsp; Users can set values for some of these parameters through the Preferences applications.&nbsp; (For more information about Preferences, see <i>The NeXT User's Reference Manual</i>.)</font>

<p><font face="Times">The system parameters and their initially registered values are listed below.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Parameter</b></font></td>

<td><font face="Helvetica"><b>Initial Value</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">SystemAlert</font></td>

<td><font face="Times">Both</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">UnixExpert</font></td>

<td><font face="Times">NO</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">PublicWindowServer</font></td>

<td><font face="Times">NO</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Umask</font></td>

<td><font face="Times">18</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BrowserSpeed</font></td>

<td><font face="Times">50</font></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Printer</font></td>

<td><font face="Times">Local_Printer</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">PrinterHost</font></td>

<td><font face="Times">NULL</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">PrinterResolution</font></td>

<td><img src="../../Images/sp.gif" width=101 height=1><font face="Times">400</font></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">SystemFont</font></td>

<td><font face="Times">Helvetica</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BoldSystemFont</font></td>

<td><font face="Times">Helvetica-Bold</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">ScrollerButtonDelay</font></td>

<td><font face="Times">0.5</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">ScrollerButtonPeriod</font></td>

<td><font face="Times">0.025</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Users can set default values for the first five parameters through the Preferences application.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The SystemAlert parameter allows applications to offer voice as well as panels for system alerts.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the UnixExpert parameter is set to NO, all UNIX system files will be hidden.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The PublicWindowServer parameter determines whether processes that are not descended from the Workspace Manager have host access to the computer.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Values for the Umask parameter are integers that correspond to the octal values used by the <b>umask()</b> system call to set the file-creation mask.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The BrowserSpeed parameter determines how fast scrolling will be when the user clicks on a browser's scroll button.&nbsp; Values for this parameter can range from 0 to 100.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The next three parameters concern printing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Printer specifies the printer that will be used.&nbsp; Valid printers are listed in the ChoosePrinter panel that's opened through the Choose button in the Print panel.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">PrinterHost specifies the host machine of the printer.&nbsp; The default value, NULL, indicates the local printer's host.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Printing can be performed with a resolution of either 300 or 400 dpi.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The next two pairs of parameters specify the font used by the system to display text and how scroll buttons will respond.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The parameters SystemFont and BoldSystemFont are stored in global variables NXSystemFont and NXBoldSystemFont, respectively, for easy use by the Application Kit.&nbsp; The Kit uses these variables, for example, to display text in attention panels and in Cells of type NX_TEXTCELL.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The value for the ScrollerButtonDelay parameter specifies how many seconds the user must hold down the mouse button to make a scroll button repeat.&nbsp; ScrollerButtonPeriod indicates the interval, also in seconds, at which the scrolling action will be repeated if the user continues to hold down the mouse button.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Global Parameters</b></font>

<p><font face="Times">The Application Kit registers values for global parameters in the Application object's <b>initialize</b> method.&nbsp; Users can set values for some of these parameters using the Preferences application.&nbsp; Preferences writes values specified by a user into the defaults database (with owner set to GLOBAL) so they will override the initial values supplied by the Application object.</font>

<p><font face="Times">The global parameters that have been defined on the NeXT computer and their initially registered values are listed below.&nbsp; The following paragraphs discuss the possible values for these parameters and their meaning.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Parameter</b></font></td>

<td><font face="Helvetica"><b>Initial Value</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXFont</font></td>

<td><font face="Times">Helvetica</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXFontSize</font></td>

<td><font face="Times">12</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXMenuX</font></td>

<td><img src="../../Images/c2D.gif" width=8 height=4><font face="Times">1.0</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXMenuY</font></td>

<td><font face="Times">1000000.0</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXFixedPitchFont</font></td>

<td><font face="Times">Ohlfs</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXFixedPitchFontSize</font></td>

<td><font face="Times">10</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXPaperType</font></td>

<td><font face="Times">Letter</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXMargins</font></td>

<td><font face="Times">72 72 90 90</font></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXAutoLaunch</font></td>

<td><font face="Times">NO</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXCaseSensitiveBrowser</font></td>

<td><font face="Times">NULL</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXHost</font></td>

<td><font face="Times">NULL</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXOpen</font></td>

<td><font face="Times">NULL</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXOpenTemp</font></td>

<td><font face="Times">NULL</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXShowAllWindows</font></td>

<td><font face="Times">NULL</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXShowPS</font></td>

<td><font face="Times">NULL</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXMallocDebug</font></td>

<td><img src="../../Images/sp.gif" width=101 height=1><font face="Times">1</font></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NXPSName</font></td>

<td><font face="Times">NULL</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Users can set default values for the first four parameters through the Preferences application.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Because the initial value for the NXFont parameter is 12-point Helvetica, applications that create documents will use this font by default.&nbsp; However, many applications assign their own values to the NXFont and NXFontSize parameters, and most of these applications also provide a Font panel through which users can change the values.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXMenuX and NXMenuY specify the location of the main menu of the application.&nbsp; The initially registered values are off the screen, so applications will probably want to supply their own values.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The next two parameters affect the font of applications that use fixed-width fonts, such as Shell and Terminal.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The default value is 10-point Ohlfs font.&nbsp; NXFixedPitchFont must be set to a fixed-width font, such as Courier or Ohlfs, rather than a variable-width font, such as Times.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The next pair of parameters concerns printing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXPaperType must be one of the standard paper types for PostScript documents such as Letter, Legal, or A4.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The NXMargins parameter specifies the printing area on the page; the initial setting is appropriate for letter-size paper.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">Values for the next two parameters indicate whether an application was automatically launched at login and whether an application's browser ignores case.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Workspace Manager passes YES as the value for NXAutoLaunch if the application was automatically launched when the user logged in.&nbsp; (See the description of the LaunchThese parameter below under &quot;Workspace Manager's Parameters.&quot;)</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Applications that create browsers can use the NXCaseSensitiveBrowser parameter to determine whether they should ignore case when alphabetizing the browser's contents.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">You can use the command line to specify values for the last six parameters, which are used only at launch time and shouldn't be written to the database.&nbsp; See &quot;The Command Line&quot; above for more information on how to do this.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The NXHost parameter enables you to run an application on one machine while sending the PostScript code generated to another machine.&nbsp; The host machine will display windows and accept events from the user.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The NXOpen parameter specifies the name of the file to be opened by the application being launched.&nbsp; If NXOpenTemp is used to specify a file, that file won't be saved when the application quits unless you explicitly tell the application to save it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXShowPS, NXShowAllWindows, and NXMallocDebug control the display of debugging output.&nbsp; By default, NXShowPS and NXShowAllWindows are turned off.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXShowPS writes to <b>stderr</b> both the PostScript code produced by the application and values returned from the PostScript interpreter to the application.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NXShowAllWindows displays all off-screen windows created by the application.&nbsp; These windows typically contain Bitmap objects used for compositing into on-screen windows.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The value of NXMallocDebug is passed to the <b>malloc_debug()</b> function, which controls the amount of error checking that <b>malloc()</b> performs.&nbsp; The UNIX manual page on <b>malloc()</b> contains more information about both these functions.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXPSName is used to establish a connection with the Window Server:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Application Kit uses the value of NXPSName to look up the Window Server from the Network Name Server.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>Workspace Manager's Parameters</b></font>

<p><font face="Times">The parameters belonging to the Workspace Manager and their initial values are shown below.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Parameter</b></font></td>

<td><font face="Helvetica"><b>Initial Value</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">LaunchThese</font></td>

<td><font face="Times">Preferences</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">IconsSnapTo</font></td>

<td><font face="Times">YES</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BrowserColWidth</font></td>

<td><font face="Times">120</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">ApplicationPaths</font></td>

<td><font face="Times">~/Apps:/LocalApps:/NextApps:/NextDeveloper/Apps:</font><br>
<font face="Times">/NextAdmin:/NextDeveloper/Demos</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">CoreLimit</font></td>

<td><font face="Times">NULL</font></td></tr>

<tr valign=top>

<td width=131 height=20></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BrowserX</font></td>

<td><font face="Times">265</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BrowserY</font></td>

<td><font face="Times">287</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BrowserW</font></td>

<td><font face="Times">534</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">BrowserH</font></td>

<td><font face="Times">296</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The first two parameters can be set through panels brought up by the Workspace Manager.&nbsp; They're documented in more detail in <i>The NeXT User's Reference Manual</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">LaunchThese indicates which applications are automatically launched when the user enters the workspace.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">IconsSnapTo specifies whether icons displayed in the Icon view are aligned on the grid.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The next three parameters can be set by using the command line at launch time or by writing them into the database from a Shell or Terminal window.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">BrowserColWidth specifies the width of the columns of the Directory Browser.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Workspace Manager searches for application programs in the colon-separated directory list in ApplicationPaths.&nbsp; See &quot;Paths&quot; in Chapter 2, &quot;The NeXT User Interface,&quot; for more information about how the Workspace Manager uses this parameter.</font></td></tr>

<tr valign=top>

<td width=105 height=10></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">CoreLimit places a limit on the size of core files for Workspace Manager and its children.&nbsp; If a program dies, the system will write a core file if you have write permission in the working directory of the program and if CoreLimit is larger than the size of the core image.&nbsp; The default value, NULL, means that Workspace Manager inherits its parent's core limit.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The remaining four parameters set the position and size of the Browser.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">BrowserX and BrowserY specify the x- and y-coordinates of the lower left corner of the Directory Browser window.&nbsp; BrowserW and BrowserH specify its width and height.&nbsp; Values for these parameters shouldn't be set directly; they're set simply by moving or resizing the Browser on-screen.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>The Pasteboard</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The pasteboard is the principal means by which users can move data within and between applications.&nbsp; It supports a cut/copy/paste user-interface paradigm.&nbsp; To the user, there is a single pasteboard that all applications share, providing a unified environment.&nbsp; Also from the user's point of view, there is a single thing in the pasteboard at a given time. Internally, however, the pasteboard may contain more than one representation of its contents.&nbsp; For example, if a user cuts a piece of text from a word processor, that text replaces whatever was previously held in the pasteboard; however, that text may be represented in the Pasteboard object by an ASCII string and a piece of PostScript code at the same time.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Using the Pasteboard</b></font>

<p><font face="Times">Applications using the pasteboard perform all operations through a single instance of the Pasteboard class.&nbsp; This global Pasteboard object is accessed by sending a <b>pasteboard</b> message to the Application object:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">id&nbsp; myPboard;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">myPboard = [NXApp pasteboard];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The Pasteboard object manages all communications with <b>pbs</b>, the pasteboard server.&nbsp; All data read from or written to the pasteboard goes through <b>pbs</b>.&nbsp; Data for a particular type is transmitted as a single, contiguous buffer of memory. Since data is transmitted using Mach messaging, these buffers are shared among applications, making the communication very efficient for large quantities of data.&nbsp; Essentially, each application that has used the data has a pointer to the same, shared physical memory, even though it may appear in different ranges of their address spaces.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Declaring Data Types</b></font>

<p><font face="Times">When an application performs a copy (or a cut), it first becomes the owner of the pasteboard by declaring what types of data it will put in the pasteboard.&nbsp; It does this with the <b>declareTypes:num:owner:</b> method.&nbsp; The first two arguments for this method are a list of all possible representations for the selection being copied and the number of types in that list.&nbsp; An application can write any of the standard pasteboard data types defined by NeXT.&nbsp; It can also write its own data types for its own use, or for use among a cooperating set of applications.&nbsp; (Data types are named by null-terminated character strings.)&nbsp; The standard data types and their corresponding global variables, which are declared in the Application Kit header file <b>Pasteboard.h</b>, are listed below.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Data Type</b></font></td>

<td><font face="Helvetica"><b>Global Variable</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Plain ASCII text</font></td>

<td><font face="Times">NXAsciiPboard</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Rich Text Format (RTF) version 1.0</font></td>

<td><font face="Times">NXRTFPboard</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Encapsulated PostScript (EPS) version 1.2</font></td>

<td><font face="Times">NXPostScriptPboard</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">Tag Image File Format (TIFF) version 5.0</font></td>

<td><font face="Times">NXTIFFPboard</font></td></tr>

<tr valign=top>

<td width=131></td>

<td nowrap><font face="Times">NeXT sound pasteboard data type</font></td>

<td><font face="Times">NXSoundPboard</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The ASCII and RTF types both describe text.&nbsp; Clients of the pasteboard that handle text should always declare and be able to accept ASCII data.&nbsp; If they can also produce or read RTF, they should declare that type as well.</font>

<p><font face="Times">The pasteboard owner, which is the third argument for <b>declareTypes:num:owner:</b>, promises to supply data in all the representations declared.&nbsp; When copying data to the pasteboard, as described below, the owner can choose to delay writing a type until that type is requested, or it can supply all representations at one time.&nbsp; If writing will be delayed, the owner must be an object that won't be freed so that it can be informed when data has been requested.&nbsp; If all representations will be supplied at one time, the owner can be NULL.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Copying Data to and Reading it from the Pasteboard</b></font>

<p><font face="Times">After declaring the data types, data can be written to the pasteboard with the <b>writeType:data:length:</b> method.&nbsp; The first argument specifies the type of the data, and the second points to the data to be written.&nbsp; The length argument specifies the number of bytes of data.&nbsp; This method is called each time a different type is written to the pasteboard.</font>

<p><font face="Times">When an application performs a paste, it first examines the available data types in the pasteboard.&nbsp; The <b>types</b> method returns a null-terminated array of character strings describing the available types.&nbsp; If the application finds a data type that's appropriate, it requests the data with the <b>readType:data:length:</b> method.&nbsp; If that data representation has not yet been written to the pasteboard, the owner specified in the <b>declareTypes:num:owner:</b> method is sent a <b>provideData: </b>message with the type requested as an argument.&nbsp; The owner must then write that type of data to the pasteboard.&nbsp; (If the application quits before supplying all declared data types, a <b>provideData:</b> message will also be sent.&nbsp; This only works if the application quits using Application's <b>terminate:</b> method.)</font>

<p><font face="Times">Applications that do significant calculation to import a certain type may be able to save this work on repeated pastes of the same data by checking the change count.&nbsp; The change count is an integer (returned by the <b>changeCount</b> method) that increments every time a set of types for the pasteboard is declared.&nbsp; If the change count is the same as it was during a previous paste, the same data is being imported.</font>

<p><font face="Times">The following section gives examples of the process of copying data to and reading it from the pasteboard.&nbsp; All functions mentioned below are described in more detail in <i>NeXTstep Reference, Volume 2</i>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Examples of Preparing and Parsing Data</b></font>

<p><font face="Times">An NXStream or NXTypedStream structure can be helpful in creating and interpreting the buffers of data that the pasteboard deals with.&nbsp; They're similar to the stream model and interface in the UNIX <b>stdio</b> library, but they can read and write to memory and Mach ports as well as UNIX file descriptors.&nbsp; Using a stream, the same code can be used to interpret a buffer of a certain data type from the pasteboard as can be used to read a disk file of the same format.&nbsp; (See &quot;Streams&quot; in this chapter for more information.)&nbsp; A special kind of data stream, a typed stream, should be used for copying Objective-C objects to the pasteboard.&nbsp; Typed streams are discussed in more detail in &quot;Archiving to a Typed Stream&quot; earlier in this chapter.</font>

<p><font face="Times">The next two sections contain examples of using a stream and a typed stream with the pasteboard.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Using a Stream</b></font>

<p><font face="Times">In the following example, a View writes the PostScript representing itself to a stream and then copies it to the pasteboard.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- copy:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb = [NXApp pasteboard];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXStream&nbsp; *stream;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[pb declareTypes:&amp;NXPostScriptPboard num:1 owner:self];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">stream = NXOpenMemory(NULL, 0, NX_WRITEONLY);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[self copyPSCodeInside:NULL to:stream];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXGetMemoryBuffer(stream, &amp;data, &amp;length, &amp;maxLength);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[pb writeType:NXPostScriptPboard data:data length:length];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXCloseMemory(stream, NX_FREEBUFFER);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>declareTypes:num:owner:</b> method readies the pasteboard to receive a single type of data, PostScript.&nbsp; Then a stream that writes to memory is opened using <b>NXOpenMemory()</b>.&nbsp; Next the View's PostScript code is written to the stream with the <b>copyPSCodeInside:to:</b> method.&nbsp; The contents of the stream are obtained with <b>NXGetMemoryBuffer()</b> and are then transferred to the pasteboard through <b>writeType:data:length:</b>.&nbsp; Finally, the stream is closed.</font>

<p><font face="Times">This is what the corresponding <b>paste:</b> method might look like:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- paste:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb = [NXApp pasteboard];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp; **type;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXStream&nbsp; *stream;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for(type = [pb types]; *type; type++)</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if(!strcmp(*type, NXPostScriptPboard))</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if(*type) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[pb readType:NXPostScriptPboard data:&amp;data length:&amp;length];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">stream = NXOpenMemory(data, length, NX_READONLY);</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* parse PostScript data using NXGetc() or NXScanf() */</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">NXCloseMemory(stream, NX_FREEBUFFER);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* invalid data type - raise an exception */;</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>paste:</b> method first ensures that PostScript code is one of the pasteboard's available data types.&nbsp; Then it reads the PostScript data from the pasteboard with <b>readType:data:length:</b> and opens a memory stream on the data using <b>NXOpenMemory()</b>.&nbsp; The data can be parsed using <b>NXGetc()</b> or <b>NXScanf()</b> and pasted in, after which the stream is closed.&nbsp; Data read from the pasteboard is allocated using <b>vm_allocate()</b>, so it must be freed using <b>vm_deallocate()</b>. <b>NXCloseMemory()</b> does this automatically if NX_FREEBUFFER is specified.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Using a Typed Stream</b></font>

<p><font face="Times">A typed stream should be used to copy an Objective-C object to and read it from the pasteboard.&nbsp; A typed stream writes an object's class hierarchy as well as both the data type and value of the object's instance variables.</font>

<p><font face="Times">The example below writes an object to a typed stream using the function <b>NXWriteRootObjectToBuffer()</b> and then puts it on the pasteboard.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">-copy:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">const char&nbsp; *const types[1] = {&#34;PrivateTypes&#34;};</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb = [NXApp pasteboard];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[pb declareTypes:types num:1 owner:self];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">data = NXWriteRootObjectToBuffer(SelectionList, &amp;length);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[pb writeType:types[0] data:data length:length];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXFreeObjectBuffer(data, length);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">In this example, the data to be written to the pasteboard exists in SelectionList, which might be a List object, for example.&nbsp; <b>NXWriteRootObjectToBuffer()</b> opens a typed stream on memory, writes the object given as its argument, and then closes the stream.&nbsp; It also returns both the size of the object (in the location specified by <b>length</b>) and a pointer to the memory buffer itself, which is truncated to the size of the object.&nbsp; The contents of this buffer can then be written to the pasteboard with <b>writeType:data:length:</b>.&nbsp; Finally, the typed stream and the data are freed with <b>NXFreeObjectBuffer()</b>.</font>

<p><font face="Times">The following method reads the object from the pasteboard:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">-paste:sender</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp; **type;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb = [NXApp pasteboard];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp; *data;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp; length;</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PasteList;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for(type = [pb types];*type;type++) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if(!strcmp(*type,&#34;PrivateTypes&#34;))</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if(*type) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">[pb readType:*type data:&amp;data length:&amp;length];</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">pasteList = NXReadObjectFromBuffer(data, length);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXFreeObjectBuffer(data, length);</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*code for pasting in the data*/</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">The <b>for</b> loop shown above checks whether the desired data type is in the pasteboard.&nbsp; If so, the corresponding data is read from the pasteboard into the typed stream with the <b>readType:data:length:</b> method. <b>NXReadObjectFromBuffer()</b> then opens a typed stream, reads the data into <b>data</b>, closes the stream, and returns the buffer.&nbsp; Since in this case the buffer won't be reread, it's freed with <b>NXFreeObjectBuffer()</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Responding to Cut, Copy, and Paste</b></font>

<p><font face="Times">Interface Builder provides your application with a main menu containing a standard Edit submenu with Cut, Copy, and Paste commands.&nbsp; These commands are initialized to send the <b>cut:</b>, <b>copy:</b>, and <b>paste:</b> messages to the first responder, and thus through the responder chain.&nbsp; Editable Application Kit classes, like Text, implement the <b>cut:</b>, <b>copy:</b>, and <b>paste:</b> methods, and therefore respond to these menu choices without any explicit connections from the menu items. An application's View subclasses that support cut, copy, and paste should allow themselves to become the first responder, implement <b>cut:</b>, <b>copy:</b>, and <b>paste:</b> methods, and let the standard menu items and the responder chain find these implementations.</font></td></tr>

</table>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=5></td>

<td><font face="Helvetica" size="+2"><b>Exception Handling</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><b>For up-to-date information on exception handling, see the documentation in:</b></font>

<p><img src="../../Images/sp.gif" width=19 height=1><font face="Times"><b>/NextLibrary/Documentation/NextDev/Concepts/ExceptionHandling.rtf</b></font></td></tr>

</table>



<p><br><br><br><br><br>

</body>
</html>
