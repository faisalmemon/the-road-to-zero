<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/DevTools/NewInterfaceBuilder/04_CreatingClass.rtfd -->
<!-- Date: Sun Jun 28 19:52:28 1998 -->
<head>
<title>04_CreatingClass</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" size="-1"><i>To do something meaningful in NEXTSTEP programming, you must create a class. Custom classes harness the power of NEXTSTEP objects and give an application its distinctive logic and form. This chapter describes the basic steps that you must follow to create and use a subclass.</i></font>

<p><font face="Helvetica"><b>Working with Interface Builder</b></font></td></tr>

</table>

<p><br><br><br><br>

<p><font face="Helvetica" size="+4" color="#006013"><b>4</b></font>

<p><font face="Times" size="+2"><b>Creating a Class</b></font>

<p><br><br><br><br>

<p><font face="Helvetica" size="-1" color="#006013"><b>A roadmap to making and adding custom classes</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Naming a new class</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Specifying outlets and actions</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Creating an instance of your class</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Connecting your class's outlets</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Connecting your class's actions</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Generating source code files</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Implementing a subclass of Object</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Implementing a subclass of NSObject</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Archiving in a mixed world</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Acting as delegate</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Implementing a View subclass</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Adding existing classes to your nib file</b></font>

<p><font face="Helvetica" size="-1" color="#006013"><b>Updating a class definition</b></font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">I inherited it brick, and left it marble.</font><br>
<img src="../../Images/sp.gif" width=72 height=1><font face="Times">Emperor Augustus</font>

<p><font face="Times">They rightly do inherit heaven's graces,</font><br>
<font face="Times">And husband nature's riches from expense.</font><br>
<img src="../../Images/sp.gif" width=72 height=1><font face="Times">Shakespeare, <i>Sonnets</i></font>

<p><font face="Times">Observe how system into system runs,</font><br>
<font face="Times">What other planets circle other suns.</font><br>
<img src="../../Images/sp.gif" width=72 height=1><font face="Times">Alexander Pope, <i>An Essay on Man</i></font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><font face="Helvetica"><b>A ROADMAP TO MAKING OR ADDING CUSTOM CLASSES</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Determine which flowchart applies to your situation.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Follow the tasks in this chapter in the order specified by that flowchart.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">This chapter differs from the other chapters in this manual because its subject is different. Creating a class (or adding an existing class) is not a set of discrete, modular tasks, but a process consisting of many interdependent tasks. The order of tasks in this chapter is therefore significant;&nbsp; with some exceptions, you need only follow the tasks sequentially, from first task to last task, and you'll end up with a useful class.</font>

<p><font face="Times">But those exceptions are significant, and so flowcharts are provided to point the way. The flowchart on the facing page guides you through the tasks required to define and implement a subclass of a root class or of the View class. An additional flowchart identifies the tasks you must complete to integrate an existing class into an application.</font>

<p><font face="Times" size="-1"><b>Note:</b></font> <font face="Times">Interface Builder's role in subclass creation is to help you locate the class in the hierarchy, name it, connect an instance of it with other objects in an application, and generate template source files. When Interface Bulder's role is done, you then must make the most important contribution: the source code that gives your class its distinctive behavior.</font>

<p><font face="Times" color="#006811">This chapter is also a departure from previous chapters because some of its tasks require other applications: Project Builder and a code editor (such as Edit). See the appropriate chapters in <i>NEXTSTEP Development Tools and Techniques</i> for information on Project Builder and Edit.</font>

<p><br><br>

<p><img src="FlowchartLegend.gif" width=177 height=249>

<p><br><br>

<p><font face="Helvetica" color="#0E0E0E"><b>Creating a Class</b></font>

<p><img src="JensFlowchart5_RTF.gif" width=415 height=684>

<p><font face="Times" color="#006811">If you branch to &quot;Implementing a Subclass of View&quot; after specifying outlets and actions, complete only the step &quot;Making an Instance of a View Subclass&quot;in this task for now, and go on to the next task.</font>

<p><font face="Times" color="#006811">After generating code files, you must switch over to Project Builder and open the header and implementation files in Edit (or some other code editor).</font>

<p><br><br>

<p><font face="Helvetica" color="#0E0E0E"><b>Adding a Class</b></font>

<p><img src="FlowchartSmall_RTF.gif" width=415 height=393>

<p><br><br>

<p><font face="Times" color="#006811">If you branch to &quot;Implementing a Subclass of View&quot; after specifying outlets and actions, complete</font><br>
<font face="Times" color="#006811">only the step &quot;Making an Instance of a View Subclass&quot;in this task and go on to the next task.</font>

<p><font face="Times" color="#006811">You'll probably want to add your class's header and implementation files to Project Builder as well</font><br>
<font face="Times" color="#006811">as to Interface Builder. See <i>NEXTSTEP Development Tools</i></font><br>
<font face="Times" color="#006811"><i>and Techniques</i> for information on this procedure.</font>

<p><br><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3>

<p><font face="Helvetica"><b>A Class Hierarchy in Transition</b></font>

<p><font face="Times">This book and especially this chapter occasionally refer to a &quot;root class.&quot; This phrase does not lack precision, but reflects a current reality: NEXTSTEP has (temporarily) dual class hierarchies.</font>

<p><font face="Times">The version of NEXTSTEP that comes with the first release of the Enterprise Objects Framework has two root classes, and therefore it has two class hierarchies. There's Object, the root class that most NEXTSTEP developers are familiar with. And now there's also NSObject. The Classes display of Interface Builder's nib file window shows these two root classes.</font>

<p><br><br>

<p><img src="F34.gif" width=356 height=240>

<p><br><br>

<p><font face="Times">NSObject is the root class for the Foundation Kit. and will soon become the root class for all NEXTSTEP classes. The Application Kit and most other NEXTSTEP classes are being converted to the class hierarchy rooted by NSObject.</font>

<p><font face="Times">The Foundation Kit (or, simply, Foundation) is a group of classes that replaces the Common classes (List, Hash, Storage, and so on). Foundation is more, however. As the name suggests, it lays down a foundation of object functionality that supports all other classes in NEXTSTEP. It provides base classes for things like strings, values, collections and storage. But more importantly, Foundation improves the persistence and distribution of objects within an object system that is independent of particular operating systems. Foundation also introduces paradigms and mechanisms that enrich the object-oriented development process, especially a new way to deallocate objects.</font>

<p><font face="Helvetica" size="-1"><b>Guidelines For Programming</b></font>

<p><font face="Times">How do you program in a world that mixes objects of different &quot;lineages&quot;? Here are some caveats and guidelines for navigating this mixed-object world (for convenience, instances of NSObjects are referred to as NSObjects):</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Subclass NSObject when you require specialized controller objects, particularly custom objects related to the Enterprise Objects Framework. Otherwise, create subclasses that inherit from Object; this is especially true if you need an object dependent on the current Application Kit (for instance, a custom View) or an object that can be archived to a nib file.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If you deal with NSObjects, you are responsible for managing your own cycles. A cycle is a condition where objects <b>retain</b> each other. If you create a cycle, you must break it. (When you retain an object, you increment its reference count, deferring its deallocation. See &quot;Foundation's Approach to Object Disposal&quot; later in this chapter for more on <b>retain</b> and the autorelease mechanism.)</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap></td>

<td><font face="Times">When to retain and when not to is a tricky question. If you don't retain an object, you can lose it; on the other hand, if you retain an object, you could be generating cycles you have no idea about. Be aware that cycles can exist without you explicitly creating them. For example, an NSArray object retains each object you add to it. Also be aware that, when you're inserting objects into collections (like NSArray) and you want to bypass the <b>retain</b>/<b>release</b> mechanism, you can use NSValue's <b>valueWithNonretainedObject:</b> to wrap objects.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">When you set an NSObject instance variable, <b>autorelease</b> the old object, then <b>retain</b> the new value. See the introduction to <i>Foundation Kit Reference</i> or &quot;Foundation's New Approach to Object Disposal&quot; later in this chapter for more information.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Use the new NSCoder and NSArchiver API to archive NSObjects; do not archive NSObjects with <b>read:</b> and <b>write:</b>. If you do, it is guaranteed that these objects will be incompatible with future versions of NEXTSTEP. For details, see the &quot;Implementing Archiving and Unarchiving&quot; step of the task &quot;Implementing a Subclass of NSObject.&quot;</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If your class has instance variables that inherit from the other root class, archive these variables with the special API. described in &quot;Archiving in a Mixed World,&quot; later in this chapter.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Never send <b>free</b> to an NSObject; send <b>release</b> instead.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Helvetica" size="-1"><b>Note:</b></font> <font face="Times">The most significant&nbsp; new features of Foundation are its notion of class clusters, its new archiving technology, and its&nbsp; mechanism and policy for object deallocation. &quot;Foundations New Approach to Object Disposal&quot; in this book summarizes&nbsp; the latter feature. See the introduction to the <i>Foundation Kit Reference</i> for comprehensive information on all of these features.</font>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_IdentifyingNewClass"></a><font face="Helvetica"><b>NAMING A NEW CLASS</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Display the Classes display of the nib file window.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>Select the class you want your class to inherit from.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Choose Subclass from the Operations menu.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">4</font></td>

<td><font face="Helvetica" size="-1"><b>Type the name of your class over the highlighted &quot;default&quot; name.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">When you create an application in NEXTSTEP, you must create at least one subclass to do anything meaningful. The Application Kit and other NEXTSTEP kits are powerful frameworks that do a lot of the work for you, but you must always supply, in one or more subclasses, the distinctive logical and computational flow of your application.</font>

<p><font face="Times">When you create a class, the first thing you must do is select your class's superclass. Make your selection in the Classes display of the nib file window.</font>

<p><img src="Naming1.gif" width=535 height=220>

<p><font face="Times">Ideally, the superclass of your class should behave much the way you want your class to behave. Your class merely adds the behavior you want to what the superclass offers, or modifies the superclass's behavior in some way. Often the behavior you want is so bound to resolving a particular problem that the proper choice of superclass is the root class. The root class provides the most generic object behavior.</font>

<p><font face="Times">Once you've selected a superclass, you must name your class.</font>

<p><img src="Naming2.gif" width=508 height=287>

<p><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">Pressing Return when a class is selected is equivalent to choosing the Subclass command.</font>

<p><font face="Times">The new class is listed under its superclass with a default name: the superclass name prefixed with &quot;My&quot; (such as &quot;MyObject&quot;). Replace this default name with the new name.</font>

<p><img src="Naming3.gif" width=512 height=215>

<p><font face="Times">Later, if you want to rename the class, first re-select the class name by double-clicking it. Then type the new name, replacing the selected text.</font>

<p><font face="Times" color="#006811">See &quot;A Short Practical Guide to Subclassing&quot; later in this chapter for more on the relation between superclasses and subclasses.</font>

<p><br><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3>

<p><font face="Helvetica"><b>A Perspective on the Class Hierarchy</b></font>

<p><font face="Times">The Classes display of the nib file window shows the classes that the current nib file is aware of. The display lets you browse through both NEXTSTEP classes and custom classes. The Classes display also depicts (by indentation) class-inheritance relationships and reveals the names of each class's outlets and actions.</font>

<p><font face="Helvetica" size="-1"><b><sup>Keyboard Navigation</sup></b></font><br>
<font face="Times">Move up and down in the list of classes pressing the up arrow and the down arrow.&nbsp; When a class is highlighted, show its subclasses by pressing the right arrow; collapse an indented list by selecting the superclass and pressing the left arrow. If the nib file window is active, incremental search is active: just type the first few letters of a class until its name</font><br>
<font face="Times">is highlighted.</font>

<p><img src="Perspective.gif" width=603 height=292>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_IdentifyingOandA"></a><font face="Helvetica"><b>SPECIFYING OUTLETS AND ACTIONS</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Click the button for an outlet or an action.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>Select <i>Outlets</i> or <i>Actions</i>.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Choose the appropriate command from the Operations menu.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">4</font></td>

<td><font face="Helvetica" size="-1"><b>Enter the name of the outlet or action in place of the default name.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">An object isolated from other objects is of little use. Interface Builder provides two ways for you to specify how objects of your class communicate with other objects: outlets and actions.</font>

<p><font face="Times">Before you begin this task, take a moment to consider what other objects you want instances of your class to send messages to, and the requests that instances of your class are apt to receive from other objects. The procedure itself is simple, and almost identical for outlets and actions.</font>

<p><font face="Times"><b><sup>Adding Outlets</sup></b></font><br>
<font face="Times">Outlets are instance variables that identify other objects. In the Classes display, you access the outlets of a class by clicking the electrical-outlet button.</font>

<p><img src="AddingOA1.gif" width=528 height=529>

<p><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">To display a class's outlets and actions (with Outlets highlighted), you can choose the Edit command from the Operations menu instead of clicking the outlet button.</font>

<p><font face="Times">When you press Return, the outlet is renamed and Interface Builder highlights the new outlet. If you have another outlet to specify, choose Add outlet again from the Operations menu and type the outlet's name over the default name.</font>

<p><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">When an outlet (but not the text of an outlet) is highlighted, you can add a new outlet by pressing the Return key instead of choosing the Add outlet command.</font>

<p><font face="Times"><b><sup>Adding Actions</sup></b></font><br>
<font face="Times">Actions are methods invoked as a direct consequence of the manipulation of Control objects in the interface, such as when users click a button. In the Classes display, you access the actions of a class by clicking the cross-hairs button.</font>

<p><img src="AddingOA2.gif" width=534 height=530>

<p><font face="Times">When you press Return, the action is renamed and Interface Builder highlights the new action. If you did not specify a colon (:) after the name, Interface Builder appends it for you. If you have another action to specify, choose Add action from the Operations menu, and type the new action's name over the default action name (&quot;MyAction&quot;).</font>

<p><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">When an action (but not the text of an outlet) is highlighted, you can add a new action by pressing the Return key instead of choosing the Add action command.</font>

<p><font face="Times">When you are finished specifying outlets and actions, click the class name to collapse the list of outlets and actions.</font>

<p><font face="Times" color="#006811">For background information on outlets and actions, see &quot;Communicating With Objects: Outlets and Actions&quot; in Chapter 3, &quot;Making and Managing Connections.&quot;&quot;</font>

<p><br><br><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3>

<p><font face="Helvetica"><b>A Short Practical Guide to Subclassing</b></font>

<p><font face="Times">Subclassing is not an esoteric art but one of the most common and essential tasks in object-oriented programming. But it doesn't need to be a difficult chore, especially if you take the time to learn what's in the class hierarchy.</font>

<p><font face="Helvetica" size="-1"><b>What is Subclassing?</b></font>

<p><font face="Times">The principal notion behind subclassing is inheritance. Classes stand in relation to other classes as child to parent or parent to child. A class might have many child classes (or subclasses), but always has only one parent class (superclass). At the head of this class hierarchy is the root class.</font>

<p><img src="F3.gif" width=294 height=177>

<p><font face="Times">The attributes (instance variables) and behavior (methods) defined by a class are shared by all descendents of that class.&nbsp;&nbsp; To put it another way, each new class is the accumulation of all class definitions in its inheritance chain.</font>

<p><font face="Times">For example, the View class defines two instance variables for location and size (<b>frame</b> for the superview orientation, and <b>bounds</b> for within the view) from which all instances of its numerous subclasses derive their own basic position and dimensions. The View class also defines several methods for setting and getting these instance variables; again, all subclasses of View inherit the behavior defined by these methods. You can send the same messages to any instance of a View subclass to have it resize itself.</font>

<p><font face="Times">So subclassing is usually the extension and specialization of the inheritance chain. When you define a class that inherits from another class, you are specifying how it differs from that superclass.</font>

<p><font face="Times">But there are reasons for creating a subclass--or a &quot;branch&quot; of subclasses--other than getting different behavior.&nbsp;&nbsp; You may want to define a class that dispenses generic functionality to its subclasses, such as an Output class that performs tasks common to both a Printer class and a Fax class.&nbsp; You might want a class to declare methods (perhaps unimplemented) that set up a protocol that future subclasses can implement.&nbsp; Code reusability is an additional motive:&nbsp; the behavioral elements shared among classes can go into a single superclass for those classes.</font>

<p><font face="Helvetica" size="-1"><b>Analyzing the Inheritance Chain</b></font>

<p><font face="Times">As the first step in subclassing you should analyze the inheritance chain. This point may seem obvious, but it is important enough to emphasize.&nbsp; You should do more than just identify the most suitable superclass; you want to understand exactly what it does and how it interacts with other classes.</font>

<p><font face="Times">Carefully read the specifications in the <i>NEXTSTEP General Reference</i>. Note which methods and instance variables are available. Determine what the methods do and how they are related to each other;&nbsp; identify the accessor methods, those that get and set the instance variables;&nbsp; identify the interfaces to instances of other classes (such as outlets).&nbsp; If you are subclassing a Foundation Kit class, locate the primitive methods (those that access instance variables directly).</font>

<p><font face="Times">If the behavior you want for your class is targeted at a special problem, even if that problem is managing an application or window, it might make the most sense to subclass the root class. These kind of subclasses, often called controller or model classes, are common in NEXTSTEP applications. See &quot;Implementing a subclass of Object&quot; and &quot;Implementing a subclass of NSObject&quot; for details on creating typical controller classes. Also, see &quot;The Model-View-Controller Paradigm&quot; later in this chapter for a description of the distinguishing characteristics of controller and model types of classes.</font>

<p><br><br>

<p><font face="Helvetica" size="-1"><b>Instance Variables: To Add or Not to Add</b></font>

<p><font face="Times">Instance variables represent an object's attributes and hold pointers to other objects (outlets). If instances of your class require special attributes or outlets, add them.</font>

<p><font face="Times">But, as a general rule, avoid adding instance variables unless they are absolutely necessary. Instance variables add weight to objects. You sometimes generate certain objects (for example, cells in a file-system browser) in large numbers. The more data these ojbects carry, the more memory gets consumed.</font>

<p><font face="Times">Often you can compute values from other values. Sometimes you can get pointers to other objects without having to specify outlets. Or you can represent attributes in lightweight fashion, especially if they are Boolean in nature, by encoding them as bits in an integer.</font>

<p><font face="Times">If you do not want to give subclasses of your class access to its instance variables, put the <b>@private </b>directive before the declarations of the instance variables you want to conceal.</font>

<p><br><br>

<p><font face="Times" size="-1"><i>This example illustrates the effects of polymorphism and inheritance in a hypothetical class hierarchy. The Shape Class provides basic functionality and a single instance variable. The Circle class, a subclass of Shape, adds more instance data and actually implements drawing. The Crescent class supplements its superclass (Circle) with more specialized behavior and data.</i></font>

<p><img src="Subclassing_RTF.gif" width=563 height=399>

<p><br><br>

<p><font face="Helvetica" size="-1"><b><sup>Determining Your Class's Methods</sup></b></font><br>
<font face="Times">Look at your class from the perspective of potential clients. What will they want it to do? What information will they expect back? The answers to these and similar questions will lead to the set of methods for your class. Based on relation to superclass, methods generally come in three types:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Added methods.</b> These new methods extend the class definition. They include accessor methods for new instance variables.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Replacement methods.</b> These types of methods completely override the superclass method of the same name. They can also, by being a &quot;null&quot; implementation, block the invocation of the superclass method.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Extended methods.</b> These methods also override a superclass method, but then in the implementation invoke the superclass method by calling <b>super</b>. This is a common technique for adding behavior or getting cumulative behavior (such as archiving) across the inheritance chain in response to a single message (such as <b>write:</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Helvetica" size="-1"><b>What is Public, What is Private?</b></font>

<p><font face="Times">When designing your subclass, also identify the code that is part of the interface and code that is private to the class.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Public methods.</b> These implement your class's interface. External objects invoke these methods by sending messages to instances of your class. Among these types of methods are accessor methods, which mediate client access to instance variables. You declare public methods in the header file for your class.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Private methods.</b> These methods can be invoked by objects within a project but are invisible to external objects. You usually declare them in a private header file and prefix the method name with an underscore character.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Functions.</b> Non-library static C functions are also private to your class. They are marginally faster than methods because they don't involve the overhead of the run-time object system.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Use a method if you're accessing instance variables, and use a public method if that method is part of your public interface. Otherwise, use functions.</font>

<p><font face="Helvetica" size="-1"><b>Alternatives to Subclassing</b></font>

<p><font face="Times">Sometimes you can get particular behavior without additional subclassing. NEXTSTEP and the Objective C language give you many ways to merge and synchronize your class's behavior with the behavior of NEXTSTEP classes and even other custom classes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Delegation.</b>&nbsp; A kit object can send, on specific occasions, messages to another object registered as its delegate. If the delegate implements the methods so invoked, it can participate in the work of the kit object. For example, an NXBrowser object sends messages to its delegate requesting cells to insert into a column. Other major Application Kit classes with delegation protocols are Application, Window, and Text.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Notifications.</b> Many kit objects post notifications to all interested observers when a particular event takes place or is about to take place. Notifications allow observing objects to coordinate related activities and sometimes give them a chance to veto the event. This can be better than delegation because an object can have many observers but only one delegate. See the specification for NSNotificationCenter (a Foundation Kit class) for details on adding an observer object and on responding to notifications.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Protocols.</b> A protocol is a list of method declarations associated with a particular purpose but unattached to a class definition. By adopting the protocol and implementing the methods, your class can interact with NEXTSTEP classes and accomplish that purpose. NEXTSTEP publishes many protocols, including those for spell-checking and interacting with the Workspace Manager.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>Categories.</b> These are Objective C constructs that enable you to add methods to a class without having to subclass it. The methods become part of the class, inherited by all of its subclasses. The only major drawback is that you cannot declare new instance variables (however, you can access all existing instance variables). Besides extending a class definition, you use categories to group, manage, and configure methods in large classes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Helvetica" size="-1"><b>Note:</b></font> <font face="Times">For the version of Interface Builder packaged with the initial release of the Enterprise Objects Framework, there are twin root class, Object and NSObject. For details on these root classes and guidelines for programming in this dual-root situation, see &quot;A Class Hierarchy in Transition&quot; earlier in this chapter. Also read the release notes for the Enterprise Objects Framework.</font>

<p><font face="Times">For complete information on the requirements, strategies, and techniques for creating a class, see <i>NEXTSTEP Object-Oriented Programming and the Objective C Language</i>.</font>

<p><br><br>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_CreatingInstance"></a><font face="Helvetica"><b>CREATING AN INSTANCE OF YOUR CLASS</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Select your class in the Classes display.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>Choose Instantiate from the Operations menu.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">You cannot connect classes to other classes. Only instances of classes--objects--can really communicate with each other. Interface Builder requires a real instance of your class to enable the connection of your object to other objects.</font>

<p><font face="Times">The procedure for generating instances of non-View classes in Interface Builder is simple. <i>This procedure applies only to classes that don't inherit from the View class.</i></font>

<p><img src="Instantiate1.gif" width=515 height=536>

<p><font face="Times">When the new instance appears in the Instances display, it takes the same name as the class. Rename it, if you want, to something more indicative of an object. (Double-click the text to select it, then type the new name.) For example, AppController could become AppControllerObject. Be aware, however, that this name is merely a convenient way to identify the object in Interface Builder; it does not create an identifier that you can reference in code.</font>

<p><font face="Times" color="#006811">For details on creating an instance of a View subclass, see &quot;Implementing a View subclass&quot; later in this chapter.</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><font face="Helvetica"><b>CONNECTING YOUR CLASS'S OUTLETS</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Control-drag a connection line from the instance to another object.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>In theConnections display, select the outlet that identifies the destination object.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Click the Connect button.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">An outlet is an instance variable that identifies another object. You initialize an outlet in Interface Builder by making a connection from your instance to another object.</font>

<p><img src="ConnectOutlet.gif" width=495 height=392>

<p><font face="Times">When you establish the line connection, the Inspector panel for the destination object becomes the key window. Specify the outlet identifier for this object.</font>

<p><img src="ConnectOutlet2.gif" width=473 height=388>

<p><br><br>

<p><font face="Times" color="#006811">This task and the next one, &quot;Connecting Your Class's Actions,&quot; summarize information more fully presented in Chapter 3, &quot;Making and Managing Connections.&quot;</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_ConnectIF"></a><font face="Helvetica"><b>CONNECTING YOUR CLASS'S ACTIONS</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Control-drag a connection line from a Control object to your class's instance.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>In the Inspector's Connections, select the appropriate action.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Click the Connect button.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">An action is the method that a Control object invokes in your instance--the target object--when a user activates the Control (for example, clicks a button). You make an action connection in Interface Builder by drawing a connection line from the Control object to the instance of your class.</font>

<p><img src="ConnectAction1.gif" width=534 height=388>

<p><font face="Times">When the line is set between the objects, the second column of the Connections display shows the action methods that the target object (your instance) has declared. Select the action for this Control object.</font>

<p><img src="ConnectAction2.gif" width=487 height=348>

<p><font face="Times" color="#006811">You can make connections between objects entirely within the outline mode of the Instances display. For more information on the outline mode, see Chapter 3, &quot;Making and Managing Connections.&quot;</font>

<p><br><br><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3><br>
<font face="Helvetica"><b>The Model-View-Controller Paradigm</b></font>

<p><font face="Times">A common and useful paradigm for object-oriented applications, particularly business applications, is Model-View-Controller (MVC).&nbsp; MVC derives from Smalltalk-80; it proposes three types of objects in an application, separated by abstract boundaries and communicating with each other across those boundaries.</font>

<p><img src="F35.gif" width=267 height=199>

<p><font face="Helvetica" size="-1"><b><sup>Model Objects</sup></b></font><br>
<font face="Times">This type of object represents special knowledge and expertise.&nbsp; Model objects hold a company's data and define the logic that manipulates that data.&nbsp; For example, a Customer object,&nbsp; common in business applications, is a Model object. It holds data describing the salient facts of a customer and has access to algorithms that access and calculate new data from those facts.&nbsp; A more specialized Model class might be one in a meteorological system called Front;&nbsp; objects of this class would contain the data and intelligence to represent weather fronts.&nbsp; Model objects are not displayable. They often are reusable, distributed, and portable to a variety of platforms.</font>

<p><font face="Helvetica" size="-1"><b><sup>View Objects</sup></b></font><br>
<font face="Times">A View object--an instance of a subclass of View--represents something visible on the user interface (a display or a control).&nbsp; A View object is &#34;ignorant&#34; of the data it displays.&nbsp; The Application Kit usually provides all the View objects you need: windows, text fields, scroll views, buttons, browsers, and so on.&nbsp; But you might want to create your own View objects to show or represent your data in a novel way (for example, a graph view).&nbsp; View objects, especially those in kits, tend to be very reusable and so provide consistency between applications.</font>

<p><font face="Helvetica" size="-1"><b><sup>Controller Object</sup></b></font><br>
<font face="Times">Acting as a mediator between Model objects and View objects in an application is a Controller object. There is usually one per application or window.&nbsp; A Controller object communicates data back and forth between the Model objects and the View objects.&nbsp; It also peforms all the application-specific chores, such as loading nib files and acting as window and application delegate. Since what a Controller does is very specific to an application, it is generally not reusable even though it often comprises much of an application's code.</font>

<p><font face="Times">Because of the Controller's central, mediating role, Model objects need not know about the state and events of the user interface, and View objects need not know about the programmatic interfaces of the Model objects.&nbsp; You can make your View and Model objects available to others from a palette in Interface Builder.</font>

<p><font face="Helvetica" size="-1"><b><sup>Hybrid Models</sup></b></font><br>
<font face="Times">MVC, strictly observed, is not advisable in all circumstances.&nbsp;&nbsp; Sometimes its best to combine roles. For instance, in a graphics-intensive application, such as an arcade game, you might have several View objects that merge the roles of View and Model.&nbsp; In some applications, especially simple ones, you can combine the roles of Controller and Model;&nbsp; these objects join the special data structures and logic of Model objects with the Controller's hooks to the interface.</font>

<p><font face="Helvetica" size="-1"><b><sup>The MVC Model in EO Framework</sup></b></font><br>
<font face="Times">The Enterprise Objects Framework (EO Framework) makes the MVC model an explicit part of its architecture. The classes of the Framework's interface layer constitute the Controller system of an application. At the heart of this layer is the EOController class. An Framework application has one EOController object for each class of enterprise objects it uses. (The Framework thus supplies a Controller object; you don't have to create it yourself.) The enterprise objects in an application comprise the Model layer and the UI objects comprise the View layer.</font>

<p><br><br>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_GeneratingCode"></a><font face="Helvetica"><b>GENERATING SOURCE CODE FILES</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Select your class in the Classes display.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>Choose Unparse from the Operations pull-down menu.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Click Yes in the subsequent attention panels.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Before you begin specifying the behavior of your class in code, you typically generate template source code files for your class from the information contained in the nib file. The header file (<i>MyClass</i>.h) created by Interface Builder declares the outlets you specified as instance variables (of type <b>id</b>) and declares the actions as instance methods of the form <i>methodName</i>:<b>sender</b>. The implementation file (<i>MyClass</i>.m) contains empty function blocks for each of these methods.</font>

<p><font face="Times">Interface Builder generates template code files by unparsing the nib file.</font>

<p><img src="Unparse1.gif" width=505 height=295>

<p><font face="Times">Interface Builder then displays an attention panels to confirm creation of the files.</font>

<p><img src="Unparse2.gif" width=479 height=171>

<p><font face="Times">If you confirm creation and the nib file is associated with a project, another attention panel subsequently asks if you wish to add the template code files to the project. Click Yes to add the files to the project.</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_ImplSimpleClass"></a><font face="Helvetica"><b>IMPLEMENTING A SUBCLASS OF OBJECT</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Import header files.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Declare new instance variables.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Implement accessor methods.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define target/action behavior.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define initialization and clean-up behavior.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define how objects are copied.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define how objects are compared.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Implement archiving and unarchiving.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define special behavior for your class.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">This task summarizes the steps that you must complete--and can optionally complete--to implement a subclass of Object. With this kind of subclass, the subtleties arising from inherited behavior are simplified. Still, the interaction of your class with the root class is very important, and applies to all subclasses.</font>

<p><font face="Times">In this task you write code, and so there is a temporary departure from Interface Builder. The task assumes that you have completed the following prerequisites in Interface Builder, presented earlier in this chapter:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Naming a class, positioning it in the class hierarchy</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Specifing outlets and actions for the class</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Creating an instance of the class</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Connecting the instance to other objects through the outlets and actions</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Generating code files by unparsing the nib file</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">When you have generated code files in Interface Builder, switch over to the Project Builder application and open your project. Open your class's header file (<i>ClassName</i>.h) and implementation file (<i>ClassName</i>.m) in Edit windows.</font>

<p><img src="ImplemObj1.gif" width=549 height=290>

<p><br><br>

<p><font face="Times"><b><sup>Importing Header Files</sup></b></font><br>
<font face="Times">This step is little different from what you must do in regular C programming: At</font><br>
<font face="Times">the beginning of your implementation file include the header files declaring all types and functions that your code is using, as well as the header files for all referenced classes, protocols, and methods. Instead of <b>#include</b>, however, use the <b>#import</b> directive; <b>#import</b> ensures that the same file is never included more than once.</font>

<p><font face="Times">Remember to import your class's header file. By doing so you include the interface files for all inherited classes. To include the Application Kit classes, all you need to</font><br>
<font face="Times">do is <b>#import &lt;appkit/appkit.h&gt;</b>. (Interface Builder imports both <b>appkit.h</b> and</font><br>
<font face="Times">your class header files for you automatically). Also add all relevant libraries in Project Builder (such as <b>libFoundation_s.a</b>).</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">//&nbsp; Record.h</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &lt;appkit/appkit.h&gt;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">//&nbsp; Record.m (implementation file)</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &#34;RecordList.h&#34;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &#34;Record.h&#34;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b><sup>Declaring New Instance Variables</sup></b></font><br>
<font face="Times">The header file generated by Interface Builder declares outlets as instance variables of type <b>id</b>. You might want to add new instance variables for your class to this list of declarations. These instance variables can hold strings, integers, floating-poing values, and other objects. All instance variables should be data that is essential to an instance of your class.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@interface RecordListManager:Object</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id recordCountField;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id recordForm;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>RecordList *recordList;</b></font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> In this example the instance variables <b>recordCountField</b> and <b>recordForm </b>derive from the outlets specified in Interface Builder. They are written to the header file when template files are generated. The instance variable <b>recordList</b> has been added to identify an instance of a custom class (RecordList). You can declare your object variables as type <b>id</b> although explicit typing improves type-checking during compilation.</font>

<p><font face="Times"><b><sup>Implementing Accessor Methods</sup></b></font><br>
<font face="Times">Accessor methods retrieve and set the values of instance variables. They provide the encapsulation of an object's data, which only the object itself (and usually instances of subclasses) can directly access. Accessor methods mediate access to instance variables, allowing client objects to get and set values through an object's interface--that is, by sending messages.</font>

<p><font face="Times">Accesor methods that <i>retrieve</i> a copy of an instance variable by convention take the same name as the instance variable. They usually have a single statement that returns the value of the instance variable. Methods that <i>set</i> the value of an instance variable by convention take the name of the instance variable (first letter capitalized) prefixed with &quot;set.&quot; For variables of most types, these kinds of methods assign the new value, passed in as an argument, to the instance variable and then either return <b>self</b> or do not return at all (if declared as <b>void</b>). Set methods often test passed-in values for validity before assigning them.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (const char *)key</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return key;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- setKey:(const char *)newKey;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if (key) NX_FREE(key);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if (newKey) {</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">key = NXCopyStringBuffer(newKey);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> The <b>key</b> method retrieves the value of the instance variable <b>key</b>; it simply returns the value and does not return <b>self</b>. The <b>setKey:</b> method sets the value of the instance variable <b>key</b>. Since, in this example, the variable is dynamically allocated, it frees it first (<b>NX_FREE()</b>) before allocating and copying the new value with <b>NXCopyStringBuffer()</b>. Accessor methods that set values always return <b>self</b>.</font>

<p><font face="Times">Your class might not need to implement accessor methods if it has no need for client objects to set or retrieve the values of its objects' instance variables.</font>

<p><font face="Times"><b><sup>Defining Target/Action Behavior</sup></b></font><br>
<font face="Times">When you defined your class in Interface Builder, you specified certain methods (<i>actions</i>) that Control objects in the interface invoke in your object (the <i>target</i>) when an certain user event occurs. In implementing your class, you must specify the behavior of these methods. The sole argument of action methods is <b>sender</b>, the object sending the message.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- moveRecord:sender</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// move record to the index</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if ([recordList moveRecord:[recordList currentRecord]</font>

<p><img src="../../Images/sp.gif" width=120 height=1><font face="Courier" size="-1">to:<b>[sender intValue]</b>] == NO) {</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">NXBeep();</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">return nil;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// update the interface</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>[sender setStringValue:NULL];</b></font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[self fillForm];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[recordForm selectText:self];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> This code calls <b>sender</b>, which identifies the Control object sending the message, to get further information and to update the Control object. It also returns <b>nil</b> instead of <b>self</b> if a certain condition blocks the successful completion of the requested action.</font>

<p><font face="Times"><b><sup>Defining Initialization and Clean-up Behavior</sup></b></font><br>
<font face="Times">The Object class defines methods that subclasses must override to initialize their instances andto deinitialize them (clean up). These methods are invoked at the start and end of an object's life. Initialization sets the initial values of instance variables and dynamically allocates and initializes variables that are other objects or C types like <b>char *</b> strings. Deinitialization frees the memory allocated to these variables.</font>

<p><font face="Times">Subclasses of the Object class almost always need to override <b>init</b> and <b>free</b>. (An exception is a subclass of Object that has no instance variables; in this case, it can rely on Object's implementation of <b>init</b>, which simply returns <b>self</b>.) You can define other initialization methods for your class that take arguments and perform more specialized initializations. However, a subclass of Object must always implement <b>init</b>, even if <b>init</b> only invokes one of these specialized initializers, passing in a default value.</font>

<p><font face="Times"><b>Designated Initializer:</b>&nbsp; One of a subclass's initialization methods must be the <i>designated initializer</i>. The designated initializer invokes its superclass's designated initializer (in Object's case, <b>init</b>), performs most of the work, and returns <b>self</b>. The other initialization methods in a class eventually end up invoking the designated initializer.</font>

<p><font face="Times"><b>Invoking super's Initializer:</b>&nbsp; Since an object's full complement of attributes includes those instance variables declared and initialized by superclasses, initialization should cascade down the inheritance chain, starting with the Object class. This means that initialization should almost always <i>begin</i> with the invocation of the superclass's designated initializer. For the same reason, deinitialization should almost always <i>end</i> by invoking the superclass's <b>free</b> method<b>,</b> after freeing its own dynamically allocated instance variables. If your free method invokes <b>super</b>'s <b>free</b> first, the object will be deinitialized before it has had a chance to free its own allocated storage.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- init</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if (self = <b>[super init]</b>) {</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">locked = NO;</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">key = NULL;</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">contents = NULL;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>return self;</b></font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- free</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if (key) NX_FREE(key);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if (contents) NX_FREE(contents);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>return [super free];</b></font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> This example shows the <b>init</b> method (which is also the designated initializer in this case) starting off by sending <b>init</b> to <b>super</b> to have its superclass (Object) complete its initializations first. It then sets the object's instances variables to initial values and returns <b>self</b>. Until it returns <b>self</b>, the object is in an unusable state. If for some reason initialization fails, free the object (if it's non-<b>nil</b>) and return <b>nil</b>. In the example <b>init</b> method, the code verifies that the object returned from <b>[super init]</b> is not <b>nil</b> before proceeding with initialization. Exceptions typically are not raised in initialization methods (except for things like programmer errors).</font>

<p><br><br>

<p><font face="Times"><b>Initialization After Unarchiving:</b>&nbsp; The <b>init</b> method is invoked in an object once and only once, usually just after memory is allocated for it. Subsequently you can archive and unarchive the object. After your object is unarchived, the Object class sends it various messages, among them <b>awake</b>. You can implement <b>awake</b> to initialize any instance variables not initialized when the object was unarchived.</font>

<p><font face="Times">After all objects have been unarchived from a nib file and all outlets are set, the Object class sends <b>awakeFromNib</b> to each of those objects. You can implement <b>awakeFromNib</b> in your class to perform any initializations that require communication with outlet objects in the interface.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- awakeFromNib</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">fieldEditor = [[FieldEditor alloc] initFrame:NULL];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[[nameField window] makeKeyAndOrderFront:self];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[nameField selectText:self];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> In this implementation of <b>awakeFromNib</b>, the object must communicate through its outlet <b>nameField</b> with a field on the interface. It makes the window of this field key, orders it front, and selects the contents of the field. These initializations are done here and not in <b>init</b> because the connection between the objects must be unarchived from the nib file first.</font>

<p><font face="Times"><b><sup>Defining How Objects are Copied</sup></b></font><br>
<font face="Times">Object's default copying behavior is to create a new object exactly the same as the original--minus any referenced objects. So if the original object has instance variables that point to other objects, the pointers to those objects are copied to the new object but the objects themselves are not duplicated.</font>

<p><font face="Times">If you want objects of your class copied differently, you must override <b>copyFromZone:</b> (not <b>copy</b>, which merely calls <b>copyFromZone:</b> with the receiver's zone as argument). Allocate new instances of the pointed-to objects and initialize them with the values of the original objects.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- copyFromZone:(NXZone*)zone {</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">Customer *theCopy;</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">theCopy = [[Customer allocFromZone:zone] init];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setCustNo:custNo];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setName:name fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setCompany:company fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setAddress:address fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setState:state fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setCity:city fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setZip:zip fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setPhone:phone fromZone:zone];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">[theCopy setCreditLimit:creditLimit];</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">return theCopy;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b><sup>Defining How Objects are Compared</sup></b></font><br>
<font face="Times">A problem similar to copying objects is comparing objects. Object's default behavior, in the <b>isEqualTo:</b> method, is to compare the identifiers of objects (their <b>id</b>s). If the <b>id</b>s of the receiving and argument objects are equal, the objects are considered equal. You might find this behavior acceptable for instances of your class, but if you don't, override <b>isEqualTo:</b>.</font>

<p><font face="Times">Suppose you have a class named Color, and this class has one instance variable, an integer which holds an industry-accepted identifier of a color. What is important in demonstrating equality of objects in this case is not the equality of <b>id</b>s, but of the values of their color instance variables.</font>

<p><font face="Times"><b><sup>Implementing Archiving and Unarchiving</sup></b></font><br>
<font face="Times">When an object of your class has been around for awhile, responding to events and to messages from other objects, its state--the values of its instance variables--is likely to change. &quot;Off&quot; might change to &quot;on,&quot; true to false, red to green. When the user quits the application owning your object, you want to save the important parts of that object's state and then restore them the next time the application runs. This is called archiving.</font>

<p><font face="Times">You archive an object by indirectly invoking its <b>write:</b> method. Then, when the application starts up again, a <b>read:</b> message is sent to all objects, allowing them to unarchive themselves. In these methods you read from and write to a typed stream that is passed as an argument. A typed stream is a special kind of data stream that holds not only an object's data but information about the types of data, the class of the object, and (optionally) the version of the class.</font>

<p><font face="Times">Begin both your <b>write:</b> method by sending <b>write:</b> to <b>super</b>, requesting the superclass to archive its instance variables first. Similarly, begin your <b>read:</b> method by invoking super's <b>read:</b>. The invocation of <b>super</b>'s method should come first because data in the stream occurs in order of inheritance (superclass to subclass).</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- read:(NXTypedStream *)stream</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1"><b>[super read:stream];</b></font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">NXReadTypes(stream, &#34;i*******d&#34;,</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">&amp;custNo, &amp;name, &amp;company,</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">&amp;address, &amp;city, &amp;state,</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">&amp;zip, &amp;phone, &amp;creditLimit);</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- write:(NXTypedStream *)stream</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1"><b>[super write:stream];</b></font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">NXWriteTypes(stream, &#34;i*******d&#34;,</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">&amp;custNo, &amp;name, &amp;company,</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">&amp;address, &amp;city, &amp;state,</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">&amp;zip, &amp;phone, &amp;creditLimit);</font>

<p><img src="../../Images/sp.gif" width=50 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> This code example shows an integer, seven C strings, and a floating-point value being archived and unarchived. As the example shows, the <b>write:</b> and the <b>read:</b> methods should mirror each other in what they read and write. The data read from the stream should be exactly in the same order (by type) as the data that was written to the stream. Both methods should end by returning <b>self</b>.</font>

<p><font face="Times">NEXTSTEP provides several common and Application Kit functions to write data to and read data from a typed stream. Among these are <b>NXWriteType()</b>, <b>NXReadType()</b>, <b>NXWriteTypes()</b>, <b>NXReadTypes()</b>, <b>NXWritePoint()</b>, and <b>NXReadRect()</b>. You call the <b>NXWriteRootObject() </b>function to invoke a <b>write:</b> method and the <b>NXReadObject()</b> function to invoke a <b>read:</b> method. Never invoke <b>read:</b> or <b>write:</b> directly.</font>

<p><font face="Times">You don't need to archive every instance variable of your class. Some of these values you can re-create from scratch and others are transitory and hence unimportant (such as a seconds variable used for timing the period since a certain event). Kit objects configured in Interface Builder are automatically unarchived from their nib file, but only as you originally initialized them. If you want to retain some changed attribute of these objects, you should archive the attribute and then initialize the object with the unarchived attribute in the <b>awakeFromNib</b> method.</font>

<p><font face="Times"><b><sup>Implementing Special Behavior</sup></b></font><br>
<font face="Times">The final step in implementing a subclass of Object is to write the methods that are special to your class, that add its distinctive behavior. This step is all up to you. If you want examples that you can use as models, look in <b>/NextDeveloper/Examples</b>.</font>

<p><font face="Times" color="#006811">For more on typed streams, on typed-stream functions, and on the format-string characters used for specifying types, see Chapter 3, &quot;Common Classes and Functions&quot; in the <i>NEXTSTEP General Reference</i>.</font>

<p><font face="Times" color="#006811">If you're programming in the Enterprise Objects Framework and want to create a class for your enterprise objects or your own controller class, NeXT recommends that you subclass NSObject rather than Object. See the next task, &quot;Implementing a Subclass of NSObject,&quot; for details.</font>

<p><font face="Times" color="#006811">For more on the Object class, see Chapter 1 of the <i>NEXTSTEP General Reference.</i></font>

<p><font face="Times" color="#006811">The NEXTSTEP book <i>Object-Oriented Programming and the Objective C Language</i> describes in detail many topics related to the Object class and class creation.</font>

<p><font face="Times" color="#006811">For more on designated initializers, see the description of the <b>init</b> method in the Object class specification <i>(NEXTSTEP General Reference</i> or <i>Object-Oriented Programming and the Objective C Language)</i>.</font>

<p><font face="Times" color="#006811">For more information on what happens during object archiving and unarchiving, see <i>Object-Oriented Programming and the Objective C Language</i>. Also read the instructions for archiving and unarchiving objects on the following pages.</font>

<p><font face="Times" color="#006811">For more information on <b>awakeFromNib</b>, see the NXNibNotification protocol specification in Chapter 2 of the <i>NEXTSTEP General Reference</i>.</font>

<p><br><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3><br>
<font face="Helvetica"><b>Overriding Other Methods of the Object Class</b></font>

<p><font face="Times">You can obtain useful functionality by overriding Object methods other than the ones described so far in this task.</font>

<p><font face="Times"><b>printForDebugger:</b>&nbsp;&nbsp; Implement this method to write a descriptive debugging message to the stream provided in the argument. (Object's default action is to print the class name and the address of the receiver.) When a user issues the <b>po</b> command in <b>gdb</b>, <b>printForDebugger:</b> is invoked to display its message.</font>

<p><font face="Times"><b>finishUnarchiving</b>&nbsp;&nbsp; Implement this method to examine an unarchived object and, if necessary, replace it with another object.</font>

<p><font face="Times"><b>initialize</b>&nbsp;&nbsp; Implement this class method if you want to initialize your class before it receives its first message. This is a good place to set your class's version (<b>setVersion:</b>).</font>

<p><font face="Times"><b>forward:</b>&nbsp;&nbsp; Implement this method if you want to forward messages with unrecognized selectors to another object that can handle the message.</font>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3>

<p><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3><br>
<font face="Helvetica"><b>The Structure of Header Files and Implementation Files</b></font>

<p><font face="Helvetica" size="-1"><b>Header File</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Begin by importing header files for declaration types (<b>#import</b>).</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>@interface</b> begins class interface declaration. Class name precedes superclass, separated by a colon.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Put the declarations of instance variables within curly braces.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">After right curly brace declare your methods.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Action methods take the argument of <b>sender</b>.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">End class interface declaration with <b>@end</b>.</font></td></tr>

</table>

<p><br><br>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &lt;appkit/appkit.h&gt;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@interface Controller:Object</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id&nbsp; dateField;</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id&nbsp; nameField;</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id&nbsp; phoneField;</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id&nbsp; SSNField;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">id listing;</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">FieldEditor *fieldEditor;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- addRecord:sender;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- clearForm:sender;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- formAction:sender;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (BOOL)textWillEnd:textObject;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- windowWillReturnFieldEditor:sender toObject:client;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@end</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Helvetica" size="-1"><b>Implementation File</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Begin by importing relevant header files, especially the class header file.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>@implementaion</b> followed by class name begins implementation section.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Implement all methods.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">End implementation section with <b>@end</b>.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &#34;Controller.h&#34;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &#34;TextAppender.h&#34;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">#import &#34;FieldEditor.h&#34;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@implementation Controller</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- addRecord:sender</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// some code here</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (BOOL)textWillEnd:textObject</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return NO;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">// ...</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><img src="../../Images/F54.gif" width=580 height=10 vspace=3></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><font face="Helvetica"><b>IMPLEMENTING A SUBCLASS OF NSOBJECT</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Import header files.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Declare new instance variables.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Implement accessor methods.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define target/action behavior.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define initialization and deallocation behavior.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define how objects are copied.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define how objects are compared.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Implement archiving and unarchiving.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Define the special behavior of your class.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">The list of implementation steps recommended for subclasses of Object can apply almost unchanged to subclasses of NSObject. However, there are significant differences within some of the steps. These differences even start earlier, in the Classes display of the nib file window when you designate the superclass.</font>

<p><img src="ImplemNSObj1.gif" width=510 height=287>

<p><font face="Times">The remaining Interface Builder procedure is the same as for all non-View objects. You specify outlets and actions, make an instance of your class, and connect your object to other objects. Afterwards, generate code files and open those files up in a text editor (such as Edit). Then implement your subclass of NSObject.</font>

<p><font face="Times" size="-1"><b>Note:</b></font> <font face="Times">When you want to create an enterprise object class or a controller class for the Enterprise Objects Framework (EO Framework), you should subclass NSObject.</font>

<p><font face="Times"><b><sup>Coding Steps Identical With Subclasses of Object</sup></b></font><br>
<font face="Times">Some of the code you write when you create a subclass of NSObject follows the same guidelines as code written for a subclass of Object. See the appropriate section of the previous task, &quot;Implementing a Subclass of Object,&quot; for guidelines on:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Importing header files</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Declaring new instance variables</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Implementing accessor methods</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Defining target/action behavior</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Initializing instances of your class</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Defining how your objects are compared (<b>isEqualTo:</b>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b><sup>Defining Initialization and Deallocation Behavior</sup></b></font><br>
<font face="Times">The procedure for initializing instances of your class is the same for subclasses of NSObject as it is for subclasses of Object. In your implementation of <b>init</b> (or the <b>init..</b>. method that serves as designated initializer) invoke <b>super</b>'s <b>init</b> method, initialize instance variables, and then return <b>self</b>.</font>

<p><font face="Times">However, the way you deallocate instances of your class is different. For subclasses of NSObject, you must override <b>dealloc</b> rather than <b>free</b>. Similar rules apply, however: deallocate the memory allocated to instance variables and then invoke <b>super</b>'s <b>dealloc</b> method. This code fragment shows a <b>dealloc</b> method and the initialization and &quot;set&quot; accessor methods related to it:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (void)dealloc {</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>[title release];</b></font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super dealloc];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (void)setTitle:(NSString *)newImage</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[title autorelease];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">title = [newTitle retain];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (id)initWithTitle:(NSString *)newTitle</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super init];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[self setTitle:newTitle];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (id)init</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return [self initWithTitle:nil];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> The <b>dealloc</b> method mirrors the <b>init...</b> method where initialization actually takes place. This example releases the object <b>title</b>, and then invokes <b>super</b>'s <b>dealloc</b> method. Since <b>dealloc</b> is declared as returning <b>void</b>, there's no need to return.</font>

<p><font face="Times" color="#006811">The <b>release</b> message sent to <b>title</b> is Foundation's counterpart to <b>free</b>. The <b>release</b> message decrements an object's reference count and, if the count afterwards is zero, <b>dealloc</b> is invoked and the object is deallocated. (You should never send the message <b>free</b> to a Foundation type.) The implementation of the <b>setTitle:</b> method in this example sends <b>autorelease</b> to the old <b>title</b> object and <b>retain</b>s the new one. Before an instance of this NSObject subclass is destroyed, it deallocates <b>title </b>with <b>release</b>.</font>

<p><font face="Times"><b><sup>Defining How Objects Are Copied</sup></b></font><br>
<font face="Times">If you expect that objects of your class will be copied, adopt the NSCopying protocol; if you have a mutable version of your class, also adopt the NSMutableCopying protocol.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@interface MyClass : NSObject &lt;NSCopying, NSMutableCopying&gt;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Next implement the protocol methods, <b>copyWithZone:</b> and <b>mutableCopyWithZone:</b>. These are simple implementations of these methods:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (id)copyWithZone:(NSZone *)zone {</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return [[MyClass allocWithZone:zone] init];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (id)mutableCopyWithZone:(NSZone *)zone {</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return [[MyMutableClass allocWithZone:zone] init];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b><sup>Implementing Archiving and Unarchiving</sup></b></font><br>
<font face="Times">NSObject introduces a new mechanism for archiving and unarchiving objects that replaces the typed-stream approach of Object. This mechanism, implemented by the NSCoder, NSArchiver, and NSUnarchiver classes and the NSCoding protocol, encodes the objects of an application in a way that enhances their persistency and distributability. The repository of this encoded object information can be a file or an NSData object. You should archive any instance variables or other data critical to an object's state.</font>

<p><font face="Times">NSObject adopts the NSCoding protocol and so, by inheritance, all of its subclasses adopt it as well. Instances of these subclasses receive, at the appropriate times in their life cycles, a message requesting that they encode themselves and a message asking that they decode and initialize themselves. You implement two NSCoding methods to intercept these messages: <b>encodeWithCoder:</b> and <b>initWithCoder:</b>.</font>

<p><font face="Times">Your implementation of these methods is similar to Object's <b>write:</b> and <b>read:</b> methods, but there are significant differences too. Both <b>encodeWithCoder:</b> and <b>initWithCoder:</b> should begin by invoking the corresponding superclass method. The invocation of <b>super</b>'s <b>initWithCoder:</b> returns the partially initialized object (<b>self</b>). End <b>initWithCoder:</b> by returning <b>self</b>, but do not return in <b>encodeWithCoder:</b>.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (id)initWithCoder:(NSCoder *)coder</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">self = [super initWithCoder:coder];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">offsets = [coder decodeSize];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[coder decodeValuesOfObjCTypes:&#34;@@s&#34;, &amp;cell, &amp;view, &amp;flags];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (void)encodeWithCoder:(NSCoder *)coder</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super encodeWithCoder:coder];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[coder encodeSize:offsets];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[coder encodeValuesOfObjCTypes:&#34;@@s&#34;, &amp;cell, &amp;view, &amp;flags];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> NSCoder defines matching sets of methods for encoding and decoding objects of different types. In this example, <b>encodeValuesOfObjCTypes:</b> takes a format string consisting of the same type specifiers used by <b>NXWriteTypes()</b> (used in <b>read:</b>). Following this is a variable sequence of arguments, each of which is the address of a variable (usually instance variable). Note that the data, by type, must be decoded in the same sequence as it was encoded.</font>

<p><font face="Times">Just as <b>NXWriteRootObject()</b> initiates archiving in classes that inherit from Object by invoking <b>write:</b>, NSArchiver's <b>archiveRootObject:toFile:</b> initiates archiving in the NSObject world, invoking <b>encodeWithCoder:</b>. NSUnarchiver's <b>unarchiveObjectWithFile:</b> initiates unarchiving in NSObject instances by invoking <b>initWithCoder:</b> in them. Never invoke <b>encodeWithCoder:</b> or <b>initWithCoder:</b> directly.</font>

<p><font face="Times"><b><sup>Defining Special Behavior</sup></b></font><br>
<font face="Times">The final step in implementing a subclass of NSObject is writing the methods that are special to your class, those methods that give it its distinctive behavior. This step is all up to you. If you want examples that you can use as models, look in <b>/NextDeveloper/Examples</b>.</font>

<p><br><br>

<p><font face="Times" color="#006811">NSObject is the new root class for NEXTSTEP introduced by the Foundation Kit. The Object and NSObject classes coexist as root classes. They are very similar, but have significant differences. See &quot;A Class Hierarchy in Transition&quot; earlier in this chapter for background. For complete information on the NSObject class see the <i>Foundation Kit Reference</i>.</font>

<p><font face="Times" color="#006811">Remember, if you create a Foundation object (such as a instance of NSString) in your initialization code or elsewhere, you are responsible for its deallocation (with <b>autorelease</b> or <b>release</b>). If you create a Foundation object in an initialization method, the proper place for releasing it is in <b>dealloc</b>.</font>

<p><font face="Times" color="#006811">See &quot;Foundation's New Approach to Object Disposal&quot;in this chapter for some background. For complete details, read the introduction to <i>Foundation Kit Reference</i>.</font>

<p><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3><br>
<font face="Helvetica"><b>Other NSObject Methods You Could Override</b></font>

<p><font face="Times">There are several other NSObject methods that you might want to implement:</font>

<p><font face="Times"><b>description</b>&nbsp;&nbsp; Implement this method to return a descriptive debugging message as a string object. When a user, debugging with <b>gdb</b>, issues the <b>po</b> command, <b>gdb</b> displays your message.</font>

<p><font face="Times"><b>awakeAfterUsingCoder:</b>&nbsp;&nbsp; Implement this method to re-initialize the receiver, providing it one last chance to propose another object in its place.</font>

<p><font face="Times"><b>replacementObjectForCoder:</b>&nbsp;&nbsp; Implement this method to substitute another object for your object during encoding.</font>

<p><font face="Times"><b>initialize</b>&nbsp;&nbsp; Implement this class method if you want to initialize your class before it receives its first message. This is a good place to set the version of your class (<b>setVersion:</b>).</font>

<p><font face="Times"><b>forwardInvocation:</b>&nbsp;&nbsp; Implement this method if you want to forward messages with unrecognized selectors to another object that can handle the message.</font>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3>

<p><br><br><br>

<p><img src="../../Images/F53.gif" width=580 height=10 vspace=3>

<p><font face="Helvetica"><b>Foundation's New Approach to Object Disposal</b></font>

<p><font face="Times">The Foundation Kit introduces a policy that helps to ensure that objects are deallocated when they are no longer needed. The policy concerns object ownership; you conform to it by using an API that affects the mechanism behind object disposal: autorelease pools and reference counting.</font>

<p><font face="Helvetica" size="-1"><b><sup>Reference Counts, Autorelease Pools, and Deallocation</sup></b></font><br>
<font face="Times">Each object in Foundation has an associated reference count. When you create an object, its reference count is set at 1. You send <b>release</b> to an object to decrement its reference count. When the reference count reaches zero, NSObject invokes the object's <b>dealloc</b> method, and the object is destroyed. However, successive consumers of the object can delay its destruction by sending it <b>retain</b>, which increments the reference count. You retain objects to ensure that they won't be deallocated until you're done with them.</font>

<p><font face="Times">Each application has an autorelease pool to track objects marked for eventual release. You put an object in the pool by sending the object an <b>autorelease</b> message. When your code finishes executing and control returns to the application object (typically at the end of the event loop), the application object sends <b>release</b> to the autorelease pool, and the pool releases its contents. If afterwards the reference count of a pool object is zero, that object is deallocated.</font>

<p><font face="Helvetica" size="-1"><b><sup>Who Owns Which Object?</sup></b></font><br>
<font face="Times">The policy is quite simple: You should send <b>release</b> or <b>autorelease</b> only to objects that you own. The flip side of this statement is: <i>If you own an object, you are responsible for releasing it</i>. You</font><br>
<font face="Times">own objects that you create (that is, send <b>alloc</b> to) or that you copy. You also own (or share ownership in) objects that you send <b>retain</b> messages to, since <b>retain</b> increments an object's reference count.</font>

<p><font face="Times">You shouldn't release objects that you receive from other objects (unless you precede the <b>release</b> or <b>autorelease</b> with a <b>retain</b>). You don't own these objects, and can assume that their owner has seen to their eventual deallocation. You can also assume that a received object remains valid within the method it was received in. That method can also safely return the object to its invoker.</font>

<p><font face="Times">You should send <b>release</b> or <b>autorelease</b> to an object only as many times as are allowed by its creation (one) plus the number of <b>retain</b> messages you have sent it. You should never send <b>free</b> to a Foundation object.</font>

<p><font face="Helvetica" size="-1"><b><sup>Some Practical Implications</sup></b></font><br>
<font face="Times">In accessor methods that set instance variables of a Foundation type, you should send <b>autorelease</b> to the old object and then send <b>retain</b> or <b>copy</b> to the new one:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (void)setTitle:(NSString *)newImage</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[title autorelease];</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">title = [newTitle retain];</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Use <b>retain</b> in this context if you don't mind sharing the passed-in object with another object; use <b>copy</b> if you want your own private version of the object.</font>

<p><font face="Times">You should also use <b>retain</b> and <b>autorelease</b> to prevent an object from being invalidated as a normal side-effect of a message. For more on this topic (&quot;Validity of Shared Objects&quot;) and on the object-ownership policy in general, see &quot;Object Ownership and Automatic Disposal&quot; in the introduction to the <i>Foundation Kit Reference</i>.</font>

<p><img src="../../Images/F54.gif" width=580 height=10 vspace=3></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_Delegate"></a><font face="Helvetica"><b>MAKING YOUR CLASS A DELEGATE</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Connect your instance to an object that has delegates.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>Select the delegate outlet in the Connections inspector.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Click Connect.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">4</font></td>

<td><font face="Helvetica" size="-1"><b>Implement the delegate methods.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Several NEXTSTEP classes allow you to register an object as their delegate. As certain events occur, the kit objects send messages to their delegates, giving them the opportunity to participate in processing. In Interface Builder, you can easily designate your class's instance as a delegate.</font>

<p><img src="Delegate.gif" width=503 height=609>

<p><font face="Times">Next, implement the delegate methods you want your class to respond to. In this example, the object acting as delegate constrains the resizing of the window.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- windowWillResize:sender toSize:(NXSize *)frameSize;</font><br>
<img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">frameSize-&gt;width = MAX(frameSize-&gt;width,400.0);</font><br>
<img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">frameSize-&gt;height = MAX(frameSize-&gt;height,350.0);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">You can programmatically make any object in your application a delegate of another object (as long as that object specifies a delegate as an outlet) with the <b>setDelegate:</b> method.</font>

<p><font face="Times" color="#006811">Messages to delegates sometimes notify them of impending or just-transpired events, and sometimes request them to complete some work. Major classes with delegate methods are Application, Window, Text, and NXBrowser. See the <i>NEXTSTEP General Reference</i> for details on delegate methods.</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><font face="Helvetica"><b>ARCHIVING OBJECTS IN A MIXED WORLD</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>If your class inherits from NSObject and has Object instance variables, use special methods for archiving and unarchiving those variables.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>If your class inherits from Object and has NSObject instance variables, use special functions for archiving and unarchiving those variables.</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">In the dual root-class situation, you might have a class that inherits from one root class but that has some instance variables that inherit from the other root class. When it comes to archiving objects that inherit from Object along with objects that inherit from NSObject, there might seem to be a problem: Do you use the old approach to archiving (<b>write:</b>), or the new (<b>encodeWithCoder:</b>)?</font>

<p><font face="Times">As an example, consider these declarations:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">@interface Author:NSObject</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NSString *au_id;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // These descend from NSObject</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NSString *au_fname;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NSString *au_lname;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NSString *address;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NSString *city;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NSString *state;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">int contract;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Scalar type</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>List *titles;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Descends from Object</b></font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">The Author class descends from NSObject, but it has a List object (<b>titles</b>) as one of its instance variables. List inherits from the Object class, and List objects are thus supposed to be archived with the <b>NXWriteObject()</b> (or similar) function within the <b>write:</b> method.</font>

<p><font face="Times">This mix of archived object hierarchies makes compatibility with future releases of NEXTSTEP a problem. To get around this problem, NEXTSTEP provides some compatibility methods and functions for you to use when archiving and unarchiving in these situations.</font>

<p><font face="Times">If you have an NSObject sublcass with objects in its instance variables that inherit from the Object class, use the <b>encodeNXObject:</b> and <b>decodeNXObject</b> methods to archive and unarchive those objects.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- (void)encodeWithCoder:(NSCoder *)aCoder</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super encodeWithCoder:aCoder];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeObject:au_id];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeObject:au_fname];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeObject:au_lname];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeObject:address];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeObject:city];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeObject:state];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeValuesOfObjCTypes:&#34;i&#34;, &amp;contract];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aCoder encodeNXObject:titles];</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- initWithCoder:(NSCoder *)aDecoder</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super initWithCoder:aDecoder];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">au_id&nbsp;&nbsp;&nbsp; = [[aDecoder decodeObject] retain];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">au_fname = [[aDecoder decodeObject] retain];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">au_lname = [[aDecoder decodeObject] retain];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">address&nbsp; = [[aDecoder decodeObject] retain];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">city&nbsp;&nbsp;&nbsp;&nbsp; = [[aDecoder decodeObject] retain];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">state&nbsp;&nbsp;&nbsp; = [[aDecoder decodeObject] retain];;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[aDecoder decodeValuesOfObjCTypes:&#34;i&#34;, &amp;contract];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>titles =&nbsp;&nbsp; [aDecoder decodeNXObject];</b></font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">What about the opposite case? You create a class that inherits from Object, and declare some instance variables that are instances of NSObject or one of its subclasses. In these situations, use the <b>NXWriteNSObject()</b> and <b>NXReadNSObject()</b> functions within the <b>write:</b> and <b>read:</b> methods, respectively.</font>

<p><font face="Times">Assuming the previous declarations of instance variables are now made for a class that inherits from Object, the archiving and unarchiving methods would look like this example.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- write:(NXTypedStream *)stream;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super write:stream];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>NXWriteNSObject(stream, au_id);</b></font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteNSObject(stream, au_fname);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteNSObject(stream, au_lname);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteNSObject(stream, address);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteNSObject(stream, city);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteNSObject(stream, state);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteType(stream, &#34;i&#34;, &amp;contract);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXWriteObject(stream, titles);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- read:(NXTypedStream *)stream;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[super read:stream];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">au_id&nbsp;&nbsp;&nbsp; = (NSString *)NXReadNSObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">au_fname = (NSString *)NXReadNSObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">au_lname = (NSString *)NXReadNSObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">address&nbsp; = (NSString *)NXReadNSObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">city&nbsp;&nbsp;&nbsp;&nbsp; = (NSString *)NXReadNSObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">state&nbsp;&nbsp;&nbsp; = (NSString *)NXReadNSObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXReadType(stream, &#34;i&#34;, &amp;contract);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">titles&nbsp;&nbsp; = NXReadObject(stream);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">There are some caveats on this method of archiving a &quot;mixed world&quot; of objects inheriting from different root classes:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">There is no sharing of information between the worlds. This is an important fact when you have complex graphs with cycles or multiple references to the same object. While NEXSTEP tracks this information within a single world, it doesn't when you mix objects of the different worlds. So avoid graphs of objects with cycles.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Container objects can't contain objects from the other world when they're archived. An NSArray object, for instance, can't contain any objects inheriting from Object and a List object can't hold any instance of NSObject or its subclasses.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Pre-existing archives of objects, all of which inherit from Object, and new archives of objects that all inherit from NSObject are forward compatible.</font>

<p><font face="Times" color="#006811">The compatability methods and functions (<b>encodeNXObject</b>:, <b>decodeNXObject</b>, <b>NXWriteNSObject()</b>, and <b>NXReadNSObjct()</b>) are declared in NSArchiver.h.</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><a name="IB4_ImplViewClass"></a><font face="Helvetica"><b>IMPLEMENTING A VIEW SUBCLASS</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">1</font></td>

<td><font face="Helvetica" size="-1"><b>Identify the class and its outlets and actions.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">2</font></td>

<td><font face="Helvetica" size="-1"><b>Place and resize a CustomView object on a window or panel.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">3</font></td>

<td><font face="Helvetica" size="-1"><b>Assign your class as the class of the CustomView.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">4</font></td>

<td><font face="Helvetica" size="-1"><b>Connect the instance to other objects in the interface</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">5</font></td>

<td><font face="Helvetica" size="-1"><b>Generate code files.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">6</font></td>

<td><font face="Helvetica" size="-1"><b>Complete programming tasks necessary for any object.</b></font></td></tr>

<tr valign=top>

<td width=35 height=15></td></tr>

<tr valign=top>

<td width=35></td>

<td nowrap><font face="Helvetica" size="-1">7</font></td>

<td><font face="Helvetica" size="-1"><b>Complete programming tasks specific to View objects:</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Initialize a View object.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Draw a View object.</b></font></td></tr>

<tr valign=top>

<td width=21 height=15></td></tr>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>If necessary, handle events.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Making a subclass of the View class is a procedure that differs from making a subclass of the Object class. But it starts out the same. In the Classes display of Interface Builder, choose Subclass from the Operations menu while View is highlighted in the browser. Then name your class and add outlets and actions.</font>

<p><img src="ImplemView.gif" width=356 height=240>

<p><font face="Times" size="-1"><b>Note:</b></font> <font face="Times">The steps in this task, insofar as they apply to View, also apply to creating classes that inherit from subclasses of View.</font>

<p><font face="Times"><b><sup>Making an Instance of a View Subclass</sup></b></font><br>
<font face="Times">Place a proxy instance of your class on your interface. Interface Builder provides a CustomView object to represent instances of View subclasses.</font>

<p><img src="ImplemView1.gif" width=513 height=422>

<p><font face="Times">Position and resize the CustomView object, and, while it's still selected, bring up the Attributes display of the Inspector panel. Assign a class name to the object; this creates an instance of your View subclass.</font>

<p><img src="ImplemView2.gif" width=463 height=310>

<p><font face="Times">The next three steps that you must complete are the same tasks that follow the instantiation of Object subclasses:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Connect the instance to other objects in the interface (&quot;Connecting Your Class's Outlets&quot; and &quot;Connecting Your Class's Actions&quot;). But now the instance appears as part of the interface, and not as an icon in the Instances display of the nib file window.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Generate code files and have them inserted in your project (&quot;Generating Source Code Files&quot;).</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Switch over to the project in Project Builder that contains the nib file. Open your class's code files in Edit.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">Since View inherits from Object, next complete some of the same programming tasks recommended for subclasses of Object:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Declaring new instance variables</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Implementing accessor methods</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Implementing target/action methods</font></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Archiving and unarchiving</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">To create a functional subclass of View, you must complete two additional steps (and might want to complete another), which are described on the following pages.</font>

<p><br><br>

<p><font face="Times"><b><sup>Initializing View Objects</sup></b></font><br>
<font face="Times">Every subclass of View must override <b>initFrame:</b> instead of <b>init</b>. In <b>initFrame:</b> (View's designated initializer) you initialize a just-allocated instance of your class, setting its attributes to an initial state. The method's sole argument is the rectangle in which drawing is to occur (usually the frame of the view).</font>

<p><font face="Times">In this example, <b>initFrame:</b> initializes instance variables of varying types and performs other housekeeping chores.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- initFrame:(const NXRect *)frameRect</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>[super initFrame:frameRect];</b></font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">face = [[NXImage allocFromZone:[self zone]]</font>

<p><img src="../../Images/sp.gif" width=127 height=1><font face="Courier" size="-1">initSize:&amp;bounds.size];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[face useDrawMethod:@selector(drawFace:) inObject:self];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">littleFont = [Font newFont:&#34;Helvetica&#34; size:12 style:0</font>

<p><img src="../../Images/sp.gif" width=155 height=1><font face="Courier" size="-1">matrix:NX_IDENTITYMATRIX];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">mediumFont = [Font newFont:&#34;Times-Roman&#34; size:14 style:0</font>

<p><img src="../../Images/sp.gif" width=155 height=1><font face="Courier" size="-1">matrix:NX_IDENTITYMATRIX];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">bigFont = [Font newFont:&#34;Times-Roman&#34; size:24 style:0</font>

<p><img src="../../Images/sp.gif" width=134 height=1><font face="Courier" size="-1">matrix:NX_IDENTITYMATRIX];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">/* Set the default state (analog face, no seconds, date on) */</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">clockType = ANALOG;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">showSeconds = NO;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">showDate = YES;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">center.x = bounds.size.width/2.0;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">center.y = bounds.size.height/2.0 + [mediumFont pointSize]/2.0;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">radius = MIN(center.x,center.y-[mediumFont pointSize]);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[face recache];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// Start the time entry. YES indicates that this is the 1st time</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[self startTimedEntry:YES];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>[self display];</b></font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1"><b>return self;</b></font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> The implementation of an <b>initFrame:</b> method begins by invoking <b>super</b>'s <b>initFrame:</b> method, ends by returning <b>self</b>, and in between sets the instance variables to initial values. Often the attributes set have a visual aspect, and affect how the view is drawn. For instance, the face outlet variable binds an image (the gauge face) to the view. Near the end of the method is <b>[display self]</b>; this invokes the view's <b>drawSelf::</b> method, forcing it to draw itself.</font>

<p><font face="Times">As with Object subclasses, you might have to implement the <b>free</b> method to free dynamically allocated storage.</font>

<p><font face="Times"><b><sup>Drawing View Objects</sup></b></font><br>
<font face="Times">A View object draws itself with the <b>drawSelf::</b> method. To invoke <b>drawSelf::</b>, another object must send <b>display</b> (or one of <b>display</b>'s variants) to the View object. The <b>drawSelf::</b> method is also invoked automatically when windows are resized and exposed, when Views are scrolled, and when similar events happen.</font>

<p><font face="Times">The two arguments passed to <b>drawSelf::</b> indicate how much of the View needs to be drawn. The first argument is a pointer to an array of rectangles and the second argument indicates how many rectangles are in the array (always one or three). If there's one rectangle in the array, that rectangle defines the drawing area. If there are three rectangles, the first rectangle is the union of the second and third--that is, it's the smallest rectangle that completely encloses the other two.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- drawSelf:(NXRect *)drawRects :(int)rectCount</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if (needRedraw)</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">[self drawFace];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">PScomposite(0.0, 0.0, bounds.size.width, bounds.size.height,</font>

<p><img src="../../Images/sp.gif" width=120 height=1><font face="Courier" size="-1">[cacheWindow gState], 0.0, 0.0, NX_COPY);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[self drawHand];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">// Calculates the angle for current value, draws hand there.</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- drawHand</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">float valueAngle;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">valueAngle = startAngle - degreesPerUnit*(value-minValue);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">PSWdrawHand(center.x,center.y,valueAngle);</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" color="#006811"><b>Notes on the code:</b> The example above shows <b>drawSelf::</b> and an auxiliary drawing method (<b>drawHand</b>). You might also want several drawing methods to draw parts of the View based on certain conditions. In this scenario <b>drawSelf::</b> acts as kind of a dispatch center, evaluating for conditions and then invoking the appropriate auxiliary method.</font>

<p><font face="Times">In implementing <b>drawSelf:</b>:, write whatever code helps to draw your View. You can call <b>pswrap</b>-generated functions to send PostScript code to the Window Server. You can send messages to bitmap objects, requesting them to composite source images stored in off-screen windows. You can change font styles and text colors. If your View uses a Cell to do any of its drawing, you can send <b>drawSelf:inView:</b> or <b>drawInside:inView:</b> to the Cell within <b>drawSelf::</b>.</font>

<p><font face="Times">The <b>drawSelf::</b> method defines a View's static appearance on the screen. Your subclass can also add other methods for dynamic drawing in response to user events. In these methods you might highlight the View, drag it from one place to another, or animate it. The Application Kit locks focus automatically when <b>drawSelf::</b> is invoked. In dynamic-drawing contexts you must lock and unlock focus yourself when drawing.</font>

<p><font face="Times">If you want your view to respond to mouse clicks, key presses, or other user events, you must do at least two things:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Re-implement View's <b>acceptsFirstResponder</b> method to return YES.</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Decide which event types you want to respond to and implement the appropriate methods: <b>mouseUp:</b>, <b>mouseDown:</b>, <b>keyDown:</b>, <b>mouseEntered:</b>, and so on.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">The event methods are defined in the Responder class, where the default implementation is to forward the event message to the next responder.</font>

<p><font face="Times">When it invokes an event method, the input system passes in a pointer to an NXEvent data structure. This structure holds details related to the event: the type of event, the mouse's location (in the window's base coordinates), the window number, a time value associated with the event, flags indicating modifier keys and mouse buttons, and supplementary data.</font>

<p><font face="Times">You can find or derive much of the information required for handling an event in the NXEvent parameter. For instance, you can convert the NXEvent mouse location to your View's base coordinate system with <b>convertPoint:fromView:</b>.</font>

<p><font face="Times">You can check for modifier keys or mouse buttons using the keyboard-state flags masks. You can also modify the window's event mask temporarily and handle a known or probable sequence of events.</font>

<p><font face="Times">The following example illustrates several of these techniques.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">- mouseDown:(NXEvent *)event</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">{</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXPoint pt;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">NXRect dirty;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// modify event mask</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">int emask=[window addToEventMask:(NX_MOUSEUPMASK |</font>

<p><img src="../../Images/sp.gif" width=302 height=1><font face="Courier" size="-1">NX_MOUSEDRAGGEDMASK)];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if( ! [backingImage lockFocus] ) return self;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// convert mouse click to local coordinate system</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">pt = event-&gt;location;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[self convertPoint: &amp;pt fromView: nil];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">pt.x += .5; pt.y += .5;</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[brush brushMoveTo: pt.x : pt.y</font>

<p><img src="../../Images/sp.gif" width=162 height=1><font face="Courier" size="-1">withPressure: event-&gt;data.mouse.pressure/255.0</font>

<p><img src="../../Images/sp.gif" width=162 height=1><font face="Courier" size="-1">dirtyRect: &amp;dirty];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[self display: &amp;dirty : 1];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">// handle anticipated events</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">while(1) {</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">event=[NXApp getNextEvent:(NX_MOUSEUPMASK</font>

<p><img src="../../Images/sp.gif" width=246 height=1><font face="Courier" size="-1">| NX_MOUSEDRAGGEDMASK)];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">if(event-&gt;type == NX_MOUSEUP)</font>

<p><img src="../../Images/sp.gif" width=120 height=1><font face="Courier" size="-1">break;</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">pt = event-&gt;location;</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">[self convertPoint: &amp;pt fromView: nil];</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">pt.x += .5; pt.y += .5;</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">[brush brushLineTo: pt.x : pt.y</font>

<p><img src="../../Images/sp.gif" width=162 height=1><font face="Courier" size="-1">withPressure:event-&gt;data.mouse.pressure/255.0</font>

<p><img src="../../Images/sp.gif" width=162 height=1><font face="Courier" size="-1">dirtyRect: &amp;dirty];</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">[self display: &amp;dirty : 1];</font>

<p><img src="../../Images/sp.gif" width=92 height=1><font face="Courier" size="-1">NXPing();&nbsp;&nbsp; // wait for the window server to catch up</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[backingImage unlockFocus];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">[window setEventMask:emask];</font>

<p><img src="../../Images/sp.gif" width=64 height=1><font face="Courier" size="-1">return self;</font>

<p><img src="../../Images/sp.gif" width=36 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">If you want your View to handle target/action messages sent to the First Responder (for example, copy and paste), be sure to override <b>acceptsFirstResponder</b> to return YES, and then implement the appropriate method <b>(copy:</b> and <b>paste:</b>).</font>

<p><font face="Times" color="#006811">The View class offers your subclass a wealth of inherent functionality. It includes methods for managing the view hierarchy, for converting coordinates and modifying the coordinate system, for managing cursors and events, and for focusing, clipping, scrolling, dragging, and printing. See the description of the View class in Chapter 2 of the <i>NEXTSTEP General Reference</i>.</font>

<p><font face="Times" color="#006811">The PostScript functions and operators available for use are described in Chapter 5, &quot;DisplayPostScript,&quot; of the <i>NEXTSTEP General Reference</i>.</font>

<p><font face="Times" color="#006811"><b>pswrap</b> is a program that creates a C function to correspond to a sequence of PostScript code. Note that your custom pswrap code (extension <b>.psw</b>) must go in the Other Sources suitcase of Project Builder. <b>pswrap</b> is described in detail in Adobe Systems' <i>pswrap Reference Manual</i>.</font>

<p><font face="Times" color="#006811">The NXEvent data structure and related data structures, constants, and flag masks are declared in <b>dpsclient/event.h</b>, and are described in Chapter 5 of the <i>NEXTSTEP General Reference</i> under &quot;Types and Constants.&quot;</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><font face="Helvetica"><b>ADDING EXISTING CLASSES TO YOUR NIB FILE</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Drag the header file from the File Viewer or Project Builder into the nib file window.</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Helvetica" size="-1"><i>Or</i></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Copy a class in one nib file and paste it in another.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">The easiest way to add a class to your nib file is to drag the header file for an existing custom class from the Workspace Manager's File Viewer into Interface Builder.</font>

<p><img src="AddClass1.gif" width=517 height=491>

<p><font face="Times">You can also add a class definition to a nib file by dragging a header or implementation file from Project Builder into a nib file window.</font>

<p><font face="Times">The new class appears in the Classes display under its subclass and with its outlets and actions defined. After adding the class, you must still connect it to other objects through its outlets and actions. To do this, complete these steps:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Make an instance of the class (for View subclasses, that means assigning your class name to the CustomView object).</font></td></tr>

<tr valign=top>

<td width=36 height=8></td></tr>

<tr valign=top>

<td width=36></td>

<td nowrap><font face="Times"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Connect the instance's outlets and actions to other objects in the nib file.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">Instead of defining a class in Interface Builder, you can write a header file and drag it into a nib file window (as described above). When writing your header file, be sure to declare outlets as instance variables of type <b>id</b>. Declare actions as methods with a single argument: <b>sender</b>.</font>

<p><font face="Times"><b><sup>Copying Classes Between Nib Files</sup></b></font><br>
<font face="Times">You can copy class definitions between nib files, in the same or different projects, by copying a class in one nib file and pasting it into another nib file.</font>

<p><img src="AddClass2.gif" width=529 height=464>

<p><font face="Times">A duplicate of the original class appears in the Classes display of the destination nib file. Generate an instance of the class in the destination nib file and connect it to other objects in the nib file through its outlets and actions.</font>

<p><font face="Times" color="#006811">If you are going to write a header file and then drag the file into Interface Builder, follow the conventions for header files described in &quot;The Structure of Header Files and Implementation Files,&quot; earlier in this chapter.</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=9></td>

<td><font face="Helvetica"><b>UPDATING A CLASS DEFINITION</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=21></td>

<td width=29><img src="../../Images/F55.gif" width=23 height=7 vspace=3></td>

<td><font face="Helvetica" size="-1"><b>Choose the Parse command and select a header file in the Open Panel.</b></font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times">If you later add outlets and actions to the header file, or delete them from it, Interface Builder allows you to update the nib file with this new information.</font>

<p><img src="UpdateClass1.gif" width=510 height=289>

<p><font face="Times">Interface Builder brings up an Open panel for you to confirm (or select) the class definition to update.</font>

<p><img src="UpdateClass2.gif" width=496 height=311>

<p><font face="Times">If there are any new outlets and actions, remember to connect these outlets and actions to other objects in the nib file.</font>

<p><font face="Times" size="-1"><b>Tip:</b></font> <font face="Times">You can also use the Parse command to add an existing class to a nib file, or you create a header file and read it into a nib file through the Parse command.</font></td></tr>

</table>



<p><br>

</body>
</html>
