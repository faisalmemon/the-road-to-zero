<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/GeneralRef/02_ApplicationKit/Functions/AppKitFunctions.rtfd -->
<!-- Date: Sun Jun 28 20:02:50 1998 -->
<head>
<title>AppKitFunctions</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXAlphaComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXAttachPopUpList(), NXCreatePopUpListButton()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set up a pop-up list</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/PopUpList.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXAttachPopUpList(</b>id <i>button</i>, PopUpList *<i>popUpList</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">id <b>NXCreatePopUpListButton(</b>PopUpList *<i>popUpList</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions make it easy to use the PopUpList class.&nbsp; <b>NXCreatePopUpListButton()</b> returns a new Button object that will activate the pop-up list specified by <i>popUpList</i>.&nbsp; The new Button must then be added to the View hierarchy with View's <b>addSubview:</b> method.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXAttachPopUpList()</b> modifies <i>button</i> so that it activates <i>popUpList</i>.&nbsp; In addition, if <i>button</i> already has a target and an action, then they are used whenever a selection is made from the pop-up list.&nbsp; <i>button</i> must be either a Control that uses ButtonCell (or a subclass) as its Cell class, or an actual ButtonCell.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXCreatePopUpListButton()</b> returns a new Button object.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXBeep()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Play the system beep</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/publicWraps.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXBeep(</b>void<b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function plays the system beep.&nbsp; Users can select a sound to be played as the system beep through the Preferences application.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXBeginTimer(), NXEndTimer()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set up timer events</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/timer.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXTrackingTimer *<b>NXBeginTimer(</b>NXTrackingTimer *<i>timer</i>, double <i>delay</i>, double <i>period</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXEndTimer(</b>NXTrackingTimer *<i>timer</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions start up and end a timed entry that puts timer events in the event queue at specified intervals.&nbsp; They ensure that the modal event loop will get a stream of events even if none are being generated by the Window Server.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXBeginTimer()</b>'s <i>delay</i> argument specifies the number of seconds after which timer events will begin to be added to the event queue; an event will then be added every <i>period</i> seconds.&nbsp; The first argument, <i>timer</i>, is a pointer to an NXTrackingTimer structure, which is defined in the header file <b>appkit/timer.h</b>.&nbsp; You don't have to initialize this argument.&nbsp; If you pass a NULL pointer, memory will be allocated for the structure.&nbsp; Since timer events are usually needed only within a modal event loop, it's generally better to declare the structure as a local variable on the stack.</font>

<p><font face="Times"><b>NXEndTimer()</b> stops the flow of timer events.&nbsp; Its argument should be a pointer to the NXTrackingTimer structure used by <b>NXBeginTimer()</b>.&nbsp; If memory had been allocated for the structure, <b>NXEndTimer()</b> frees it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXBeginTimer()</b> returns a pointer to the NXTrackingTimer structure it uses.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXBlackComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXBlueComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXBPSFromDepth()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXColorSpaceFromDepth()</b></font>

<p><font face="Helvetica"><b>NXBrightnessComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeAlphaComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeBlackComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeBlueComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeBrightnessComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeCyanComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeGrayComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeGreenComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeHueComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeMagentaComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXChangeRedComponent(), NXChangeGreenComponent(), NXChangeBlueComponent(), NXChangeCyanComponent(), NXChangeMagentaComponent(), NXChangeYellowComponent(), NXChangeBlackComponent(), NXChangeHueComponent(), NXChangeSaturationComponent(), NXChangeBrightnessComponent(), NXChangeGrayComponent(), NXChangeAlphaComponent()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Modify a color by changing one of its components</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXColor <b>NXChangeRedComponent(</b>NXColor <i>color</i>, float <i>red</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXColor <b>NXChangeGreenComponent(</b>NXColor <i>color</i>, float <i>green</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeBlueComponent(</b>NXColor <i>color</i>, float <i>blue</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeCyanComponent(</b>NXColor <i>color</i>, float <i>cyan</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeMagentaComponent(</b>NXColor <i>color</i>, float <i>magenta</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeYellowComponent(</b>NXColor <i>color</i>, float <i>yellow</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeBlackComponent(</b>NXColor <i>color</i>, float <i>black</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeHueComponent(</b>NXColor <i>color</i>, float <i>hue</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeSaturationComponent(</b>NXColor <i>color</i>, float <i>saturation</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeBrightnessComponent(</b>NXColor <i>color</i>, float <i>brightness</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeGrayComponent(</b>NXColor <i>color</i>, float <i>gray</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXChangeAlphaComponent(</b>NXColor <i>color</i>, float <i>alpha</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions alter one component of a color value and return the new color.&nbsp; The first argument, <i>color</i>, is the color to be altered and the second argument is the new value for the altered component.&nbsp; For example, the code below specifies a color with a greater red content than the standard brown:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXColor redBrown = NXChangeRedComponent(NX_COLORBROWN, 0.9);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Note that the <i>color</i> argument is used as a reference for creating a new color value; it is not itself changed.</font>

<p><font face="Times">Values passed for the altered component should lie between 0.0 and 1.0; out-of-range values will be lowered to 1.0 or raised to 0.0.&nbsp; NX_NOALPHA can be passed to <b>NXChangeAlphaComponent()</b> to remove any specification of coverage from the color.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">These functions return an NXColor structure that, except for the altered component, represents a color identical to the one passed as an argument.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXRedComponent()</b>, <b>NXSetColor()</b>, <b>NXConvertRGBAToColor()</b>, <b>NXConvertColorToRGBA()</b>, <b>NXEqualColor()</b>, <b>NXReadColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXChangeSaturationComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChangeYellowComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChangeRedComponent()</b></font>

<p><font face="Helvetica"><b>NXChunkCopy()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font>

<p><font face="Helvetica"><b>NXChunkGrow()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXChunkMalloc(), NXChunkRealloc(), NXChunkGrow(), NXChunkCopy(), NXChunkZoneMalloc(), NXChunkZoneRealloc(), NXChunkZoneGrow(), NXChunkZoneCopy()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Manage variable-sized arrays of records</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/chunk.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXChunk *<b>NXChunkMalloc(</b>int <i>growBy</i>, int <i>initUsed</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXChunk *<b>NXChunkRealloc(</b>NXChunk *<i>pc</i><b>)</b></font><br>
<font face="Times">NXChunk *<b>NXChunkGrow(</b>NXChunk *<i>pc</i>, int <i>newUsed</i><b>)</b></font><br>
<font face="Times">NXChunk *<b>NXChunkCopy(</b>NXChunk *<i>pc</i>, NXChunk *<i>dpc</i><b>)</b></font><br>
<font face="Times">NXChunk *<b>NXChunkZoneMalloc(</b>int <i>growBy</i>, int <i>initUsed</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times">NXChunk *<b>NXChunkZoneRealloc(</b>NXChunk *<i>pc</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times">NXChunk *<b>NXChunkZoneGrow(</b>NXChunk *<i>pc</i>, int <i>newUsed</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times">NXChunk *<b>NXChunkZoneCopy(</b>NXChunk *<i>pc</i>, NXChunk *<i>dpc</i>, NXZone *<i>zone</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">A Text object uses these functions to manage variable-sized arrays of records.&nbsp; For general storage management, use objects of the Storage or List class.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">These functions are paired (for example, <b>NXChunkZoneMalloc()</b> and <b>NXChunkMalloc()</b>):&nbsp; One function lets you specify a zone and one doesn't.&nbsp; Those functions that don't take a zone argument operate within the default zone, as returned by <b>NXDefaultMallocZone()</b>.&nbsp; In all other respects, the two types of functions are identical.&nbsp; In the following discussion, statements concerning one member of a function pair apply equally well to the other member.</font>

<p><font face="Times">Arrays that are managed by these functions must have as their first element an NXChunk structure, as defined in <b>appkit/chunk.h</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct _NXChunk {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">short&nbsp; growby;&nbsp;&nbsp;&nbsp;&nbsp; /* Increment to grow by */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; allocated;&nbsp; /* Number of bytes allocated */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; used;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Number of bytes used */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} NXChunk;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For example, assuming an <b>account</b> structure has been declared, an <b>accountArray</b> structure is declared as:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct _accountArray {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXChunk&nbsp; chunk;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">account&nbsp; record[1];</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} accountArray;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The NXChunk structure stores three values:&nbsp; <b>growby</b> specifies how many additional bytes of storage will be allocated when <b>NXChunkRealloc()</b> is called; <b>allocated</b> stores the number of bytes currently allocated for the array; and <b>used</b> stores the number of bytes currently used by the array's elements.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The values recorded in the NXChunk element don't take into account the size of the NXChunk element itself.&nbsp; However, the functions described here preserve space for this element.&nbsp; You don't need to take into account the size of the array's NXChunk when using these functions.</font>

<p><font face="Times">Use <b>NXChunkMalloc()</b> to initially allocate memory for the array.&nbsp; The amount of memory allocated is equal to <i>initUsed</i>.&nbsp; If <i>initUsed</i> is 0, <i>growby</i> bytes are allocated.&nbsp; The array's NXChunk element records the value of <i>growby</i> and the amount of memory allocated for the array.</font>

<p><font face="Times"><b>NXChunkRealloc()</b> increases the amount of memory available for the array identified by the pointer <i>pc</i>.&nbsp; The amount of memory allocated depends on the value of the <b>growby</b> member of the array's NXChunk element.&nbsp; If the value is 0, the space for elements is doubled; otherwise the array's size increases by <b>growby</b> bytes.&nbsp; The <b>allocated</b> member of the array's NXChunk element stores the new size of the array.</font>

<p><font face="Times"><b>NXChunkGrow()</b> increases the size of the array identified by the pointer <i>pc</i> by a specific amount.&nbsp; The <i>newUsed</i> argument specifies the array's new size in bytes.&nbsp; If the <b>growby</b> member of the array's NXChunk element is 0, the array grows to the size specified by <i>newUsed</i>.&nbsp; Otherwise, the array grows to the larger of <b>growby</b> and <i>newUsed</i>.&nbsp; In either case, the size of the array changes only if the new size is larger than the old one.</font>

<p><font face="Times"><b>NXChunkCopy()</b> copies the array identified by the pointer <i>pc</i> to the array identified by the pointer <i>dpc</i> and returns a pointer to the copy.&nbsp; Since the new array may be relocated in memory, the returned pointer may be different than <i>dpc</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Each function returns a pointer to an array's NXChunk element.&nbsp; <b>NXChunkMalloc()</b> returns a pointer to the newly allocated array, <b>NXChunkRealloc()</b> and <b>NXChunkGrow()</b> return pointers to the resized arrays, and <b>NXChunkCopy()</b> returns a pointer to the copy of the array.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXChunkRealloc()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font>

<p><font face="Helvetica"><b>NXChunkZoneCopy()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font>

<p><font face="Helvetica"><b>NXChunkZoneGrow()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font>

<p><font face="Helvetica"><b>NXChunkZoneMalloc()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font>

<p><font face="Helvetica"><b>NXChunkZoneRealloc()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXChunkMalloc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXColorListName(), NXColorName(), NXFindColorNamed()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Associate colors with their names and their color lists</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">const char *<b>NXColorListName (</b>NXColor <i>color</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">const char *<b>NXColorName (</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">BOOL <b>NXFindColorNamed (</b>const char *<i>colorList</i>, const char *<i>colorName</i>, NXColor *<i>color</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Use these functions to access named colors and named color lists.&nbsp; They're used in conjunction with objects of the NXColorList class that generate colors with persistent names.&nbsp; The documentation for NXColorList includes a complete description of persistent color names and named NXColorLists.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXColorListName()</b> looks for and returns the name of a color list from which a particular color was taken.&nbsp; <i>color</i> represents the NXColor whose source list name you're seeking.&nbsp; The return value is a character string representing the name of the list from which the color was taken; an empty string is returned if <i>color</i> isn't taken from a named list.&nbsp; This function can be used to get the argument for NXColorList's <b>findColorListNamed:</b> method.</font>

<p><font face="Times"><b>NXColorName()</b> returns the persistent name of a color.&nbsp; <i>color</i> is the NXColor whose persistent name you wish to find.</font>

<p><font face="Times"><b>NXFindColorNamed()</b> returns by reference the NXColor associated with a particular name in a particular list.&nbsp; <i>colorList </i>represents the name of the list in which you wish to search; if <i>colorList</i> doesn't represent a NXColorList that generates colors with persistent names, this method returns NO.&nbsp; <i>colorName</i> represents the name of the color you wish to find.&nbsp; <i>color</i> returns the actual NXColor associated with <i>colorName</i> in <i>colorList</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXColorListName()</b> returns a character string representing the name of the list from which the color was taken; an empty string is returned if the color isn't taken from a named list.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXColorName()</b> returns a character string representing the name of <i>color</i>: an empty string is returned if <i>color</i> wasn't taken from a list that generates colors with persistent names.</font>

<p><font face="Times"><b>NXFindColorNamed()</b> returns YES if it finds <i>colorName</i> in <i>colorList</i>, NO if not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times">NXColorList class</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXColorName()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXColorListName()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXColorSpaceFromDepth(), NXBPSFromDepth(), NXNumberOfColorComponents(), NXGetBestDepth()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about color space and window depth</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXColorSpace <b>NXColorSpaceFromDepth(</b>NXWindowDepth <i>depth</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>NXBPSFromDepth(</b>NXWindowDepth <i>depth</i><b>)</b></font><br>
<font face="Times">int <b>NXNumberOfColorComponents(</b>NXColorSpace <i>space</i><b>)</b></font><br>
<font face="Times">BOOL <b>NXGetBestDepth(</b>NXWindowDepth *<i>depth,</i> int <i>numColors</i>, int <i>bps</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The first of these functions, <b>NXColorSpaceFromDepth()</b>, maps an enumerated value for window depth into the corresponding enumerated value for color space.&nbsp; The <i>depth</i> argument can be any of the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">NX_TwoBitGrayDepth</font><br>
<font face="Times">NX_EightBitGrayDepth</font><br>
<font face="Times">NX_TwelveBitRGBDepth</font><br>
<font face="Times">NX_TwentyFourBitRGBDepth</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The value returned will be one of the NXColorSpace values in this list:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">NX_OneIsBlackColorSpace</font><br>
<font face="Times">NX_OneIsWhiteColorSpace</font><br>
<font face="Times">NX_RGBColorSpace</font><br>
<font face="Times">NX_CMYKColorSpace</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">NX_TwoBitGrayDepth and NX_EightBitGrayDepth map to NX_OneIsWhiteColorSpace.</font>

<p><font face="Times">The second function, <b>NXBPSFromDepth()</b>, extracts the number of bits per sample (bits per pixel in each color component) from a window <i>depth</i>.</font>

<p><font face="Times">The third function, <b>NXNumberOfColorComponents()</b>, similarly extracts the number of color components from a color <i>space</i>. The value returned will be 1, 3, or 4.</font>

<p><font face="Times">The fourth function, <b>NXGetBestDepth()</b>, finds the best window depth for an image with a given number of color components, <i>numColors</i>, and a given bits per sample, <i>bps</i>.&nbsp; The depth is returned by reference in the variable specified by <i>depth</i>.&nbsp; It will be one of the enumerated values listed above.&nbsp; If the depth provided exactly matches the requirements of <i>numColors</i> and <i>bps</i>, or is deeper than required, this function returns YES.&nbsp; If the depth isn't deep enough for <i>numColors</i> and <i>bps</i>, but is the best available, it returns NO.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXColorSpaceFromDepth()</b> returns the color space that matches a given window <i>depth</i>.&nbsp; <b>NXBPSFromDepth()</b> returns the number of bits per sample for a given window <i>depth</i>.&nbsp; <b>NXNumberOfColorComponents()</b> returns the number of color components in a given color <i>space</i>.&nbsp; <b>NXGetBestDepth()</b> returns YES if it can provide a window depth deep enough for <i>numColors</i> and <i>bps</i>, and NO if it can't.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXCompleteFilename()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Match an incomplete file name</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/SavePanel.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NXCompleteFilename</b>(char <i>*path</i>, int <i>maxPathSize</i>)</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXCompleteFilename</b> is used by the SavePanel class to determine the number of files matching an incomplete pathname. <i>path</i> is a pointer to a buffer containing an incomplete pathname.&nbsp; <i>maxPathSize</i> is the size of the buffer (<i>not</i> the length of <i>path</i>).</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">This function returns the number of files that match the incomplete name.&nbsp; By reference, <i>path</i> returns up to <i>maxPathSize </i>characters of the path to the first file matching the incomplete name.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXContainsRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXMouseInRect()</b></font>

<p><font face="Helvetica"><b>NXConvertCMYKAToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font>

<p><font face="Helvetica"><b>NXConvertCMYKToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToCMYK()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToCMYKA()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToGray()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToGrayAlpha()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToHSB()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToHSBA()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font>

<p><font face="Helvetica"><b>NXConvertColorToRGB()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertColorToRGBA()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXConvertColorToRGBA(), NXConvertColorToCMYKA(), NXConvertColorToHSBA(), NXConvertColorToGrayAlpha(), NXConvertColorToRGB(), NXConvertColorToCMYK(), NXConvertColorToHSB(), NXConvertColorToGray()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Convert a color value to its standard components</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXConvertColorToRGBA(</b>NXColor <i>color</i>, float *<i>red</i>, float *<i>green</i>, float *<i>blue</i>, float *<i>alpha</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXConvertColorToCMYKA(</b>NXColor <i>color</i>, float *<i>cyan</i>, float *<i>magenta</i>, float *<i>yellow</i>, float *<i>black</i>, float *<i>alpha</i><b>)</b></font><br>
<font face="Times">void <b>NXConvertColorToHSBA(</b>NXColor <i>color</i>, float *<i>hue</i>, float *<i>saturation</i>, float *<i>brightness</i>, float *<i>alpha</i><b>)</b></font><br>
<font face="Times">void <b>NXConvertColorToGrayAlpha(</b>NXColor <i>color</i>, float *<i>gray</i>, float *<i>alpha</i><b>)</b></font><br>
<font face="Times">void <b>NXConvertColorToRGB(</b>NXColor <i>color</i>, float *<i>red</i>, float *<i>green</i>, float *<i>blue</i><b>)</b></font><br>
<font face="Times">void <b>NXConvertColorToCMYK(</b>NXColor <i>color</i>, float *<i>cyan</i>, float *<i>magenta</i>, float *<i>yellow</i>, float *<i>black</i><b>)</b></font><br>
<font face="Times">void <b>NXConvertColorToHSB(</b>NXColor <i>color</i>, float *<i>hue</i>, float *<i>saturation</i>, float *<i>brightness</i><b>)</b></font><br>
<font face="Times">void <b>NXConvertColorToGray(</b>NXColor <i>color</i>, float *<i>gray</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions convert a color value, <i>color</i>, to its standard components.&nbsp; The first argument to each function is the NXColor data structure to be converted.&nbsp; Subsequent arguments point to <b>float</b> variables where the component values can be returned by reference.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The conversion can be to any set of components that might be used to specify a color value:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Red, green, and blue (RGB) components</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Cyan, magenta, yellow, and black (CMYK) components</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Hue, saturation, and brightness (HSB) components</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A single component for gray scale images</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A color initially specified by one set of components can be converted to another set.&nbsp; For example:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXColor&nbsp; color;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp;&nbsp;&nbsp; hue, saturation, brightness;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">color = NXConvertRGBToColor(0.8, 0.3, 0.15);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXConvertColorToHSB(color, &amp;hue, &amp;saturation, &amp;brightness);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first four functions in the list above report the coverage component, <i>alpha</i>, included in the color value, as well as the color components.&nbsp; The second four report only the color components; they're macros and are defined on the corresponding functions, but ignore the <i>alpha</i> argument.</font>

<p><font face="Times">The <b>float</b> values returned by reference will lie in the range 0.0 through 1.0.&nbsp; The value returned for the coverage component will be NX_NOALPHA if <i>color</i> doesn't include a coverage specification.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXConvertRGBAToColor()</b>, <b>NXSetColor()</b>, <b>NXEqualColor()</b>, <b>NXRedComponent()</b>, <b>NXChangeRedComponent()</b>, <b>NXReadColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXConvertGlobalToWinNum()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertWinNumToGlobal()</b></font>

<p><font face="Helvetica"><b>NXConvertGrayAlphaToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font>

<p><font face="Helvetica"><b>NXConvertGrayToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font>

<p><font face="Helvetica"><b>NXConvertHSBAToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font>

<p><font face="Helvetica"><b>NXConvertHSBToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXConvertRGBAToColor(), NXConvertCMYKAToColor(), NXConvertHSBAToColor(), NXConvertGrayAlphaToColor(), NXConvertRGBToColor(), NXConvertCMYKToColor(), NXConvertHSBToColor(), NXConvertGrayToColor()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Specify a color value</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXColor <b>NXConvertRGBAToColor(</b>float <i>red</i>, float <i>green</i>, float <i>blue</i>, float <i>alpha</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXColor <b>NXConvertCMYKAToColor(</b>float <i>cyan</i>, float <i>magenta</i>, float <i>yellow</i>, float <i>black</i>, float <i>alpha</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXConvertHSBAToColor(</b>float <i>hue</i>, float <i>saturation</i>, float <i>brightness</i>, float <i>alpha</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXConvertGrayAlphaToColor(</b>float <i>gray</i>, float <i>alpha</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXConvertRGBToColor(</b>float <i>red</i>, float <i>green</i>, float <i>blue</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXConvertCMYKToColor(</b>float <i>cyan</i>, float <i>magenta</i>, float <i>yellow</i>, float <i>black</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXConvertHSBToColor(</b>float <i>hue</i>, float <i>saturation</i>, float <i>brightness</i><b>)</b></font><br>
<font face="Times">NXColor <b>NXConvertGrayToColor(</b>float <i>gray</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions specify a color by its standard components and return an NXColor structure for the color.&nbsp; In the Application Kit, a color can be specified in any of four ways:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">By its red, green, and blue components (RGB)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">By its cyan, magenta, yellow, and black components (CMYK)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">By its hue, saturation, and brightness components (HSB)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">On a gray scale</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">No matter how they're specified, all color values are stored as the NXColor data type.&nbsp; The internal format of this type is unspecified; it should be set only through these functions or as one of the constants defined for pure colors, such as NX_COLORORANGE or NX_COLORWHITE.</font>

<p><font face="Times">The NXColor structure includes provision for a coverage component, <i>alpha</i>, which can be specified at the same time as the color.&nbsp; The first four functions listed above specify both color and coverage.&nbsp; The last four specify only color; they're defined as macros that work through the corresponding functions by passing NX_NOALPHA for the <i>alpha</i> argument.</font>

<p><font face="Times">Except for NX_NOALPHA, all values passed for color and coverage components should lie in the range 0.0 through 1.0; higher values will be reduced to 1.0 and lower ones raised to 0.0.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Each of these functions and macros returns an NXColor structure for the color specified.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXConvertColorToRGBA()</b>, <b>NXSetColor()</b>, <b>NXEqualColor()</b>, <b>NXRedComponent()</b>, <b>NXChangeRedComponent()</b>, <b>NXReadColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXConvertRGBToColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXConvertRGBAToColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXConvertWinNumToGlobal(), NXConvertGlobalToWinNum()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Convert local and global window numbers</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/publicWraps.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXConvertWinNumToGlobal(</b>int <i>winNum</i>, unsigned int *<i>globalNum</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXConvertGlobalToWinNum(</b>int <i>globalNum</i>, unsigned int *<i>winNum</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions allow two or more applications to refer to the same window.&nbsp; In the rare cases where this is necessary, the global window number, which has been automatically assigned by the Window Server, is used rather than the local window number, which is assigned by the application.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXConvertWinNumToGlobal()</b> takes the local window number and places the corresponding global window number in the variable specified by <i>globalNum</i>.&nbsp; This global number can then be passed to other applications that need access to the window.</font>

<p><font face="Times">To convert window numbers in the opposite direction, give the global number as an argument for <b>NXConvertGlobalToWinNum()</b>.&nbsp; This function places the appropriate local number in the variable specified by <i>winNum</i>.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>NXCopyBits(), NXCopyBitmapFromGState()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Copy an image</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXCopyBits(</b>int <i>gstate</i>, const NXRect *<i>aRect</i>, const NXPoint *<i>aPoint</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXCopyBitmapFromGState(</b>int <i>gstate</i>, const NXRect *<i>srcRect</i>, const NXRect *<i>destRect</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXCopyBits()</b> copies the pixels in the rectangle specified by <i>aRect</i> to the location specified by <i>aPoint</i>.&nbsp; The source rectangle is defined in the graphics state designated by <i>gstate</i>.&nbsp; If <i>gstate</i> is NXNullObject, the current graphics state is assumed.&nbsp; The <i>aPoint</i> destination is defined in the current graphics state.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXCopyBitmapFromGState()</b> copies the pixels in the rectangle <i>srcRect</i> to the rectangle <i>destRect</i>.&nbsp; The source rectangle is defined in the graphics state designated by <i>gstate</i>.&nbsp; The destination is defined in the current graphics state.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXCopyCurrentGState()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXSetGState()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXCopyInputData(), NXCopyOutputData()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Save data received in a remote message</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Listener.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">char *<b>NXCopyInputData(</b>int <i>parameter</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">char *<b>NXCopyOutputData(</b>int <i>parameter</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions each return a pointer to memory containing data passed from one application to another in a remote message. <b>NXCopyInputData()</b> is used for data received by a Listener object, and <b>NXCopyOutputData()</b> is used for return data received back by a Speaker.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Data received by a Listener in a remote message is guaranteed only for the duration of the receiving application's response to the message.&nbsp; Return data passed back to a Speaker is guaranteed only until the Speaker receives another return message. Therefore, you must copy any data you wish to keep.</font>

<p><font face="Times">If the data is passed in-line (if it's not too large to fit within the Mach message), these functions allocate memory for the data, copy it, and return a pointer to the copy.&nbsp; However, it's likely that more memory will be allocated than is required for the copy. Both functions use <b>vm_allocate()</b>, which provides memory in multiples of a page.</font>

<p><font face="Times">Therefore, for in-line data, it's more efficient for you to allocate the memory yourself, using <b>malloc()</b> or <b>NX_MALLOC()</b>, then copy the data using a standard library function like <b>strcpy()</b>.</font>

<p><font face="Times">For out-of-line data (data that's too large to fit within the Mach message itself, so that only a pointer to it is passed), it's generally more efficient to use <b>NXCopyInputData()</b> and <b>NXCopyOutputData()</b> to save a copy.&nbsp; Both functions ensure that the Listener or Speaker won't free the out-of-line data.&nbsp; Both return a pointer to the data without actually copying it.</font>

<p><font face="Times">The memory returned by these functions should be freed using <b>vm_deallocate()</b>, rather than <b>free()</b>.</font>

<p><font face="Times">The data to be saved is identified by <i>parameter</i>, an index into the list of parameters declared for the Objective C method that sends or receives the remote message.&nbsp; Indices begin at 0, and byte arrays count as a single parameter even though they're declared as a combination of a pointer to the array and an integer that counts the number of bytes in the array.</font>

<p><font face="Times">The examples below illustrate how these functions are used.&nbsp; In the first, a Listener receives a <b>translateGaelic::toWelsh::ok: </b>message, a fictitious message which requests the receiving application to exchange Gaelic text for the equivalent Welsh version.&nbsp; If the application needs to save the original text, it would copy it, using <b>NXCopyInputData()</b>, in the method it implements to respond to the message:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp; *originalText;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- (int)translateGaelic:(char *)gaelicText</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">:(int)gaelicLength</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">toWelsh:(char *)welshText</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">:(int *)welshLength</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">ok:(int *)flag</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ( gaelicLength &gt;= vm_page_size )</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">originalText = NXCopyInputData(0);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">.&nbsp; .&nbsp; .</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The application that sends a <b>translateGaelic::toWelsh::ok:</b> message would save the returned text, using <b>NXCopyOutputData()</b>, immediately after sending the remote message:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp; *newText;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; newLength;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; error, success;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">error = [mySpeaker translateGaelic:someText</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">:strlen(someText)</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">toWelsh:&amp;newText</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">:&amp;newLength</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">ok:&amp;success];</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if ( !error &amp;&amp; success )</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">newText = NXCopyOutputData(1);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Both functions return a pointer to memory containing data identified by the <i>parameter</i> index, or a NULL pointer if the data can't be provided.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXCopyOutputData()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXCopyInputData()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXCountWindows(), NXWindowList()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about an application's windows</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/publicWraps.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXCountWindows(</b>int *<i>count</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXWindowList(</b>int <i>size</i>, int <i>list</i>[]<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXCountWindows()</b> counts the number of on-screen windows belonging to the application; it returns the number by reference in the variable specified by <i>count</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXWindowList()</b> provides an ordered list of the application's on-screen windows.&nbsp; It fills the <i>list</i> array with up to <i>size</i> window numbers; the order of windows in the array is the same as their order in the Window Server's screen list (their front-to-back order on the screen).&nbsp; Use the count obtained by <b>NXCountWindows()</b> to specify the size of the array for <b>NXWindowList()</b>.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>NXCreateFileContentsPboardType(), NXCreateFilenamePboardType(), NXGetFileType(), NXGetFileTypes()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Return file-related pasteboard types</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Pasteboard.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXAtom <b>NXCreateFileContentsPboardType(</b>const char *<i>fileType</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXAtom <b>NXCreateFilenamePboardType(</b>const char *<i>filename</i><b>)</b></font><br>
<font face="Times">const char *<b>NXGetFileType(</b>const char *<i>pboardType</i><b>)</b></font><br>
<font face="Times">const char **<b>NXGetFileTypes(</b>const char *const *<i>pboardTypes</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXCreateFileContentsPboardType()</b> returns an NXAtom to a pasteboard type representing a file's contents based on the supplied string <i>fileType</i>.&nbsp; <i>fileType</i> should generally be the extension part of a file name.&nbsp; The conversion from a named file type to a pasteboard type is simple; no mapping to standard pasteboard types is attempted.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXCreateFilenamePboardType()</b> returns an NXAtom to a pasteboard type representing a file name based on the supplied string <i>filename</i>.</font>

<p><font face="Times"><b>NXGetFileType()</b> is the inverse of both <b>NXCreateFileContentsPboardType()</b> and <b>NXCreateFilenamePboardType()</b>. When passed a pasteboard type as returned by those functions, it returns the extension or file name from which the type was derived.&nbsp; It returns NULL if <i>pboardType</i> isn't a pasteboard type created by those functions.</font>

<p><font face="Times"><b>NXGetFileTypes()</b> accepts a null-terminated array of pointers to pasteboard types and returns a null-terminated array of the unique extensions and file names from the file-content and file-name types found in the input array.&nbsp; It returns NULL if the input array contains no file-content or file-name types.&nbsp; The returned array is allocated and must be freed by the caller.&nbsp; The pointers in the return array point into strings passed in the input array.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXCreatePopUpListButton()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXAttachPopUpList()</b></font>

<p><font face="Helvetica"><b>NXCyanComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXDefaultStringOrderTable()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXOrderStrings()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXDefaultTopLevelErrorHandler(), NXSetTopLevelErrorHandler(), NXTopLevelErrorHandler()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Define an error handler</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/errors.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXDefaultTopLevelErrorHandler(</b>NXHandler *<i>errorState</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXTopLevelErrorHandler *<b>NXSetTopLevelErrorHandler(</b>NXTopLevelErrorHandler *<i>procedure</i><b>)</b></font><br>
<font face="Times">NXTopLevelErrorHandler *<b>NXTopLevelErrorHandler(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This group of a function and two macros defines the top-level error handler.&nbsp; The top-level handler is called when an exception is forwarded through the nested lower-level handlers up to the top level.&nbsp; The hierarchy of error handlers is created by using any number of nested NX_DURING...NX_ENDHANDLER constructs.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If an application doesn't define its own top-level handler, by default it will use <b>NXDefaultTopLevelErrorHandler()</b>.&nbsp; This function is defined and used by the Application Kit.&nbsp; Its only argument is a pointer to an NXHandler structure (as defined in the header file <b>objc/error.h</b>).&nbsp; The <b>appkit/errors.h</b> header file defines <b>NXDefaultTopLevelErrorHandler()</b> as being a global variable of type NXTopLevelErrorHandler, which is defined as follows:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef void NXTopLevelErrorHandler(NXHandler *errorState);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">extern NXTopLevelErrorHandler NXDefaultTopLevelErrorHandler;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXDefaultTopLevelErrorHandler()</b> calls <b>NXReportError()</b>, which executes the procedure defined to report the error that occurred.&nbsp; (See the description of <b>NXRegisterErrorReporter()</b> in this chapter for details about <b>NXReportError()</b>.)&nbsp; If an error occurred when an application's PostScript context was created or if its PostScript connection is broken, <b>NXDefaultTopLevelErrorHandler()</b> exits.</font>

<p><font face="Times">An application can override <b>NXDefaultTopLevelErrorHandler()</b> by defining its own top-level handler.&nbsp; This involves passing a pointer to an error-handling procedure to the macro <b>NXSetTopLevelErrorHandler()</b>.&nbsp; The new error-handling procedure must be of type NXTopLevelErrorHandler, which means it must take a pointer to an NXHandler as its only argument and it must return <b>void</b>.</font>

<p><font face="Times"><b>NXTopLevelErrorHandler()</b> returns a pointer to the current top-level handler.&nbsp; After a new one has been set using <b>NXSetTopLevelErrorHandler()</b>, subsequent calls to <b>NXTopLevelErrorHandler()</b> will return a pointer to the new top-level error handler.</font>

<p><font face="Times">The two macros, <b>NXSetTopLevelErrorHandler()</b> and <b>NXTopLevelErrorHandler()</b>, are defined in the header file <b>appkit/errors.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NX_RAISE()</b> (Common Functions), <b>NXDefaultExceptionRaiser()</b> (Common Functions), <b>NXRegisterErrorReporter()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXDivideRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXSetRect()</b></font>

<p><font face="Helvetica"><b>NXDrawALine()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXScanALine()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXDrawBitmap(), NXReadBitmap(), NXSizeBitmap()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Render and read bitmap images</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXDrawBitmap(</b>const NXRect *<i>rect</i>, int <i>pixelsWide</i>, int <i>pixelsHigh</i>, int <i>bitsPerSample</i>, int <i>samplesPerPixel</i>, int <i>bitsPerPixel</i>, int <i>bytesPerRow</i>, BOOL <i>isPlanar</i>, BOOL <i>hasAlpha</i>, NXColorSpace <i>colorSpace</i>, const unsigned char *const <i>data</i>[5]<b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXReadBitmap(</b>const NXRect *<i>rect</i>, int <i>pixelsWide</i>, int <i>pixelsHigh</i>, int <i>bps</i>, int <i>spp</i>, int <i>config</i>, int <i>mask</i>, void *<i>data1</i>, void *<i>data2</i>, void *<i>data3</i>, void *<i>data4</i>, void *<i>data5</i><b>)</b></font><br>
<font face="Times">void <b>NXSizeBitmap(</b>const NXRect *<i>rect</i>, int *<i>size</i>, int *<i>pixelsWide</i>, int *<i>pixelsHigh</i>, int *<i>bps</i>, int *<i>spp</i>, int *<i>config</i>, int *<i>mask</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">These functions are marginally obsolete.&nbsp; Most applications are better served using the NXBitmapImageRep class to read and display bitmap images.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The first of these functions, <b>NXDrawBitmap()</b>, renders an image from a bitmap, binary data that describes the pixel values for the image (this function replaces <b>NXImageBitmap()</b>).&nbsp; The second function, <b>NXReadBitmap()</b>, reads the bitmap for a rendered image using information about the image obtained from <b>NXSizeBitmap()</b>.&nbsp; <b>NXReadBitmap()</b> produces data that <b>NXDrawBitmap()</b> can use to recreate the image.&nbsp; The third function, <b>NXSizeBitmap()</b>, supplies the information required by <b>NXReadBitmap()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXDrawBitmap()</b> renders a bitmap image using an appropriate PostScript operator--<b>image</b>, <b>colorimage</b>, or <b>alphaimage</b>.&nbsp; It puts the image in the rectangular area specified by its first argument, <i>rect</i>; the rectangle is specified in the current coordinate system and is located in the current window.&nbsp; The next two arguments, <i>pixelsWide</i> and <i>pixelsHigh</i>, give the width and height of the image in pixels.&nbsp; If either of these dimensions is larger or smaller than the corresponding dimension of the destination rectangle, the image will be scaled to fit.</font>

<p><font face="Times">The remaining arguments to <b>NXDrawBitmap()</b> describe the bitmap data, as explained in the following paragraphs.</font>

<p><font face="Times"><i>bitsPerSample</i> is the number of bits per sample for each pixel and <i>samplesPerPixel</i> is the number of samples per pixel. <i>bitsPerPixel</i> is based on <i>samplesPerPixel</i> and the configuration of the bitmap: if the configuration is planar, then the value of <i>bitsPerPixel</i> should equal the valule of <i>bitsPerSample</i>; if the configuration isn't planar (is meshed instead), <i>bitsPerPixel</i> should equal <i>bitsPerSample</i> * <i>samplesPerPixel</i>.</font>

<p><font face="Times"><i>bytesPerRow</i> is calcualted in one of two ways, depending on the configuration of the image data (data configuration is described below).&nbsp; If the data is planer, <i>bytesPerRow</i> is (7 + (<i>pixelsWide</i> * <i>bitsPerSample</i>)) / 8.&nbsp; If the data is meshed , <i>bytesPerRow</i> is (7 + (<i>pixelsWide</i> * <i>bitsPerSample</i> * <i>samplesPerPixel</i>)) / 8.</font>

<p><font face="Times">A sample is data that describes one component of a pixel.&nbsp; In an RGB color system, the red, green, and blue components of a color are specified as separate samples, as are the cyan, magenta, yellow, and black components in a CMYK system.&nbsp; Color values in a gray scale are a single sample.&nbsp; Alpha values that determine transparency and opaqueness are specified as a coverage sample separate from color. In bitmap images with alpha, the color (or gray) components have to be premultiplied with the alpha. This is the way images with alpha are displayed, this is the way they are read back, and this is the way they are stored in TIFFs.</font>

<p><font face="Times"><i>isPlanar</i> refers to the way data is configured in the bitmap.&nbsp; This flag should be set YES if a separate data channel is used for each sample.&nbsp; The function provides for up to five channels, <i>data1</i>, <i>data2</i>, <i>data3</i>, <i>data4</i>, and <i>data5</i>.&nbsp; It should be set NO if sample values are interwoven in a single channel (meshed); all values for one pixel are specified before values for the next pixel.</font>

<p><font face="Times">Figure 0-1 illustrates these two ways of configuring data.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F0.gif" width=327 height=184></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 0-1</b></font><font face="Times">.&nbsp; Planar and Meshed Configurations</font>

<p><br><br>

<p><font face="Times">As shown in the illustration, color samples (rgb) precede the coverage sample (</font><img src="../../../Images/c61.gif" width=9 height=7><font face="Times">) in both configurations.</font>

<p><font face="Times">In NEXTSTEP, gray-scale windows store pixel data in planar configuration; color windows store it in meshed configuration. <b>NXDrawBitmap()</b> can render meshed data in a planar window, or planar data in a meshed window.&nbsp; However, it's more efficient if the image has a depth (<i>bitsPerSample</i>) and configuration (<i>isPlanar</i>) that matches the window.</font>

<p><font face="Times"><i>hasAlpha</i> indicates whether the image contains alpha.&nbsp; If it does, the number of samples should be 1 greater than the number of color components in the model (e.g., 4 for RGB).</font>

<p><font face="Times"><i>colorSpace</i> can be NX_CustomColorSpace, indicating that the image data is to be interpreted according to the current color space in the PostScript graphics state. This allows for imaging using custom color spaces. The image parameters supplied as the other arguments should match what the color space is expecting.</font>

<p><font face="Times">If the image data is planar, <i>data</i>[0] through <i>data</i>[<i>samplesPerPixel</i>-1] point to the planes; if the data is meshed, only <i>data</i>[0] needs to be set.</font>

<p><font face="Times"><b>NXReadBitmap()</b> gets bitmap data for an existing image.&nbsp; It uses the PostScript <b>readimage</b> operator to read pixel values within the rectangle referred to by its first argument, <i>rect</i>.&nbsp; The rectangle is in the current window and is specified in the current coordinate system.&nbsp; If the rectangle is rotated so that its sides are no longer aligned with the screen coordinate system, <b>NXReadBitmap()</b> will read pixel values for the smallest screen-aligned rectangle enclosing the rectangle specified by <i>rect</i>.</font>

<p><font face="Times"><b>NXReadBitmap()</b> writes the bitmap data into the buffers specified by the <i>data1</i>, <i>data2</i>, <i>data3</i>, <i>data4</i>, and <i>data5</i> arguments.&nbsp; The number of actual buffers you must provide depends on whether there's a separate channel for each sample (<i>config</i>) and on the number of samples per pixel (<i>spp</i>).&nbsp; This information, as well as other information about the image, should be obtained directly from the device using the <b>NXSizeBitmap()</b> function.</font>

<p><font face="Times">When passed a pointer to a rectangle, <b>NXSizeBitmap()</b> gets values that <b>NXReadBitmap()</b> needs to produce a bitmap for the rectangle.&nbsp; It yields values that can be passed directly to <b>NXReadBitmap()</b> for the following parameters:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">pixelsWide</font><br>
<font face="Times">pixelsHigh</font><br>
<font face="Times">bps</font><br>
<font face="Times">spp</font><br>
<font face="Times">config</font><br>
<font face="Times">mask</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">It also provides the size, in bytes, that will be required for each channel of bitmap data.&nbsp; <b>NXSizeBitmap()</b> works through the <b>currentwindowalpha</b> and <b>sizeimage</b> operators.&nbsp; The following paragraphs describe the kinds of information you could obtain from each of these operators if you were to use them directly.</font>

<p><font face="Times">If <b>currentwindowalpha</b> returns 0, the image may include some transparent paint and you'll need to obtain coverage values in addition to color values in the bitmap.&nbsp; Include NX_ALPHAMASK in <i>mask</i>, and make sure the alpha component is counted in <i>spp</i>.</font>

<p><font face="Times">The <b>sizeimage</b> operator provides values for the <i>pixelsWide</i>, <i>pixelsHigh</i>, and <i>bps</i> parameters and for these device-dependent values:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The number of color samples per pixel--1 (gray scale), 3 (RGB), or 4 (CMYK).&nbsp; If there's also an alpha component, you'll need to add 1 to this number to obtain <i>spp</i>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A boolean value that reflects whether samples are meshed within a single data channel.&nbsp; If they're not meshed, the operator returns <i>true</i> in a <i>multiproc</i> parameter, indicating that in the PostScript language multiple procedures would be required to read the various samples.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXDrawButton(), NXDrawGrayBezel(), NXDrawGroove(), NXDrawWhiteBezel(), NXDrawTiledRects(), NXFrameRect(), NXFrameRectWithWidth()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Draw a bordered rectangle</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXDrawButton(</b>const NXRect *<i>aRect</i>, const NXRect *<i>clipRect</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXDrawGrayBezel(</b>const NXRect *<i>aRect</i>, const NXRect *<i>clipRect</i><b>)</b></font><br>
<font face="Times">void <b>NXDrawGroove(</b>const NXRect *<i>aRect</i>, const NXRect *<i>clipRect</i><b>)</b></font><br>
<font face="Times">void <b>NXDrawWhiteBezel(</b>const NXRect *<i>aRect</i>, const NXRect *<i>clipRect</i><b>)</b></font><br>
<font face="Times">NXRect *<b>NXDrawTiledRects(</b>NXRect *<i>aRect</i>, const NXRect *<i>clipRect</i>, const int *<i>sides</i>, const float *<i>grays</i>, int <i>count</i><b>)</b></font><br>
<font face="Times">void <b>NXFrameRect(</b>const NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">void <b>NXFrameRectWithWidth(</b>const NXRect *<i>aRect</i>, NXCoord <i>frameWidth</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions draw rectangles with borders.&nbsp; <b>NXDrawButton()</b> draws the rectangle used to signify a button in the NEXTSTEP user interface, <b>NXDrawTiledRects()</b> is a generic function that can be used to draw different types of borders, and the other functions provide ready-made bezeled, grooved, or line borders.&nbsp; These borders can be used to outline an area or to give rectangles the effect of being recessed from or elevated above the surface of the screen, as shown in Figure 0-2.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F1.gif" width=458 height=201></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 0-2</b></font><font face="Times">.&nbsp; Rectangle Borders</font>

<p><br><br>

<p><font face="Times">Each function's first argument specifies the rectangle within which the border is to be drawn in the current coordinate system. Since these functions are often used to draw the border of a View, this rectangle will typically be that View's bounds rectangle. Some of the functions also take a clipping rectangle; only those parts of <i>aRect</i> that lie within the clipping rectangle will be drawn.</font>

<p><font face="Times">As its name suggests, <b>NXDrawWhiteBezel()</b> fills in its rectangle with white; <b>NXDrawButton()</b>, <b>NXDrawGrayBezel()</b>, and <b>NXDrawGroove()</b> use light gray.&nbsp; These functions are designed for rectangles that are defined in unscaled, unrotated coordinate systems (that is, where the y-axis is vertical, the x-axis is horizontal, and a unit along either axis is equal to one screen pixel).&nbsp; The coordinate system can be either flipped or unflipped.&nbsp; The sides of the rectangle should lie on pixel boundaries.</font>

<p><font face="Times"><b>NXFrameRect()</b> and <b>NXFrameRectWithWidth()</b> draw a frame around the inside of a rectangle in the current color. <b>NXFrameRect()</b> draws a frame with a width equal to 1.0 in the current coordinate system; <b>NXFrameRectWithWidth() </b>allows you to set the width of the frame.&nbsp; Since the frame is drawn inside the rectangle, it will be visible even if drawing is clipped to the rectangle (as it would be if the rectangle were a View object).&nbsp; These functions work best if the sides of the rectangle lie on pixel boundaries.</font>

<p><font face="Times">In addition to its <i>aRect</i> and <i>clipRect</i> arguments, <b>NXDrawTiledRects()</b> takes three more arguments, which determine how thick the border is and what gray levels are used to form it.&nbsp; <b>NXDrawTiledRects()</b> works through <b>NXDivideRect()</b> to take successive 1.0</font><img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">unit-wide slices from the sides of the rectangle specified by the <i>sides</i> argument.&nbsp; Each slice is then drawn using the corresponding gray level from <i>grays</i>.&nbsp; <b>NXDrawTiledRects()</b> makes and draws these slices <i>count</i> number of times. <b>NXDivideRect()</b> returns a pointer to the rectangle after the slice has been removed; therefore, if a side is used more than once, the second slice is made inside the first.&nbsp; This also makes it easy to fill in the rectangle inside of the border.</font>

<p><font face="Times">In the following example, <b>NXDrawTiledRects()</b> draws a bezeled border consisting of a 1.0</font><img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">unit-wide white line at the top and on the left side, and a 1.0</font><img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">unit-wide dark-gray line inside a 1.0</font><img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">unit-wide black line on the other two sides.&nbsp; The rectangle inside this border is filled in using light gray.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySides[] = {NX_YMIN, NX_XMAX, NX_YMAX, NX_XMIN,</font><br>
<img src="../../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">NX_YMIN, NX_XMAX};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">float&nbsp;&nbsp;&nbsp; myGrays[] = {NX_BLACK, NX_BLACK, NX_WHITE, NX_WHITE,</font><br>
<img src="../../../Images/sp.gif" width=292 height=1><font face="Courier" size="-1">NX_DKGRAY, NX_DKGRAY};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXRect&nbsp; *aRect;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">NXDrawTiledRects(aRect, (NXRect *)0, mySides, myGrays, 6);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSsetgray(NX_LTGRAY);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">PSrectfill(aRect-&gt;origin.x, aRect-&gt;origin.y,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">aRect-&gt;size.width, aRect-&gt;size.height);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">As shown, <b>mySides</b> is an array that specifies sides of a rectangle; for example, NX_YMIN selects the side parallel to the x-axis with the smallest y-coordinate value.&nbsp; The constants shown in <b>mySides</b> are described in more detail in the description of <b>NXDivideRect()</b>.&nbsp; <b>myGrays</b> is an array that specifies the successive gray levels to be used in drawing parts of the border.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXDrawTiledRects()</b> returns a pointer to the rectangle that lies within the border.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXDivideRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXDrawGrayBezel()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawButton()</b></font>

<p><font face="Helvetica"><b>NXDrawGroove()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawButton()</b></font>

<p><font face="Helvetica"><b>NXDrawTiledRects()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawButton()</b></font>

<p><font face="Helvetica"><b>NXDrawWhiteBezel()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawButton()</b></font>

<p><font face="Helvetica"><b>NXEditorFilter()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXFieldFilter()</b></font>

<p><font face="Helvetica"><b>NXEmptyRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXMouseInRect()</b></font>

<p><font face="Helvetica"><b>NXEndTimer()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXBeginTimer()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXEqualColor()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Test whether two colors are the same</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">BOOL <b>NXEqualColor(</b>NXColor <i>oneColor</i>, NXColor <i>anotherColor</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function compares <i>oneColor</i> to <i>anotherColor</i> and returns YES if they are, in fact, the same color.&nbsp; Two colors can be the same, yet be represented differently within the NXColor structure.&nbsp; Therefore, NXColor structures should be compared only through this function, never directly.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The coverage components of the NXColor structures are included in the comparison.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">This function returns YES if the two colors are visually identical, and NO if they're not.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXSetColor()</b>, <b>NXConvertRGBAToColor()</b>, <b>NXConvertColorToRGBA()</b>, <b>NXRedComponent()</b>, <b>NXChangeRedComponent()</b>, <b>NXReadColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXEqualRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXMouseInRect()</b></font>

<p><font face="Helvetica"><b>NXEraseRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRectClip()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXFieldFilter(), NXEditorFilter()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Filter characters entered into Text object</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Text.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">unsigned short <b>NXFieldFilter(</b>unsigned short <i>theChar</i>, int <i>flags</i>, unsigned short <i>charSet</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">unsigned short <b>NXEditorFilter(</b>unsigned short <i>theChar</i>, int <i>flags</i>, unsigned short <i>charSet</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions check each character the user types into a Text object's text.&nbsp; Use <b>NXFieldFilter()</b>, the Text object's default character filter, when you want the user to be able to move the selection from text field to field by pressing Return, Tab, or Shift-Tab.&nbsp; Use <b>NXEditorFilter()</b> when you don't want Return, Tab, and Shift-Tab interpreted in this way.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXFieldFilter()</b> passes on values generated by alphanumeric keys directly to the Text object for display.&nbsp; Values generated by Return, Tab, Shift-Tab, and the arrow keys are remapped to constants that have a special meaning for the Text object.&nbsp; The Text object interprets any of these constants as a movement command, a command to end the Text object's status as first responder. Based on the key pressed, the Text object's delegate can control which other object should become the first responder. <b>NXFieldFilter()</b> remaps to 0 all other values less than 0x20 and any values generated in conjunction with the Command key.</font>

<p><font face="Times"><b>NXEditorFilter()</b> is identical to <b>NXFieldFilter()</b> except that it passes on values corresponding to Return, Tab, and Shift-Tab directly to the Text object.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXFieldFilter()</b> returns 0 (NX_ILLEGAL), the ASCII value of the character typed, or a constant the Text object interprets as a movement command.&nbsp; The constants are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">NX_RETURN</font><br>
<font face="Times">NX_TAB</font><br>
<font face="Times">NX_BACKTAB</font><br>
<font face="Times">NX_LEFT</font><br>
<font face="Times">NX_RIGHT</font><br>
<font face="Times">NX_UP</font><br>
<font face="Times">NX_DOWN</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This function also returns 0 if a key is pressed while a Command key is held down.</font>

<p><font face="Times"><b>NXEditorFilter()</b>'s return values are identical to those of <b>NXFieldFilter(),</b> except that it also returns the values generated by Return, Tab, and Shift-Tab without first remapping them.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXFindColorNamed()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXColorListName()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXFindPaperSize()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Find dimensions of specified paper type</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/PageLayout.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">const NXSize *<b>NXFindPaperSize(</b>const char *<i>paperName</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXFindPaperSize()</b> returns a pointer to an NXSize structure containing the dimensions of a sheet of paper of type <i>paperName</i>. The dimensions are given in points (72 per inch).&nbsp; <i>paperName</i> is a character string that corresponds to one of the standard paper types used by conforming PostScript documents.&nbsp; For example, it could be &quot;Letter&quot;, &quot;Legal&quot;, or &quot;A4&quot;.&nbsp; By providing the precise size of these types, this function helps programs adjust the on-screen display to the page size of the document being displayed.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXFrameLinkRect(), NXLinkFrameThickness()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Draw a distinctive outline around linked data</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/NXDataLinkManager.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXFrameLinkRect(</b>const NXRect *<i>aRect</i>, BOOL <i>isDestination</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">float <b>NXLinkFrameThickness(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXFrameLinkRect()</b> draws a distinctive link outline just outside the rectangle specified by <i>aRect</i>.&nbsp; To draw an outline around a destination link, <i>isDestination</i> should be YES, otherwise it should be NO.&nbsp; <b>NXLinkFrameThickness()</b> returns the thickness of the link outline so that the outline can be properly erased by the application, or for other purposes.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXFrameRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawButton()</b></font>

<p><font face="Helvetica"><b>NXFrameRectWithWidth()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawButton()</b></font>

<p><font face="Helvetica"><b>NXFreeAlertPanel()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRunAlertPanel()</b></font>

<p><font face="Helvetica"><b>NXGetAlertPanel()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRunAlertPanel()</b></font>

<p><font face="Helvetica"><b>NXGetBestDepth()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXColorSpaceFromDepth()</b></font>

<p><font face="Helvetica"><b>NXGetFileType()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXCreateFileContentsPboardType()</b></font>

<p><font face="Helvetica"><b>NXGetFileTypes()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXCreateFileContentsPboardType()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXGetNamedObject(), NXGetObjectName(), NXNameObject(), NXUnnameObject()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Refer to objects by name</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Application.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">id <b>NXGetNamedObject(</b>const char *<i>name</i>, id <i>owner</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">const char *<b>NXGetObjectName(</b>id <i>theObject</i><b>)</b></font><br>
<font face="Times">int <b>NXNameObject(</b>const char *<i>name</i>, id <i>theObject</i>, id <i>owner</i><b>)</b></font><br>
<font face="Times">int <b>NXUnnameObject(</b>const char *<i>name</i>, id <i>owner</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions permit programs that use the Application Kit to refer to objects by name.&nbsp; Names are assigned with Interface Builder or with the <b>NXNameObject()</b> function described here.&nbsp; When you create an object with Interface Builder, Interface Builder assigns it a default name that you can then edit or replace with a name of your own choosing.&nbsp; Underscores shouldn't be used as part of a name.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">To distinguish among different objects with the same name, each object can also be assigned another object as an owner; the owner can be <b>nil</b>.&nbsp; By default, Interface Builder assigns the Application object (NXApp) as the owner of a Window, and a View's Window as the owner of that View.</font>

<p><font face="Times"><b>NXGetNamedObject()</b> returns the object having the <i>name</i> and <i>owner</i> passed as arguments, or <b>nil</b> if there is no such object. Only one object can be identified by a given combination of a name and owner.&nbsp; <b>NXGetObjectName()</b> takes an object and returns that object's name.</font>

<p><font face="Times"><b>NXNameObject()</b> assigns an object a <i>name</i> and <i>owner</i>.&nbsp; An object can be assigned any number of different names and owners. However, if you attempt to assign a combination of a name and owner already used to identify another (or the same) object, the assignment fails.</font>

<p><font face="Times"><b>NXUnnameObject()</b> disassociates an object from the combination of a <i>name</i> and <i>owner</i>.&nbsp; Thereafter, <b>NXGetNamedObject() </b>won't return the object when passed the <i>name</i> and <i>owner</i> as arguments.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXNameObject()</b> returns 1 if it successfully assigns a name to an object, and 0 if not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXUnnameObject()</b> returns 1 if it disassociates an object from the combination of name and owner passed as arguments, and 0 if the name and owner weren't associated with an object to begin with.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXGetObjectName()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXGetNamedObject()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXGetOrPeekEvent()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Access event record in event queue</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Application.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXEvent *<b>NXGetOrPeekEvent(</b>DPSContext <i>context</i>, NXEvent *<i>anEvent</i>, int <i>mask</i>, double <i>timeout</i>, int <i>threshold</i>, int <i>peek</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXGetOrPeekEvent()</b> accesses an event record in an application's event queue and returns a pointer to it.&nbsp; This function combines the facilities of <b>DPSGetEvent()</b> and <b>DPSPeekEvent()</b>, but unlike these client library functions, it allows your application to be journaled.&nbsp; Applications based on the Application Kit should use this function (or the Application class methods such as <b>getNextEvent:</b> and <b>peekNextEvent:into:</b>) to access event records.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first argument, <i>context</i>, represents a PostScript execution context within the Window Server.&nbsp; Virtually all applications have only one execution context, which can be returned through Application's <b>context</b> method.&nbsp; Applications having more than one execution context can use the constant DPS_ALLCONTEXTS to access events from all contexts belonging to them.</font>

<p><font face="Times">The second argument, <i>anEvent</i>, is a pointer to an event record.&nbsp; If an event is found, its data is copied into the storage referred to by this pointer.</font>

<p><font face="Times"><i>mask</i> determines the types of events sought.&nbsp; See &quot;Types and Constants&quot; for a list of event type masks.</font>

<p><font face="Times">If an event matching the event mask isn't available in the queue, <b>NXGetOrPeekEvent()</b> waits until one arrives or until <i>timeout </i>seconds have elapsed, whichever occurs first.&nbsp; The value of <i>timeout</i> can be in the range of 0.0 to NX_FOREVER.&nbsp; If <i>timeout</i> is 0.0, the routine returns an event only if one is waiting in the queue when the routine asks for it.&nbsp; If <i>timeout</i> is NX_ FOREVER, the routine waits until an appropriate event arrives before returning.</font>

<p><font face="Times"><i>threshold</i> is an integer in the range 0 to 31 that determines which other services may be provided during a call to <b>NXGetOrPeekEvent()</b>.&nbsp; Requests for services are registered by the functions <b>DPSAddTimedEntry()</b>, <b>DPSAddPort()</b>, and <b>DPSAddFD()</b>.&nbsp; Each of these functions takes an argument specifying a priority level.&nbsp; If this level is equal to or greater than <i>threshold</i>, the service is provided before <b>NXGetOrPeekEvent()</b> returns.</font>

<p><font face="Times">The last argument, <i>peek</i>, specifies whether <b>NXGetOrPeekEvent()</b> removes the event from the event queue.&nbsp; If <i>peek</i> is 0, <b>NXGetOrPeekEvent()</b> removes the record from the queue after making its data available to the application; otherwise, it leaves the record in the queue.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">If <b>NXGetOrPeekEvent()</b> finds an event record that meets the requirements of its parameters, it returns a pointer to it. Otherwise, it returns NULL.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXJournalMouse()</b>, <b>DPSGetEvent()</b> (Display PostScript), <b>DPSPeekEvent()</b> (Display PostScript), <b>DPSDiscardEvent() </b>(Display PostScript)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXGetWindowServerMemory()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Return the amount of memory being used by a context</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Application.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NXGetWindowServerMemory(</b>DPSContext <i>context</i>, int *<i>virtualMemory</i>, int *<i>windowBackingMemory</i>, NXStream *<i>windowDumpStream</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXGetWindowServerMemory()</b> calculates the amount of Window Server memory being used at the moment by the given Window Server context.&nbsp; If NULL is passed for the context, the current context is used.&nbsp; The amount of PostScript virtual memory used by the current context is returned in the <b>int</b> pointed to by <i>virtualMemory</i>; the amount of window backing store used by windows owned by the current context is returned in the <b>int</b> pointed to by <i>windowBackingMemory</i>.&nbsp; The sum of these two numbers is the amount of the Window Server's memory that this context is responsible for.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">To calculate these numbers, <b>NXGetWindowServerMemory()</b> uses the PostScript language operators <b>dumpwindows</b> and <b>vmstatus</b>.&nbsp; It takes some time to execute; thus, calling this function in normal operation is not recommended.</font>

<p><font face="Times">If a non</font><img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">NULL value is passed in for <i>windowDumpStream</i>, the information returned from the <b>dumpwindows</b> operator is echoed to the specified NXStream.&nbsp; This can be useful for finding out more about which windows are using up your storage.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Normally, <b>NXGetWindowServerMemory()</b> returns 0.&nbsp; If NULL is passed for context and there's no current DPS context, this function returns</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXGrayComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXGreenComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXHighlightRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRectClip()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXHomeDirectory(), NXUserName()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get user's home directory and name</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Application.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">const char *<b>NXHomeDirectory(</b>void<b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">const char *<b>NXUserName(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions return the user's home directory and name.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXHomeDirectory()</b> returns a pointer to the full pathname of the user's home directory.&nbsp; <b>NXUserName()</b> returns a pointer to the user's name.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXHueComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font>

<p><font face="Helvetica"><b>NXInsetRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXSetRect()</b></font>

<p><font face="Helvetica"><b>NXIntegralRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXSetRect()</b></font>

<p><font face="Helvetica"><b>NXIntersectionRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXUnionRect()</b></font>

<p><font face="Helvetica"><b>NXIntersectsRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXMouseInRect()</b></font>

<p><font face="Helvetica"><b>NXIsServicesMenuItemEnabled()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXSetServicesMenuItemEnabled()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXJournalMouse()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Allow journaling during direct mouse tracking</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/NXJournaler.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXJournalMouse(</b>void<b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function lets an application that accesses the status of the mouse directly (by calling functions such as <b>PSstilldown()</b> or <b>PScurrentmouse()</b>) participate in event journaling.&nbsp; If your application tests the status of the mouse by analyzing event records received through the Application Kit's normal distribution mechanism, you won't need to call this function.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For an application to be journaled, it must ask for events.&nbsp; If a routine in your application bypasses the Kit's event distribution system to test the mouse's position or button status, it must call <b>NXJournalMouse()</b> to ensure that its activities can be journaled. For example, a routine that takes some action as long as the mouse button is depressed should call <b>NXJournalMouse()</b> before testing the mouse:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">do {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXJournalMouse();</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">PSstilldown(mouseDownEvent.data.mouse.eventNum, &amp;stillDown);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Do some action */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} while (stillDown);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXJournalMouse()</b> asks for a journal, mouse-up, or mouse-dragged event; sends a copy to the journaler (if one is recording); and then discards the event.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">In the example above, releasing the mouse button causes the loop to exit.&nbsp; If the loop didn't call <b>NXJournalMouse()</b>, the mouse-up event would remain in the event queue after the loop exited.&nbsp; With the addition of <b>NXJournalMouse()</b>, this event is discarded.&nbsp; For most applications, this difference is of no consequence.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXGetOrPeekEvent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXLinkFrameThickness()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXFrameLinkRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXLogError()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Write a formatted error string</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/nextstd.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXLogError(</b>const char *<i>format</i>, ...<b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXLogError()</b> writes a formatted string to the console or <b>stderr</b>, depending on whether the application is launched from the Workspace Manager or a Terminal window.&nbsp; If launched from the Workspace Manager, <b>NXLogError()</b> will call <b>syslog()</b>, which marks the message with the time of occurrence and the application's process identification number.&nbsp; See the UNIX manual page for <b>syslog()</b> for more information.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXRegisterErrorReporter()</b>, <b>NX_RAISE()</b> (Common Functions), <b>NXDefaultExceptionRaiser()</b> (Common Functions)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXMagentaComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXMouseInRect(), NXPointInRect(), NXIntersectsRect(), NXContainsRect(), NXEqualRect(), NXEmptyRect()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Test graphic relationships</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">BOOL <b>NXMouseInRect(</b>const NXPoint *<i>aPoint</i>, const NXRect *<i>aRect</i>, BOOL <i>flipped</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">BOOL <b>NXPointInRect(</b>const NXPoint *<i>aPoint</i>, const NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">BOOL <b>NXIntersectsRect(</b>const NXRect *<i>aRect</i>, const NXRect *<i>bRect</i><b>)</b></font><br>
<font face="Times">BOOL <b>NXContainsRect(</b>const NXRect *<i>aRect</i>, const NXRect *<i>bRect</i><b>)</b></font><br>
<font face="Times">BOOL <b>NXEqualRect(</b>const NXRect *<i>aRect</i>, const NXRect *<i>bRect</i><b>)</b></font><br>
<font face="Times">BOOL <b>NXEmptyRect(</b>const NXRect *<i>aRect</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions test the rectangles referred to by their arguments; they return YES if the test succeeds and NO if it fails.&nbsp; The functions that take two arguments assume that both arguments are expressed in the same coordinate system.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXMouseInRect()</b> is used to determine whether the hot spot of the cursor is inside a given rectangle.&nbsp; It returns YES if the point referred to by its first argument is located within the rectangle referred to by its second argument.&nbsp; If not, it returns NO.&nbsp; It assumes an unscaled and unrotated coordinate system.</font>

<p><font face="Times">The hot spot is the point within the cursor image that's used to report the cursor's location.&nbsp; It's situated at the upper left corner of a critical pixel in the cursor image, the one cursor pixel that's constrained to always be on screen.&nbsp; <b>NXMouseInRect()</b> is designed to return YES when this pixel is inside the rectangle, and NO when it's not.&nbsp; Thus if the point referred to by <i>aPoint</i> lies along the upper or left edge of the rectangle, this function should return YES.&nbsp; But if the point lies along the lower or right edge of the rectangle, it should return NO.&nbsp; To make this determination, the function needs to know the polarity of the y-axis.&nbsp; The third argument, <i>flipped</i>, should be NO if the positive y-axis extends upward, and YES if the coordinate system has been flipped so that the positive y-axis extends downward.&nbsp; (For convenience, View's <b>mouse:inRect:</b> method automatically determines whether the coordinate system is flipped.</font>

<p><font face="Times"><b>NXPointInRect()</b> performs the same test as <b>NXMouseInRect()</b> but assumes a flipped coordinate system.&nbsp; If the coordinate system is unflipped, it gives the wrong result if the point is coincident with the maximum or minimum y-coordinate of the rectangle.&nbsp; You should use <b>NXMouseInRect()</b> when testing the cursor's location.</font>

<p><font face="Times"><b>NXContainsRect()</b> returns YES if <i>aRect</i> completely encloses <i>bRect</i>.&nbsp; Otherwise, it returns NO.</font>

<p><font face="Times"><b>NXIntersectsRect()</b> returns YES if the two rectangles overlap, and NO otherwise.&nbsp; Adjacent rectangles that share only a side are not considered to overlap.</font>

<p><font face="Times">It's possible for <b>NXIntersectsRect()</b> to return NO even though the two rectangles include some of the same pixels.&nbsp; This can happen when the rectangles don't have any area in common, yet their outlines pass through some of the same pixels--for example, when they share a side not at a pixel boundary.&nbsp; In the NEXTSTEP imaging model, any pixel an outline passes through is treated as if it were inside the outline.</font>

<p><font face="Times"><b>NXEqualRect()</b> returns YES if the two rectangles are identical, and NO otherwise.</font>

<p><font face="Times"><b>NXEmptyRect()</b> returns YES if the rectangle encloses no area at all--that is, if it has no height or no width (or if its width or height is negative).&nbsp; If the height and width are both positive, it returns NO.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXUnionRect()</b>, <b>NXSetRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXNameObject()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXGetNamedObject()</b></font>

<p><font face="Helvetica"><b>NXNumberOfColorComponents()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXColorSpaceFromDepth()</b></font>

<p><font face="Helvetica"><b>NXOffsetRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXSetRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXOrderStrings(), NXDefaultStringOrderTable()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Provide table-driven string ordering service</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Text.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NXOrderStrings(</b>const unsigned char *<i>string1</i>, const unsigned char *<i>string2</i>, BOOL <i>caseSensitive</i>, int <i>length</i>, NXStringOrderTable *<i>table</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXStringOrderTable *<b>NXDefaultStringOrderTable(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXOrderStrings()</b> returns a value indicating the ordering of the strings <i>s1</i> and <i>s2</i>, as determined by the NXStringOrderTable structure <i>table</i>.&nbsp; If <i>caseSensitive</i> is NO, capital and lowercase versions of a letter are considered to have identical rank.&nbsp; The comparison considers at most the first <i>length</i> characters of each string.&nbsp; For convenience, you can pass</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1 for <i>length</i> if both strings are null-terminated.&nbsp; If <i>table</i> is NULL, the default ordering table (as described below) is used.&nbsp; <b>NXOrderStrings() </b>returns 1, 0, or</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1 depending on whether <i>s1</i> is greater than, equal to, or less than <i>s2</i> according to <i>table</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">When comparing strings that are visible to the user, you should generally use <b>NXOrderStrings(</b><i>s1</i>, <i>s2</i>, YES,</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1, NULL<b>)</b> as a replacement for <b>strcmp(</b><i>s1</i>, <i>s2</i><b>)</b> and <b>NXOrderStrings(</b><i>s1</i>, <i>s2</i>, YES, <i>n</i>, NULL<b>)</b> as a replacement for <b>strncmp(</b><i>s1</i>, <i>s2</i>, <i>n</i><b>)</b>.</font>

<p><font face="Times"><b>NXOrderStrings()</b> consults an NXStringOrderTable structure when comparing strings.&nbsp; This structure is declared in <b>appkit/Text.h</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">unsigned char primary[256];</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">unsigned char secondary[256];</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">unsigned char primaryCI[256];</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">unsigned char secondaryCI[256];</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} NXStringOrderTable;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first two arrays contain ordering information for case sensitive searches; the last two are for case insensitive searches. <b>NXOrderStrings()</b> determines a character's rank by using the character to index into the appropriate primary array.&nbsp; The value found at that position determines the character's rank.&nbsp; For example, in the default ordering table the value at the `a' position is less than that at the `b' position, but the values at the `o' and `&ouml;' positions are identical.&nbsp; The secondary arrays provide additional ordering information for ligature characters (such as `&aelig;' and `fl'), in effect breaking the ligature apart for the purposes of ordering.&nbsp; Thus, the two characters `ae' and the single character `&aelig;' are given equal rank.</font>

<p><font face="Times">NEXTSTEP provides a default order table, which you can obtain by calling <b>NXDefaultStringOrderTable()</b>.&nbsp; If you want to create your own order table, it's best to start with the default table and algorithmically modify it (perhaps in conjunction with the NXCType routines such as <b>NXIsAlpha()</b>, which are described in Chapter 3, &quot;Common Classes and Functions&quot;).&nbsp; In this way, you'll benefit from using character tables that have already been localized.&nbsp; The entry at the 0 position in each array must be 0.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXOrderStrings()</b> returns 1, 0, or</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1 depending on whether <i>s1</i> is greater than, equal to, or less than <i>s2</i> according to <i>table</i>. <b>NXDefaultStringOrderTable()</b> returns a pointer to the default string order table.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXPerformService()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Programmatically invokes a Services menu service</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Listener.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">BOOL <b>NXPerformService(</b>const char *<i>itemName</i>, Pasteboard *<i>pboard</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXPerformService()</b> allows an application to programmatically invoke a service found in its services menu.&nbsp; <i>itemName</i> is a Services menu item, in any language.&nbsp; If the requested service is from a submenu of the Services menu, <i>itemName</i> must contain a slash (for example, &quot;Mail/Selection&quot;).&nbsp; The Pasteboard <i>pboard</i> must contain the data required by the service, and when the function returns, <i>pboard</i> will contain the data supplied by the service provider.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns YES if the service is successfully performed, NO otherwise.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXPing()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Synchronize the application with the Window Server</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXPing(</b>void<b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXPing()</b> helps applications synchronize their actions with the actions of the Window Server; it enables an application to respond smoothly to user events.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An application can generate PostScript code faster than the Window Server can interpret it.&nbsp; An application can therefore &quot;get ahead&quot; of the Server--it can get events and respond to them before its responses to previous events are displayed to the user. To the user, it appears that the application is slow, or that there's discontinuity between an event and the response.</font>

<p><font face="Times"><b>NXPing()</b> causes the application to pause until the Window Server catches up.&nbsp; It flushes the connection buffer so that all current PostScript code is sent to the Server and returns only when all the code has been interpreted.</font>

<p><font face="Times">Waiting for the Window Server to catch up with the application is sometimes a good idea, for two reasons:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It lets the Server have full access to the CPU.&nbsp; The application stops competing with it for system resources.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It gives the application a chance to generate less, and more relevant, PostScript code.&nbsp; An application won't fall even further behind the user while it waits for the Window Server if it combines its responses to events or allows events to be coalesced in the event queue.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXPing()</b> is most typically used in a modal loop.&nbsp; In a tracking loop, it should be called just before getting each new event (after all the PostScript code has been generated in response to the last event).&nbsp; The following schematic for a <b>mouseDown:</b> method illustrates its use.&nbsp; (Comments that would be replaced by code in any real method are shown in italic type.)</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- mouseDown:(NXEvent *)thisEvent</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">BOOL&nbsp;&nbsp; shouldLoop = YES;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp; oldMask = [window addToEventMask:NX_LMOUSEDRAGGEDMASK];</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while ( shouldLoop ) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=187 height=1><font face="Courier" size="-1">* <i>Draw in response to the event</i></font><br>
<img src="../../../Images/sp.gif" width=187 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">NXPing();</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">theEvent = [NXApp getNextEvent:(NX_LMOUSEUPMASK</font><br>
<img src="../../../Images/sp.gif" width=390 height=1><font face="Courier" size="-1">| NX_LMOUSEDRAGGEDMASK)];</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if ( theEvent-&gt;type == NX_LMOUSEUP )</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">shouldLoop = NO;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* <i>Replace dynamic drawing with a static display</i></font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">[window setEventMask:oldMask];</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">During the wait imposed by <b>NXPing()</b>, mouse-dragged (and mouse-moved) events will be coalesced in the event queue.&nbsp; When the application next gets an event, it will be a more up-to-date one than if <b>NXPing()</b> had not been used.&nbsp; Coalescing also serves to reduce the total amount of PostScript code generated.</font>

<p><font face="Times"><b>NXPing()</b> also lets an application more efficiently group its responses to a number of similar events.&nbsp; In the following example, the method that responds to key-down events uses the <b>peekNextEvent:into:</b> method to take all available key-down events from the event queue and display them at once.&nbsp; The use of <b>NXPing()</b> means that the example will be invoked less often than it otherwise would.&nbsp; However, it will consolidate events into fewer instructions for the Window Server.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">- keyDown:(NXEvent *)theEvent</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* <i>Check theEvent-&gt;data.key.charSet and</i></font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* <i>theEvent-&gt;data.key.charCode and set up the array of</i></font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* <i>characters to displayed</i></font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while ( 1 ) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Peek at the next event */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">NXEvent next;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">theEvent = [NXApp peekNextEvent:NX_ALLEVENTS into:&amp;next];</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Break the loop if there is no next event */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if ( !theEvent )</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Skip over key-up events */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">else if ( theEvent-&gt;type == NX_KEYUP ) {</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">[NXApp getNextEvent:NX_KEYUPMASK];</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">continue;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Respond only to key-down events */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">else if ( theEvent-&gt;type == NX_KEYDOWN ) {</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=215 height=1><font face="Courier" size="-1">* <i>Add the new character to the array to be displayed</i></font><br>
<img src="../../../Images/sp.gif" width=215 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">[NXApp getNextEvent:NX_KEYDOWNMASK];</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Break the loop on all other event types */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* <i>Display the array of characters</i></font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">NXPing();</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">return self;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The wait imposed by <b>NXPing()</b> may mean that there are more key-down events in the event queue each time this method is invoked.&nbsp; Since it's much more efficient for the application to send fewer instructions to the Window Server to display longer strings, this delay helps rather than hurts.</font>

<p><font face="Times">In the examples shown above, <b>NXPing()</b> is called just before the application is ready to get another event.&nbsp; This is the most appropriate place for it, since it means that the response to the last event will be complete--including the Window Server's part--before the response to the next event begins.&nbsp; It might be noted that both <b>NXPing()</b> and the functions and methods that get events flush the output buffer to the Window Server.&nbsp; However, the buffer isn't flushed if it's empty, so calling <b>NXPing()</b> before getting an event doesn't cause an extra operation to be performed.</font>

<p><font face="Times">Using <b>NXPing()</b> has two negative consequences:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It reduces the Window Server's throughput--the amount of PostScript code that it can interpret in a given time period.&nbsp; This is mainly due to the increased communication between the Server and the application.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">It reduces the granularity of the application's response to events.&nbsp; When events are coalesced in the event queue, cursor movements are tracked at greater intervals.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Therefore, you should not use <b>NXPing()</b> in a simple event loop unless the time needed to execute the PostScript code each event generates is longer than the time needed to complete the loop.</font>

<p><font face="Times">Although <b>NXPing()</b> is most often used in modal loops, it's also appropriate to use it in situations where information from the Window Server is needed before the application can proceed.&nbsp; For example, you may want to call <b>NXPing()</b> before entering a section of code that depends on previous PostScript instructions being executed without error.&nbsp; Since your application won't get notified of any errors until the PostScript code is actually executed, <b>NXPing()</b> allows it to wait for the notification before proceeding.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSFlush()</b> (Display PostScript)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXPointInRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXMouseInRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXPortFromName(), NXPortNameLookup()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get send rights to an application port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Listener.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">port_t <b>NXPortFromName(</b>const char *<i>name</i>, const char *<i>host</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">port_t <b>NXPortNameLookup(</b>const char *<i>name</i>, const char *<i>host</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXPortFromName()</b> and <b>NXPortNameLookup()</b> both return send rights to the port that's registered with the Network Name Server under <i>name</i> for the <i>host</i> machine.&nbsp; If <i>host</i> is a NULL pointer or an empty string, the local host is assumed.&nbsp; This is the most common usage.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An application generally registers with the Network Name Server under the name it uses for its executable file.&nbsp; For example, Digital Webster</font><font size="-2"><sup><sup>TM</sup></sup></font><font face="Times">registers under &quot;Webster&quot; and Mail under &quot;Mail&quot;.&nbsp; To get the port for Workspace, you should use the name NX_WORKSPACEREQUEST.&nbsp; Note, however, that this port isn't available until the application is fully initialized; requests for this port before Application's <b>appDidInit:</b> method is invoked will return PORT_NULL.</font>

<p><font face="Times">If no port is registered for the <i>name</i> application, <b>NXPortNameLookup()</b> returns PORT_NULL.&nbsp; However, <b>NXPortFromName()</b> tries to have <i>host</i>'s Workspace Manager launch the application.&nbsp; If the application can be launched and if it registers with the Network Name Server, send rights to its port are returned.&nbsp; This strategy is almost always successful for the local host.&nbsp; It's more problematic for a remote host, since the Workspace Manager is normally protected from messages coming from other machines.</font>

<p><font face="Times">If, in the end, no port can be found for the <i>name</i> application, <b>NXPortFromName()</b>, like <b>NXPortNameLookup()</b>, returns PORT_NULL.</font>

<p><font face="Times">Applications should use these two functions, rather than the Mach <b>netname_look_up()</b> function, to get send rights to a public port.&nbsp; Although both functions currently use <b>netname_look_up()</b> to find the port, this may not always be true.&nbsp; In future releases, Listener objects might &quot;check in&quot; with another server--such as the Bootstrap Server--rather than the Network Name Server. In this case, the two functions described here will continue to find and return the port associated with <i>name</i>, but <b>netname_look_up()</b> will not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Both functions return send rights to the public port of the <i>name</i> application on the <i>host</i> machine, or PORT_NULL if the port can't be found.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXPortNameLookup()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXPortFromName()</b></font>

<p><font face="Helvetica"><b>NXReadBitmap()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawBitmap()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXReadColor(), NXWriteColor()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Read and write a color from a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXColor <b>NXReadColor(</b>NXTypedStream *<i>stream</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXWriteColor(</b>NXTypedStream *<i>stream</i>, NXColor <i>color</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXReadColor()</b> reads a color from the typed stream, <i>stream</i>, and returns it.&nbsp; <b>NXWriteColor()</b> writes a color value, <i>color</i>, to a typed stream.&nbsp; The stream can be connected to a file, to memory, or to some other repository for data.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">NXColor values should be read and written only using these functions.&nbsp; When a color is written by <b>NXWriteColor()</b> and then read back by <b>NXReadColor()</b>, the color is guaranteed to be the same.&nbsp; This cannot be guaranteed if NXColor structures are read and written directly--for example, through standard C functions like <b>fread()</b> and <b>fwrite()</b>.&nbsp; The internal format of an NXColor data structure is not specified and therefore may change in future releases.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXReadColor()</b> returns the color value it reads.</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times"><b>NXReadColor()</b> raises an NX_newerTypedStream exception if the data it's expected to read is not of type NXColor.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXSetColor()</b>, <b>NXConvertRGBAToColor()</b>, <b>NXConvertColorToRGBA()</b>, <b>NXEqualColor()</b>, <b>NXRedComponent()</b>, <b>NXChangeRedComponent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXReadColorFromPasteboard(), NXWriteColorToPasteboard()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Read and write NXColor data on the pasteboard

<p><br><br><br>

<p></font><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXColor <b>NXReadColorFromPasteboard(</b>id <i>pasteboard</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXWriteColorToPasteboard(</b>id <i>pasteboard</i>, NXColor <i>color</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Use these functions to read and write NXColor data on a pasteboard</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXReadColorFromPasteboard()</b> looks at <i>pasteboard</i> to see if it contains data of NXColorPboardType.&nbsp; If it finds color, it then checks to see if the application can import alpha, and, if not, removes any alpha component before returning the NXColor.</font>

<p><font face="Times"><b>NXWriteColorToPasteboard()</b> writes the NXColor <i>color</i> to the Pasteboard object <i>pasteboard</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXReadColorFromPasteboard()</b> returns the color found on the pasteboard; if no color is found, it returns NX_COLORBLACK.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times">Pasteboard class,</font> <img src="../../../Images/c2D.gif" width=8 height=4> <font face="Times"><b>doesImportAlpha</b> (Application class)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXReadPixel()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Read a pixel value at the specified location</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXColor <b>NXReadPixel(</b>const NXPoint *<i>location</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXReadPixel()</b> returns the color of the pixel at the given location.&nbsp; The <i>location</i> argument is taken in the current coordinate system--in other words, you must lock focus on the View that contains the pixel that you wish to query, and then pass the coordinate for the pixel in the View's coordinate system.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXReadPoint(), NXWritePoint(), NXReadRect(), NXWriteRect(), NXReadSize(), NXWriteSize()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Read or write NEXTSTEP-defined data types to a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXReadPoint(</b>NXTypedStream *<i>typedStream</i>, NXPoint *<i>aPoint</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXWritePoint(</b>NXTypedStream *<i>typedStream</i>, const NXPoint *<i>aPoint</i><b>)</b></font><br>
<font face="Times">void <b>NXReadRect(</b>NXTypedStream *<i>typedStream</i>, NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">void <b>NXWriteRect(</b>NXTypedStream *<i>typedStream</i>, const NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">void <b>NXReadSize(</b>NXTypedStream *<i>typedStream</i>, NXSize *<i>aSize</i><b>)</b></font><br>
<font face="Times">void <b>NXWriteSize(</b>NXTypedStream *<i>typedStream</i>, const NXSize *<i>aSize</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions read and write NXPoint, NXSize, or NXRect structures from and to an open typed stream.&nbsp; They can be used within <b>read:</b> or <b>write:</b> methods for archiving purposes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXReadPoint()</b>, <b>NXReadSize()</b>, and <b>NXReadRect()</b> each take a typed stream as a first argument and place the data read from the stream into the location specified by the second argument.</font>

<p><font face="Times"><b>NXWritePoint()</b>, <b>NXWriteSize()</b>, and <b>NXWriteRect()</b> write the data pointed to by their second arguments to the typed streams<i>.</i></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times">All six functions check whether the typed stream has been opened for reading or for writing and raise a TYPEDSTREAM_FILE_INCONSISTENCY exception if the type isn't correct.&nbsp; For example, if <b>NXReadPoint()</b> is called and the stream was opened for writing, the exception is raised.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The functions for reading raise a TYPEDSTREAM_FILE_INCONSISTENCY exception if the data to be read is not of the expected type.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXOpenTypedStream()</b> (Common Functions), <b>NXReadType()</b> (Common Functions), <b>NXReadArray()</b> (Common Functions), <b>NXReadObject()</b> (Common Functions)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXReadRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadPoint()</b></font>

<p><font face="Helvetica"><b>NXReadSize()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadPoint()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXReadWordTable(), NXWriteWordTable()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Read or write Text object's word tables</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Text.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXReadWordTable(</b>NXZone *<i>zone</i>, NXStream *<i>stream</i>, unsigned char **<i>preSelSmart</i>, unsigned char **<i>postSelSmart</i>, unsigned char **<i>charCategories</i>, NXFSM **<i>wrapBreaks</i>, int *<i>wrapBreaksCount</i>, NXFSM **<i>clickBreaks</i>, int *<i>clickBreaksCount</i>, BOOL *<i>charWrap</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXWriteWordTable(</b>NXStream *<i>stream</i>, const unsigned char *<i>preSelSmart</i>, const unsigned char *<i>postSelSmart</i>, const unsigned char *<i>charCategories</i>, const NXFSM *<i>wrapBreaks</i>, int <i>wrapBreaksCount</i>, const NXFSM *<i>clickBreaks</i>, int <i>clickBreaksCount</i>, BOOL <i>charWrap</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions read and write the Text object's word tables.&nbsp; Given <i>stream</i>, a pointer to a stream containing appropriate data, <b>NXReadWordTable()</b> creates word tables in the memory zone specified by <i>zone</i>.&nbsp; Conversely, given references to word table structures, <b>NXWriteWordTable()</b> records the structures in the stream referred to by <i>stream</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The word table arguments taken by these two functions are identical except for the degree of indirection.&nbsp; For each table it will create, <b>NXReadWordTable()</b> takes the address of a pointer.&nbsp; When the function returns, these pointers will point to the newly created tables.&nbsp; On the other hand, <b>NXWriteWordTable()</b> takes a pointer to each table it will record to the stream.</font>

<p><font face="Times"><i>preSelSmart</i> and <i>postSelSmart</i> refer to smart cut and paste tables.&nbsp; These tables specify which characters preceding or following the selection will be treated as equivalent to a space.&nbsp; <i>wrapBreaks</i> refers to a break table, the table that a Text object uses to determine word boundaries for line breaks.&nbsp; <i>wrapBreaksCount</i> gives the number of elements in the array of NXFSM structures that make up the break table.&nbsp; Similarly, <i>clickBreaks</i> and <i>clickBreaksCount</i> refer to a click table, the table that determines word boundaries for word selection.&nbsp; Finally, <i>charWrap</i> refers to a flag indicating whether words whose length exceeds the Text object's line length should be wrapped on a character-by-character basis.</font>

<p><font face="Times">Word tables can be set through the defaults system.&nbsp; The global parameter NXWordTablesFile determines which word table file an application will use.&nbsp; The value for this parameter can be either a file name or the special values &quot;English&quot; or &quot;C&quot;.&nbsp; The special values cause built-in tables for those languages to apply.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times"><b>NXReadWordTable()</b> raises an NX_wordTablesRead exception if it's unable to open <i>stream</i>.&nbsp; <b>NXWriteWordTable()</b> raises an NX_wordTablesWrite exception if it's unable to open <i>stream</i> or if <i>charCategories</i>, <i>wrapBreaks</i>, or <i>clickBreaks</i> is NULL.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXRectClip(), NXRectClipList(), NXRectFill(), NXRectFillList(), NXRectFillListWithGrays(), NXEraseRect(), NXHighlightRect()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Optimize drawing</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXRectClip(</b>const NXRect *<i>aRect</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXRectClipList(</b>const NXRect *<i>rects</i>, int <i>count</i><b>)</b></font><br>
<font face="Times">void <b>NXRectFill(</b>const NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">void <b>NXRectFillList(</b>const NXRect *<i>rects</i>, int <i>count</i><b>)</b></font><br>
<font face="Times">void <b>NXRectFillListWithGrays(</b>const NXRect *<i>rects</i>, const float *<i>grays</i>, int <i>count</i><b>)</b></font><br>
<font face="Times">void <b>NXEraseRect(</b>const NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">void <b>NXHighlightRect(</b>const NXRect *<i>aRect</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions provide efficient ways to carry out common drawing operations on rectangular paths.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXRectClip()</b> intersects the current clipping path with the rectangle referred to by its argument, <i>aRect</i>, to determine a new clipping path.&nbsp; <b>NXRectClipList()</b> takes an array of <i>count</i> number of rectangles and intersects the current clipping path with each of them.&nbsp; Thus, the new clipping path is the graphic intersection of all the rectangles and the original clipping path.&nbsp; Both functions work through the <b>rectclip</b> operator.&nbsp; After computing the new clipping path, the current path is reset to empty.</font>

<p><font face="Times"><b>NXRectFill()</b> fills the rectangle referred to by its argument with the current color.&nbsp; <b>NXRectFillList()</b> fills a list of <i>count </i>rectangles with the current color.&nbsp; Both work through the <b>rectfill</b> operator.</font>

<p><font face="Times"><b>NXRectFillListWithGrays()</b> takes a list of <i>count</i> rectangles and a matching list of <i>count</i> gray values.&nbsp; The first rectangle is filled with the first gray, the second rectangle with the second gray, and so on.&nbsp; There must be an equal number of rectangles and gray values.&nbsp; The rectangles should not overlap; the order in which they'll be filled can't be guaranteed.&nbsp; This function alters the current color of the current graphics state, setting it unpredictably to one of the values passed in <i>grays</i>.</font>

<p><font face="Times">As its name suggests, <b>NXEraseRect()</b> erases the rectangle referred to by its argument, filling it with white.&nbsp; It does not alter the current color.</font>

<p><font face="Times"><b>NXHighlightRect()</b> uses the <b>compositerect</b> operator to highlight the rectangle referred to by its argument.&nbsp; Light gray becomes white, and white becomes light gray.&nbsp; This function must be called twice, once to highlight the rectangle and once to unhighlight it; the rectangle should not be left in its highlighted state.&nbsp; When not drawing on the screen, the compositing operation is replaced by one that fills the rectangle with light gray.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXSetRect()</b>, <b>NXUnionRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXRectClipList()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRectClip()</b></font>

<p><font face="Helvetica"><b>NXRectFill()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRectClip()</b></font>

<p><font face="Helvetica"><b>NXRectFillList()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRectClip()</b></font>

<p><font face="Helvetica"><b>NXRectFillListWithGrays()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRectClip()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXRedComponent(), NXGreenComponent(), NXBlueComponent(), NXCyanComponent(), NXMagentaComponent(), NXYellowComponent(), NXBlackComponent(), NXHueComponent(), NXSaturationComponent(), NXBrightnessComponent(), NXGrayComponent(), NXAlphaComponent()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Isolate one component of a color</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">float <b>NXRedComponent(</b>NXColor <i>color</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">float <b>NXGreenComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXBlueComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXCyanComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXMagentaComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXYellowComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXBlackComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXHueComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXSaturationComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXBrightnessComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXGrayComponent(</b>NXColor <i>color</i><b>)</b></font><br>
<font face="Times">float <b>NXAlphaComponent(</b>NXColor <i>color</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Each of these functions takes an NXColor structure as an argument and returns the value of one component of the color, as indicated by the function name.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Each function returns a component of the color passed as an argument.&nbsp; The function name indicates which component is returned.&nbsp; <b>NXAlphaComponent()</b> returns NX_NOALPHA if a coverage component is not specified for the color.&nbsp; Otherwise, all return values lie in the range 0.0 through 1.0.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXChangeRedComponent()</b>, <b>NXSetColor()</b>, <b>NXConvertRGBAToColor()</b>, <b>NXConvertColorToRGBA()</b>, <b>NXEqualColor()</b>, <b>NXReadColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXRegisterErrorReporter(), NXRemoveErrorReporter(), NXReportError()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Specify an error reporter</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/errors.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXRegisterErrorReporter(</b>int <i>min</i>, int <i>max</i>, NXErrorReporter *<i>proc</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXRemoveErrorReporter(</b>int <i>code</i><b>)</b></font><br>
<font face="Times">void <b>NXReportError(</b>NXHandler *<i>errorState</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These three functions set up an error reporting procedure, which typically includes writing a message to <b>stderr</b>.&nbsp; When an error is raised (using <b>NX_RAISE()</b>), each of the nested error handlers is notified successively until one can handle the error without forwarding it to the next level.&nbsp; This handler executes its error handling code, which usually includes calling <b>NXReportError()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXReportError()</b>'s <i>errorState</i> argument contains information about the error, including an error code that identifies the error. (The NXHandler structure is defined in the header file <b>objc/error.h</b>.)&nbsp; <b>NXReportError()</b> uses this error code to search the codes for which error reporters have been registered (see below).&nbsp; When it finds a match, it calls the corresponding procedure. If no matching error code is found, an unknown error code message is written to <b>stderr</b>.</font>

<p><font face="Times">The Application Kit registers its error reporters in the <b>initialize</b> class method of the Application object.&nbsp; Other applications that subclass Application will use these reporters by default, but they can also define their own set of errors and a reporter.&nbsp; To create your own range of error codes and corresponding error messages, call <b>NXRegisterErrorReporter()</b>.&nbsp; Its first two arguments define the range of numbers you will use as error codes.&nbsp; Applications that define their own reporter should begin their range at NX_APPBASE.&nbsp; The third argument points to the procedure that matches an error code in that range with an error message.</font>

<p><font face="Times"><b>NXRemoveErrorReporter()</b> removes the error reporter that had been assigned to the error <i>code</i> passed in as its argument.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NX_RAISE()</b> (Common Functions), <b>NXDefaultTopLevelErrorHandler()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXRemoteMethodFromSel(), NXResponsibleDelegate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Match an Objective C method and a receiver to a remote message</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Listener.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXRemoteMethod *<b>NXRemoteMethodFromSel(</b>SEL <i>aSelector</i>, NXRemoteMethod *<i>methods</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">id <b>NXResponsibleDelegate(</b>id <i>aListener</i>, SEL <i>aSelector</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These two functions are used within subclasses of the Listener class.&nbsp; When you define a Listener subclass using the <b>msgwrap </b>utility, calls to these functions are generated automatically.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXRemoteMethodFromSel()</b> looks up the <i>aSelector</i> method in a table of remote methods that have been declared for the Listener subclass.&nbsp; The second argument, <i>methods</i>, is a pointer to the beginning of the table.&nbsp; A pointer to the table entry for the <i>aSelector</i> method is returned.</font>

<p><font face="Times"><b>NXResponsibleDelegate()</b> returns the <b>id</b> of the object that responds to <i>aSelector</i> remote messages received by <i>aListener</i>.&nbsp; That object will be the Listener's delegate, or the delegate of the Listener's delegate.&nbsp; A Listener normally entrusts the remote messages it receives to its delegate, but if its delegate has a delegate of its own, the Listener defers to that object.&nbsp; Thus if the Application object is the Listener's delegate, the Application object's delegate will be given the first chance to respond to <i>aSelector</i> messages.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXRemoteMethodFromSel()</b> returns a pointer to the entry for the <i>aSelector</i> method in a table of remote methods kept by a Listener subclass, or NULL if there is no entry for the method.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXResponsibleDelegate()</b> returns the delegate that responds to <i>aSelector</i> remote messages received by <i>aListener</i>.&nbsp; If the delegate of <i>aListener</i>'s delegate can respond to <i>aSelector</i> messages, the delegate of <i>aListener</i>'s delegate is returned.&nbsp; If not and <i>aListener</i>'s delegate can respond to <i>aSelector</i> messages, <i>aListener</i>'s delegate is returned.&nbsp; If neither delegate responds to <i>aSelector</i> messages (or <i>aListener</i> doesn't have a delegate), <b>nil</b> is returned.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXRemoveErrorReporter()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRegisterErrorReporter()</b></font>

<p><font face="Helvetica"><b>NXReportError()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRegisterErrorReporter()</b></font>

<p><font face="Helvetica"><b>NXResetUserAbort()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXUserAborted()</b></font>

<p><font face="Helvetica"><b>NXResponsibleDelegate()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRemoteMethodFromSel()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXRunAlertPanel(), NXRunLocalizedAlertPanel(), NXGetAlertPanel(), NXFreeAlertPanel()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create or free an attention panel</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Panel.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NXRunAlertPanel(</b>const char *<i>title</i>, const char *<i>msg</i>, const char *<i>defaultButton</i>, const char *<i>alternateButton</i>, const char *<i>otherButton</i>, <i>...</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>NXRunLocalizedAlertPanel(</b>const char *<i>table</i>, const char *<i>title</i>, const char *<i>msg</i>, const char *<i>defaultButton</i>, const char *<i>alternateButton</i>, const char *<i>otherButton</i>, ...<b>)</b></font><br>
<font face="Times">id <b>NXGetAlertPanel(</b>const char *<i>title</i>, const char *<i>msg</i>, const char *<i>firstButton</i>, const char *<i>alternateButton</i>, const char *<i>otherButton</i>, <i>...</i><b>)</b></font><br>
<font face="Times">void <b>NXFreeAlertPanel(</b>id <i>alertPanel</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXRunAlertPanel()</b>, <b>NXRunLocalizedAlertPanel()</b> and <b>NXGetAlertPanel()</b> all create an attention panel that alerts the user to some consequence of a requested action; the panel may also let the user cancel or modify the action.&nbsp; <b>NXRunAlertPanel() </b>and <b>NXRunLocalizedAlertPanel()</b> create the panel and run it in a modal event loop; <b>NXGetAlertPanel()</b> returns a Panel object that you can use in a modal session.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">These functions take the same set of arguments.&nbsp; The first argument is the title of the panel, which should be at most a few words long.&nbsp; The default title is &quot;Alert&quot;.&nbsp; The next argument is the message that's displayed in the panel.&nbsp; It can use <b>printf()</b>-style formatting characters; any necessary arguments should be listed at the end of the function's argument list (after the <i>otherButton</i> argument).&nbsp; For more information on formatting characters, see the UNIX manual page for <b>printf()</b>.</font>

<p><font face="Times">There are arguments to supply titles for up to three buttons, which will be displayed in a row across the bottom of the panel.&nbsp; The panel created by <b>NXRunAlertPanel()</b> must have at least one button, which will have the symbol for the Return key; if you pass a NULL title to the other two buttons, they won't be created.&nbsp; If NULL is passed as the <i>defaultButton</i>, &quot;OK&quot; will be used as its title.&nbsp; The panel created by <b>NXGetAlertPanel()</b> doesn't have to have any buttons.&nbsp; If you supply a title for <i>firstButton</i>, it will be displayed with the symbol for the Return key.</font>

<p><font face="Times"><b>NXRunAlertPanel()</b> not only creates the panel, it puts the panel on screen and runs it using the <b>runModalFor:</b> method defined in the Application class.&nbsp; This method sets up a modal event loop that causes the panel to remain on screen until the user clicks one of its buttons.&nbsp; <b>NXRunAlertPanel()</b> then removes the panel from the screen list and returns a value that indicates which of the three buttons the user clicked:&nbsp; NX_ALERTDEFAULT, NX_ALERTALTERNATE, or NX_ALERTOTHER.&nbsp; (If an error occurred while creating the panel, NX_ALERTERROR is returned.)&nbsp; For efficiency, <b>NXRunAlertPanel()</b> creates the panel the first time it's called and reuses it on subsequent calls, reconfiguring it if necessary.</font>

<p><font face="Times"><b>NXGetAlertPanel()</b> doesn't set up a modal event loop; instead, it returns a Panel that can be used to set up a modal session.&nbsp; A modal session is useful for allowing the user to interrupt the program.&nbsp; During a modal session, you can perform activities while the panel is displayed and check at various points in your program whether the user has clicked one of the panel's buttons.</font>

<p><font face="Times">To set up a modal session, send the Application object a <b>beginModalSession:for:</b> message with the Panel returned by <b>NXGetAlertPanel()</b> as its second argument.&nbsp; When you want to check if the user has clicked one of the Panel's buttons, use <b>runModalSession:</b>.&nbsp; To end the modal session, use <b>endModalSession:</b>.&nbsp; When you're finished with the Panel created by <b>NXGetAlertPanel()</b>, you must free it by passing it to <b>NXFreeAlertPanel()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXRunAlertPanel()</b> returns a constant that indicates which button in the attention panel the user clicked.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXRunLocalizedAlertPanel()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRunAlertPanel()</b></font>

<p><font face="Helvetica"><b>NXSaturationComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXScanALine(), NXDrawALine()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Calculate or draw line of text (in Text object)</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Text.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NXScanALine(</b>id <i>self</i>, NXLayInfo *<i>layInfo</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>NXDrawALine(</b>id <i>self</i>, NXLayInfo *<i>layInfo</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">A Text object calls the first two functions to calculate and draw a line of text.&nbsp; Each function's first argument is the Text object itself.&nbsp; The second argument is an NXLayInfo structure, as described in the &quot;Types and Constants&quot; section.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">To determine the placement of characters in a line, <b>NXScanALine()</b> takes into account line width, text alignment, font metrics, and other data from the Text object.&nbsp; It stores the results of its calculations in global variables.</font>

<p><font face="Times">A Text object calls <b>NXDrawALine()</b> to draw a line of text.&nbsp; The global variables set by <b>NXScanALine()</b> provide <b>NXDrawALine()</b> with the information it needs to draw each line of text.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXScanALine()</b> returns 1 only if a word's length exceeds the width of a line and the Text object's <b>charWrap</b> instance variable is NO.&nbsp; Otherwise, it returns 0.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXDrawALine()</b> has no significant return value.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>NXSetColor()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the current color</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/color.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXSetColor(</b>NXColor <i>color</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function uses PostScript operators to make <i>color</i> the current color of the current graphics state.&nbsp; If <i>color</i> includes a coverage component (if <b>NXAlphaComponent()</b> returns anything but NX_NOALPHA), it also sets the current coverage. However, coverage will not be set when printing.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXEqualColor()</b>, <b>NXConvertRGBAToColor()</b>, <b>NXConvertColorToRGBA()</b>, <b>NXRedComponent()</b>, <b>NXChangeRedComponent()</b>, <b>NXReadColor()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXSetGState(), NXCopyCurrentGState()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set or copy current graphics state object</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/publicWraps.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXSetGState(</b>int <i>gstate</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXCopyCurrentGState(</b>int <i>gstate</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions set the current PostScript graphics state.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXSetGState()</b> is a C function cover for the PostScript <b>setgstate</b> operator.&nbsp; It sets the current graphics state to that specified by <i>gstate</i>.</font>

<p><font face="Times"><b>NXCopyCurrentGState()</b> takes a snapshot of the current graphic state and assigns it the number <i>gstate</i>.&nbsp; Generally, a snapshot should be taken only when the current path is empty and the current clip path is in its default state.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>NXSetRect(), NXOffsetRect(), NXInsetRect(), NXIntegralRect(), NXDivideRect()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Modify a rectangle</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXSetRect(</b>NXRect *<i>aRect</i>, NXCoord <i>x</i>, NXCoord <i>y</i>, NXCoord <i>width</i>, NXCoord <i>height</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXOffsetRect(</b>NXRect *<i>aRect</i>, NXCoord <i>dx</i>, NXCoord <i>dy</i><b>)</b></font><br>
<font face="Times">void <b>NXInsetRect(</b>NXRect *<i>aRect</i>, NXCoord <i>dx</i>, NXCoord <i>dy</i><b>)</b></font><br>
<font face="Times">void <b>NXIntegralRect(</b>NXRect *<i>aRect</i><b>)</b></font><br>
<font face="Times">NXRect *<b>NXDivideRect(</b>NXRect *<i>aRect</i>, NXRect *<i>bRect</i>, NXCoord <i>slice</i>, int <i>edge</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions modify the <i>aRect</i> argument.&nbsp; It's assumed that all arguments are expressed within the same coordinate system.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first function, <b>NXSetRect()</b>, sets the values in the NXRect structure specified by its first argument, <i>aRect</i>, to the values passed in the other arguments.&nbsp; It provides a convenient way to initialize an NXRect structure.</font>

<p><font face="Times">The next two functions, <b>NXOffsetRect()</b> and <b>NXInsetRect()</b>, are illustrated in Figure 0-3.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F2.gif" width=365 height=179></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Figure 0-3</b></font><font face="Times">.&nbsp; Inset and Offset Rectangles</font>

<p><br><br>

<p><font face="Times"><b>NXOffsetRect()</b> shifts the location of the rectangle by <i>dx</i> along the x-axis and by <i>dy</i> along the y-axis.&nbsp; <b>NXInsetRect()</b> alters the rectangle so that the two sides that are parallel to the y-axis are inset by <i>dx</i> and the two sides parallel to the x-axis are inset by <i>dy</i>.</font>

<p><font face="Times"><b>NXIntegralRect()</b> alters the rectangle so that none of its four defining values (<i>x</i>, <i>y</i>, <i>width</i>, and <i>height</i>) have fractional parts. The values are raised or lowered to the nearest integer, as appropriate, so that the new rectangle completely encloses the old rectangle.&nbsp; These alterations ensure that the sides of the new rectangle lie on pixel boundaries, if the rectangle is defined in a coordinate system that has its coordinate origin on the corner of four pixels and a unit of length along either axis equal to one pixel.&nbsp; If the rectangle's width or height is 0 (or negative), it's set to a rectangle with origin at (0.0, 0.0) and with 0 width and height.</font>

<p><font face="Times"><b>NXDivideRect()</b> divides a rectangle in two.&nbsp; It cuts a slice off the rectangle specified by <i>aRect</i> to form a new rectangle, which it stores in the structure specified by <i>bRect</i>.&nbsp; The rectangle specified by <i>aRect</i> is modified accordingly.&nbsp; The size of the slice taken from the rectangle is indicated by <i>slice</i>; it's taken from the side of the rectangle indicated by <i>edge</i>.&nbsp; The constants for <i>edge </i>can be:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_XMIN</font></td>

<td><font face="Times">The slice is made parallel to the y-axis, along the side with the smallest x-coordinate values.</font></td></tr>

<tr valign=top>

<td width=124 height=12></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_YMIN</font></td>

<td><font face="Times">The slice is made parallel to the x-axis, along the side with the smallest y-coordinate values.</font></td></tr>

<tr valign=top>

<td width=124 height=12></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_XMAX</font></td>

<td><font face="Times">The slice is made parallel to the y-axis, along the side with the greatest x-coordinate values.</font></td></tr>

<tr valign=top>

<td width=124 height=12></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_YMAX</font></td>

<td><font face="Times">The slice is made parallel to the x-axis, along the side with the greatest y-coordinate values.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXSetRect()</b>, <b>NXOffsetRect()</b>, <b>NXInsetRect()</b>, and <b>NXIntegralRect()</b> have no significant return values.&nbsp; <b>NXDivideRect() </b>returns a pointer to the new rectangle, <i>bRect</i>.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXUnionRect()</b>, <b>NXMouseInRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXSetServicesMenuItemEnabled(), NXIsServicesMenuItemEnabled()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Determine whether an item is included in Services menus</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Listener.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NXSetServicesMenuItemEnabled(</b>const char *<i>item,</i> BOOL <i>flag</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">BOOL <b>NXIsServicesMenuItemEnabled(</b>const char *<i>item</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXSetServicesMenuItemEnabled()</b> is used by a service-providing application to determine whether the Services menus of other applications will contain the <i>item</i> command enabling users to request its services.&nbsp; If <i>flag</i> is YES, the Application Kit will build Services menus for other applications that include the <i>item</i> command.&nbsp; If <i>flag</i> is NO, <i>item</i> won't appear in any application's Services menu.&nbsp; <i>item</i> should be the same character string entered in the &quot;Menu Item:&quot; field of the services file.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Service-providing applications should let users decide whether the Services menus of other applications they use should include the <i>item</i> command.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXSetServicesMenuItemEnabled()</b> returns 0 if it's successful in enabling or disabling the <i>item</i> command, and a number other than 0 if not.&nbsp; <b>NXIsServicesMenuItemEnabled()</b> returns YES if <i>item</i> is currently enabled, and NO if it's not.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXSetTopLevelErrorHandler()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDefaultTopLevelErrorHandler()</b></font>

<p><font face="Helvetica"><b>NXSizeBitmap()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDrawBitmap()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXTextFontInfo()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Calculate font ascender, descender, and line height</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Text.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXTextFontInfo(</b>id <i>font</i>, NXCoord *<i>ascender</i>, NXCoord *<i>descender</i>, NXCoord *<i>lineHeight</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXTextFontInfo()</b> calculates, and returns by reference, the ascender, descender, and line height values for the Font given by <i>font.</i></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXTopLevelErrorHandler()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXDefaultTopLevelErrorHandler()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXUnionRect(), NXIntersectionRect()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Compute a third rectangle from two rectangles</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXRect *<b>NXUnionRect(</b>const NXRect *<i>aRect</i>, NXRect *<i>bRect</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXRect *<b>NXIntersectionRect(</b>const NXRect *<i>aRect</i>, NXRect *<i>bRect</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXUnionRect()</b> figures the graphic union of two rectangles--that is, the smallest rectangle that completely encloses both.&nbsp; It takes pointers to the two rectangles as arguments and replaces the second rectangle with their union.&nbsp; If one rectangle has zero (or negative) width or height, <i>bRect</i> is replaced with the other rectangle.&nbsp; If both of the rectangles have 0 (or negative) width or height, <i>bRect</i> is set to a rectangle with its origin at (0.0, 0.0) and with 0 width and height.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXIntersectionRect()</b> figures the graphic intersection of two rectangles--the rectangle that encloses any area they have in common.&nbsp; It takes pointers to the two rectangles as arguments.&nbsp; If the rectangles overlap, it replaces the second one, <i>bRect</i>, with their intersection.&nbsp; If the two rectangles don't overlap, <i>bRect</i> is set to a rectangle with its origin at (0.0, 0.0) and with a 0 width and height.&nbsp; Adjacent rectangles that share only a side are not considered to overlap.</font>

<p><font face="Times">Both functions assume that all arguments are expressed within the same coordinate system.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXUnionRect()</b> returns its second argument (<i>bRect</i>), a pointer to the union of the two rectangles unless both rectangles have 0 (or negative) width or height, in which case it returns a pointer to a NULL rectangle.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If the two rectangles overlap, <b>NXIntersectionRect()</b> returns its second argument (<i>bRect</i>), a pointer to their intersection.&nbsp; If the rectangles don't overlap, it returns a pointer to a NULL rectangle.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXIntersectsRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXUnnameObject()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXGetNamedObject()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXUpdateDynamicServices()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Re-register provided services</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Listener.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NXUpdateDynamicServices(</b>void<b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXUpdateDynamicServices()</b> is used by a service-providing application to re-register the services it's willing to provide.&nbsp; To do this, you create a file with the extension &quot;.service&quot; and place it in the application's path, or in <b>/NextLibrary/Services</b>, <b>/LocalLibrary/Services</b>, or <b>~/Library/Services</b>.&nbsp; The content of the file is identical to a normal service file (see the &quot;Other Features&quot; section for a description of service file format).&nbsp; You then call this function.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NXUserAborted(), NXResetUserAbort()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Report user's request to abort</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/Application.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">BOOL <b>NXUserAborted(</b>void<b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>NXResetUserAbort(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NXUserAborted()</b> returns YES if the user pressed Command-period since the application last got an event in the main event loop, and NO if not.&nbsp; Command-period signals the user's intention to abort an ongoing process.&nbsp; Applications should call this function repeatedly during a modal session and respond appropriately if it ever returns YES.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NXResetUserAbort()</b> resets the flag returned by <b>NXUserAborted()</b> to NO.&nbsp; It's called in the Application object's <b>run</b> method before getting each new event.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NXUserAborted()</b> returns YES if the user pressed Command-period, and NO otherwise.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NXUserName()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXHomeDirectory()</b></font>

<p><font face="Helvetica"><b>NXWindowList()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXCountWindows()</b></font>

<p><font face="Helvetica"><b>NXWriteColor()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadColor()</b></font>

<p><font face="Helvetica"><b>NXWriteColorToPasteboard()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadColorFromPasteboard()</b></font>

<p><font face="Helvetica"><b>NXWritePoint()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadPoint()</b></font>

<p><font face="Helvetica"><b>NXWriteRect()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadPoint()</b></font>

<p><font face="Helvetica"><b>NXWriteSize()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadPoint()</b></font>

<p><font face="Helvetica"><b>NXWriteWordTable()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXReadWordTable()</b></font>

<p><font face="Helvetica"><b>NXYellowComponent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NXRedComponent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NX_ASSERT()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Write an error message</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/nextstd.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NX_ASSERT(</b>int <i>exp</i>, char *<i>msg</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This macro, which is defined in the header file <b>appkit/nextstd.h</b>, writes an error message if the program was compiled with the NX_BLOCKASSERTS flag undefined and if <i>exp</i> is false.&nbsp; The message <i>msg</i> is written to <b>stderr</b> if the application was launched from a terminal.&nbsp; If the application was launched by the Workspace Manager, the message is written using <b>syslog()</b> with the priority set to LOG_ERR.&nbsp; Normally, <b>syslog()</b> writes messages to the Workspace Manager's console window.&nbsp; See the UNIX manual page for <b>syslog()</b> for more information about this function and how to write messages to places other than the console window.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If <i>exp</i> is true, no action is taken.&nbsp; Also, if the NX_BLOCKASSERTS flag is defined, a call to <b>NX_ASSERT()</b> has no effect.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NX_FREE()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_MALLOC()</b></font>

<p><font face="Helvetica"><b>NX_HEIGHT()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NX_MALLOC(), NX_REALLOC(), NX_FREE()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Allocate memory</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/nextstd.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><i>type-name</i> *<b>NX_MALLOC(</b><i>type-name</i> *<i>var</i>, <i>type-name</i>, int <i>num</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><i>type-name</i> *<b>NX_REALLOC(</b><i>type-name</i> *<i>var</i>, <i>type-name</i>, int <i>num</i><b>)</b></font><br>
<font face="Times">void <b>NX_FREE(</b>void <i>*pointer</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These macros allocate and free memory space by making calls to the standard C-library functions <b>malloc()</b>, <b>realloc()</b>, and <b>free()</b>.&nbsp; For more information about these functions, see their UNIX manual pages.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NX_MALLOC()</b> and <b>NX_REALLOC()</b> return a pointer of type <i>type-name</i> to the argument <i>var</i>.&nbsp; The amount of memory these two functions allocate is determined by multiplying <i>num</i> (which should be an <b>int</b>) by the number of bytes needed for the data type <i>type-name</i>.&nbsp; <b>NX_REALLOC()</b> should be used to change the size of the object <i>var</i>, just as <b>realloc()</b> would be used.&nbsp; These macros are shown below as they are defined in the header file <b>appkit/nextstd.h</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define&nbsp; NX_MALLOC(VAR, TYPE, NUM)&nbsp; \</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">((VAR) = (TYPE *) malloc((unsigned)(NUM)*sizeof(TYPE)))</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define&nbsp; NX_REALLOC(VAR, TYPE, NUM)&nbsp; \</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">((VAR) = (TYPE *) realloc((VAR), (unsigned)(NUM)*sizeof(TYPE)))</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NX_FREE()</b> deallocates the space pointed to by <i>pointer</i>.&nbsp; It does nothing if <i>pointer</i> is NULL.&nbsp; It's also defined in <b>appkit/nextstd.h</b>, as shown below:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define&nbsp; NX_FREE(PTR)&nbsp;&nbsp;&nbsp; free((PTR));</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NX_MALLOC()</b> and <b>NX_REALLOC()</b> return pointers to the space they allocate or NULL if the request for space cannot be satisfied.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NX_MAXX()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font>

<p><font face="Helvetica"><b>NX_MAXY()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font>

<p><font face="Helvetica"><b>NX_MIDX()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font>

<p><font face="Helvetica"><b>NX_MIDY()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NX_PSDEBUG</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Print the current PostScript context</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/nextstd.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>NX_PSDEBUG</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>NX_PSDEBUG</b> prints the current Display PostScript context to the standard output device, along with the class, object, and method in which the macro appears.&nbsp; This macro does nothing if the application is compiled with NX_BLOCKPSDEBUG defined.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NX_REALLOC()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_MALLOC()</b></font>

<p><font face="Helvetica"><b>NX_WIDTH()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NX_X(), NX_Y(), NX_WIDTH(), NX_HEIGHT(), NX_MAXX(), NX_MAXY(), NX_MIDX(), NX_MIDY()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Query an NXRect structure</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/graphics.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">NXCoord <b>NX_X(</b>NXRect <i>*aRect</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">NXCoord <b>NX_Y(</b>NXRect <i>*aRect</i><b>)</b></font><br>
<font face="Times">NXCoord <b>NX_WIDTH(</b>NXRect <i>*aRect</i><b>)</b></font><br>
<font face="Times">NXCoord <b>NX_HEIGHT(</b>NXRect <i>*aRect</i><b>)</b></font><br>
<font face="Times">NXCoord <b>NX_MAXX(</b>NXRect <i>*aRect</i><b>)</b></font><br>
<font face="Times">NXCoord <b>NX_MAXY(</b>NXRect <i>*aRect</i><b>)</b></font><br>
<font face="Times">NXCoord <b>NX_MIDX(</b>NXRect <i>*aRect</i><b>)</b></font><br>
<font face="Times">NXCoord <b>NX_MIDY(</b>NXRect <i>*aRect</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These macros return information about the NXRect structure referred to by <i>aRect</i>.&nbsp; An NXRect structure is defined by a point that locates the rectangle (x- and y-coordinates) and an extent that determines its size (a width and height as measured along the x- and y-axes).</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NX_X()</b> and <b>NX_Y()</b> return the x- and y-coordinates that locate the rectangle.&nbsp; These will be the smallest coordinate values within the rectangle.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NX_HEIGHT()</b> and <b>NX_WIDTH()</b> return the width and height of the rectangle.</font>

<p><font face="Times"><b>NX_MAXX()</b> and <b>NX_MAXY()</b> return the largest x- and y-coordinates in the rectangle.&nbsp; These are calculated by adding the width of the rectangle to the x-coordinate returned by <b>NX_X()</b> and by adding the height of the rectangle to the y-coordinate returned by <b>NX_Y()</b>.</font>

<p><font face="Times"><b>NX_MIDX()</b> and <b>NX_MIDY()</b> return the x- and y-coordinates that lie at the center of the rectangle, exactly midway between the smallest and largest coordinate values.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>NXSetRect()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NX_Y()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_X()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NX_ZONEMALLOC(), NX_ZONEREALLOC()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Allocate zone memory</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">appkit/nextstd.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><i>type-name</i> *<b>NX_ZONEMALLOC(</b>NXZone <i>zone, type-name</i> *<i>var</i>, <i>type-name</i>, int <i>num</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times"><i>type-name</i> *<b>NX_ZONEREALLOC(</b>NXZone <i>zone, type-name</i> *<i>var</i>, <i>type-name</i>, int <i>num</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These macros allocate and free memory space by making calls to the functions <b>NXZoneMalloc()</b> and <b>NXZoneRealloc()</b>.&nbsp; For more information about these functions, see their descriptions in Chapter 3.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>NX_ZONEMALLOC()</b> and <b>NX_ZONEREALLOC()</b> return a pointer of type <i>type-name</i> to the argument <i>var</i> allocated in <i>zone</i>. The amount of memory these two macros allocate is determined by multiplying <i>num</i> (which should be an <b>int</b>) by the number of bytes needed for the data type <i>type-name</i>.&nbsp; <b>NX_ZONEREALLOC()</b> should be used to change the size of the object <i>var</i>, just as <b>realloc()</b> or <b>NXZoneRealloc()</b> would be used.&nbsp; These macros are shown below as they are defined in the header file <b>appkit/nextstd.h</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define&nbsp; NX_ZONEMALLOC(Z, VAR, TYPE, NUM)&nbsp; \</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">((VAR) = (TYPE *) NXZoneMalloc((Z), \</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">(unsigned)(NUM)*sizeof(TYPE)))</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define&nbsp; NX_ZONEREALLOC(Z, VAR, TYPE, NUM)&nbsp; \</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">((VAR) = (TYPE *) NXZoneRealloc((Z), (char *)(VAR), \</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">(unsigned)(NUM)*sizeof(TYPE)))</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>NX_ZONEMALLOC()</b> and <b>NX_ZONEREALLOC()</b> return pointers to the space they allocate or NULL if the request for space cannot be satisfied.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>NX_ZONEREALLOC()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See NX_ZONEMALLOC()</b></font></td></tr>

</table>



<p>

</body>
</html>
