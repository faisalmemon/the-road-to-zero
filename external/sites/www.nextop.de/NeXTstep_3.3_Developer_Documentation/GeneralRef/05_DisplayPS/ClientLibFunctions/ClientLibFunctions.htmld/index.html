<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/GeneralRef/05_DisplayPS/ClientLibFunctions/ClientLibFunctions.rtf -->
<!-- Date: Sun Jun 28 20:04:49 1998 -->
<head>
<title>ClientLibFunctions</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSAddFD(), DPSRemoveFD()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Monitor a file descriptor</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSAddFD(</b>int <i>fd</i>, DPSFDProc <i>handler</i>, void *<i>userData</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSRemoveFD(</b>int <i>fd</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSAddFD()</b> registers the function <i>handler</i> to be called each time there is activity with the file specified by file descriptor <i>fd</i>. The function is called provided the following are true:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The file descriptor <i>fd</i> must be valid and open; typically <i>fd</i> is generated through a call to <b>open()</b>.&nbsp; There needn't be any data waiting to be read on <i>fd</i>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>priority</i>, an integer from 0 to 30, must be equal to or greater than the application's current priority threshold.&nbsp; See <b>DPSAddTimedEntry()</b> for a further explanation.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">DPSFDProc, <i>handler</i>'s defined type, takes the form</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void *<i>handler</i>(int <i>fd</i>, void *<i>userData</i>)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">where <i>fd</i> is the file descriptor that prompted the function call and <i>userData</i> is the same pointer that was passed as the third argument to <b>DPSAddFD()</b>.&nbsp; The <i>userData</i> pointer is provided as a convenience, allowing you to pass arbitrary data to <i>handler</i>.</font>

<p><font face="Times"><b>DPSRemoveFD()</b> removes the specified file descriptor from the list of those that the application will check.</font>

<p><font face="Times">Typically, <b>DPSAddFD()</b> is used to listen to a socket or pipe; it's rarely used to monitor a common file.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSAddPort()</b>, <b>DPSAddTimedEntry()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSAddNotifyPortProc(), DPSRemoveNotifyPortProc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the handler function for the notify port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSAddNotifyPortProc(</b>DPSPortProc <i>handler</i>, void *<i>userData</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSRemoveNotifyPortProc(</b>DPSPortProc <i>handler</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSAddNotifyPortProc()</b> registers <i>handler</i> as the function that's called when a message arrives on the notify port, the unique port, created through the <b>task_notify()</b> Mach function, on which notifications (such as port death) are sent.&nbsp; You don't need to create the notify port yourself; <b>DPSAddNotifyPortProc()</b> creates it for you if it doesn't already exist.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">DPSPortProc, <i>handler</i>'s defined type, takes the form</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Courier" size="-1">void</font> <font size="-1"><img src="../../../Images/c2A.gif" width=6 height=7></font><font face="Courier" size="-1"><i>handler</i>(msg_header_t *<i>msg</i>, void *<i>userData</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">where <i>msg</i> is a pointer to the message that was received at the port and <i>userData</i> is the same pointer that was passed as the second argument to <b>DPSAddNotifyPortProc()</b>.&nbsp; The <i>userData</i> pointer is provided as a convenience, allowing you to pass arbitrary data to <i>handler</i>.</font>

<p><font face="Times">The notify port can have only one handler at a time; adding a handler removes the current one.&nbsp; You can remove the port's handler without specifying a new one with the <b>DPSRemoveNotifyPortProc()</b> function.&nbsp; The function's argument must match the notify port's current handler.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSAddPort()</b>, <b>DPSAddTimedEntry()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSAddPort(), DPSRemovePort()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Monitor a Mach port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSAddPort(</b>port_t <i>port</i>, DPSPortProc <i>handler</i>, int <i>maxMsgSize</i>, void *<i>userData</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSRemovePort(</b>port_t <i>port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSAddPort()</b> registers the function <i>handler</i> to be called each time your application asks for an event or peeks at the event queue.&nbsp; The function is called provided the following are true:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Mach port <i>port</i>&nbsp; must be valid and it must hold a message waiting to be read.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>priority</i>, an integer from 0 to 30, must be equal to or greater than the application's current priority threshold.&nbsp; See <b>DPSAddTimedEntry()</b> for a further explanation.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">DPSPortProc, <i>handler</i>'s defined type, takes the form</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void *<i>handler</i>(msg_header_t *<i>msg</i>, void *<i>userData</i>)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">where <i>msg</i> is a pointer to the message that was received at the port and <i>userData</i> is the same pointer that was passed as the fourth argument to <b>DPSAddPort()</b>.&nbsp; The <i>userData</i> pointer is provided as a convenience, allowing you to pass arbitrary data to <i>handler</i>.</font>

<p><font face="Times">If, within <i>handler</i>, you want to call <b>msg_receive()</b> to receive further messages at the port, you must first call <b>DPSRemovePort()</b> to remove the port from the system's port set.&nbsp; (This is because your application can't receive messages from a port that's in a port set.)&nbsp; After your application is finished receiving messages directly from the port, it can call <b>DPSAddPort()</b> to have the system continue to monitor the port.</font>

<p><font face="Times">The contents of the message buffer <i>msg</i>, as received by <i>handler</i>, are invalid after the function returns.&nbsp; If you need to save any of the information that you find.</font>

<p><font face="Times">The <i>maxMsgSize</i> argument is an integer that gives the size, in bytes, of the largest message you expect to receive.</font>

<p><font face="Times"><b>DPSRemovePort()</b> removes the specified Mach port from the list of those that the application will check.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSAddFD()</b>, <b>DPSAddTimedEntry()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSAddTimedEntry(), DPSRemoveTimedEntry()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a timed entry</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">DPSTimedEntry <b>DPSAddTimedEntry(</b>double&nbsp; <i>period</i>, DPSTimedEntryProc <i>handler</i>, void *<i>userData</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSRemoveTimedEntry(</b>DPSTimedEntry <i>tag</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSAddTimedEntry()</b> registers <i>handler</i> as a &quot;timed entry,&quot; a function that's called repeatedly at a given time interval.&nbsp; <i>period </i>determines the number of seconds between calls to the timed entry.&nbsp; Whenever an application based on the Application Kit attempts to retrieve events from the event queue, it also checks (depending on <i>priority</i>) to determine whether any timed entries are due to be called.&nbsp; <i>userData</i> is a pointer that you can use to pass some data to the timed entry.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function registered as <i>handler</i> has the form:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void *<i>handler</i>(DPSTimedEntry <i>tag</i>, double <i>now</i>, void *<i>userData</i>)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">where <i>tag</i> is the timed entry identifier returned by <b>DPSAddTimedEntry()</b>, <i>now</i> is the number of seconds since some arbitrary point in the past, and <i>userData</i> is the pointer <b>DPSAddTimedEntry()</b> received when this timed entry was installed.</font>

<p><font face="Times">An application's priority threshold can be set explicitly as an integer from 0 to 31 through a call to <b>DPSGetEvent()</b> or <b>DPSPeekEvent()</b>.&nbsp; It's against this threshold that <i>priority</i> is measured (note that <i>priority</i> can be no greater than 30--the additional threshold level, 31, is provided to disallow all inter-event function calls).&nbsp; However, if you're using the Application Kit, you should access the event queue through Application class methods such as <b>getNextEvent:</b>.&nbsp; Although some of these methods let you set the priority threshold explicity, you typically invoke the methods that set it automatically.&nbsp; Such methods use only three priority levels:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Constant</b></font></td>

<td><font face="Helvetica"><b>Meaning</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_BASETHRESHOLD</font></td>

<td><font face="Times">Normal execution</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_RUNMODALTHRESHOLD</font></td>

<td><font face="Times">An attention panel is being run</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">NX_MODALRESPTHRESHOLD</font></td>

<td><font face="Times">A modal event loop is being run</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">When applicable, you should use these constants as the value for <i>priority</i>.&nbsp; For example, if you want <i>handler</i> to be called during normal execution, but not if an attention panel or a modal loop is running, then you would set <i>priority</i> to NX_BASETHRESHOLD.</font>

<p><font face="Times"><b>DPSRemoveTimedEntry()</b> removes a previously registered timed entry.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSAddTimedEntry()</b> returns a number identifying the timed entry or</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1 to indicate an error.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSAsynchronousWaitContext()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Procede asynchronously while PostScript code is executed</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSAsynchronousWaitContext(</b>DPSContext <i>context</i>, DPSPingProc <i>handler</i>,</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">void *<i>userData</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function is similar to the more familiar <b>DPSWaitContext()</b> functions, except that rather than wait for all PostScript code to execute, it returns immediately, allowing your application to procede while the PostScript code is executed in the background. The DPSPingProc function <i>handler</i> is called (with <i>context</i> and <i>userData</i> as its two arguments) when all the PostScript code has been executed.&nbsp; The DPSPingProc function takes the form</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void *<i>handler</i>(DPSContext <i>context</i>, void *<i>userData</i>);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">Be careful when you use this function; you mustn't send more PostScript code while waiting for the handler to be called.&nbsp; In general, it's best to not make any demands on the Application Kit or the Client Library if you're waiting for an asynchronous handler to return.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>DPSCreateContext(), DPSCreateContextWithTimeoutFromZone(), DPSCreateNonsecureContext(), DPSCreateStreamContext()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a PostScript execution context</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">DPSContext <b>DPSCreateContext(</b>const char *<i>hostName</i>, const char *<i>serverName</i>, DPSTextProc <i>textProc</i>, DPSErrorProc <i>errorProc</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">DPSContext <b>DPSCreateContextWithTimeoutFromZone(</b>const char *<i>hostName</i>, const char *<i>serverName</i>, DPSTextProc <i>textProc</i>, DPSErrorProc <i>errorProc</i>, int <i>timeout</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times">DPSContext <b>DPSCreateNonsecureContext(</b>const char *<i>hostName</i>, const char *<i>serverName</i>, DPSTextProc <i>textProc</i>, DPSErrorProc <i>errorProc</i>, int <i>timeout</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times">DPSContext <b>DPSCreateStreamContext(</b>NXStream *<i>stream</i>, int <i>debugging</i>, DPSProgramEncoding <i>progEnc</i>, DPSNameEncoding <i>nameEnc</i>, DPSErrorProc <i>errorProc</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSCreateContext()</b> establishes a connection with the Window Server and creates a PostScript execution context in it.&nbsp; The new context becomes the current context.&nbsp; The first argument, <i>hostName</i>, identifies the machine that's running the Window Server; the second argument, <i>serverName</i>, identifies the Window Server that's running on that machine.&nbsp; With these two arguments and the help of the Mach network server <b>nmserver</b>, the Mach port for the Window Server can be identified.&nbsp; If <i>hostName</i> is NULL, the network server on the local machine is queried for the Window Server's port.&nbsp; If <i>serverName</i> is NULL, a default name for the Window Server is used.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The last two arguments, <i>textProc</i> and <i>errorProc</i>, refer to call-back functions (defined in the Client Library specification) that handle text returned from the Window Server and errors generated on either side of the connection.</font>

<p><font face="Times">For an application that's based on the Application Kit, you could create an additional context by making this call:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">DPSContext&nbsp; c;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">c = DPSCreateContext(NXGetDefaultValue([NXApp appName], &#34;NXHost&#34;),</font><br>
<img src="../../../Images/sp.gif" width=257 height=1><font face="Courier" size="-1">NXGetDefaultValue([NXApp appName], &#34;NXPSName&#34;),</font><br>
<img src="../../../Images/sp.gif" width=257 height=1><font face="Courier" size="-1">NULL,</font><br>
<img src="../../../Images/sp.gif" width=257 height=1><font face="Courier" size="-1">NULL);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This example queries the application's default values for the indentity of the host machine and the Window Server.&nbsp; By doing this, the new context is created in the correct Window Server even if that Server is not on the same machine as the application process.</font>

<p><font face="Times">The context that <b>DPSCreateContext()</b> creates allocates memory from the default allocation zone.&nbsp; Also, when there's difficulty creating the context, <b>DPSCreateContext()</b> waits up to 60 seconds before raising an exception.&nbsp; If you want to change either of these parameters, use <b>DPSCreateContextWithTimeoutFromZone()</b>.&nbsp; Its two additional arguments let you specify the zone for the context to use when allocating context-specific data and a timeout value in milliseconds.</font>

<p><font face="Times"><b>DPSCreateNonsecureContext()</b> creates a &quot;nonsecure&quot; context in which you can use PostScript operators that are normally disallowed.&nbsp; The most significant of these are operators that let you write files.</font>

<p><font face="Times"><b>DPSCreateStreamContext()</b> is similar to <b>DPSCreateContext()</b>, except that the new context is actually a connection from the client application to a stream.&nbsp; This connection becomes the current context.&nbsp; PostScript code that the application generates is sent to the stream rather than to the Window Server.&nbsp; The first argument, <i>stream</i>, is a pointer to an NXStream structure, as created by <b>NXOpenFile()</b> or <b>NXMapFile()</b>.&nbsp; The <i>debugging</i> argument is intended for debugging purposes but is not currently implemented.&nbsp; <i>progEnc</i> and <i>nameEnc</i> specify the type of program and user-name encodings to be used for output to the stream. The last argument, <i>errorProc</i>, identifies the procedure that's called when errors are generated.</font>

<p><font face="Times">Few programmers will need to call either of these functions directly:&nbsp; The Application Kit manages contexts for programs based on the Kit.&nbsp; For example, when an application is launched, its Application object calls <b>DPSCreateContext()</b> to create a context in the Window Server.&nbsp; Similarly, to print a View the Kit calls <b>DPSCreateStreamContext()</b> to temporarily redirect PostScript code from the View to a stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Each of these functions returns the newly created DPSContext structure.</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times"><b>DPSCreateContext()</b> and <b>DPSCreateContextWithTimeoutFromZone()</b> raise a dps_err_outOfMemory exception if they encounter difficulty allocating ports or other resources for the new context.&nbsp; They raise a dps_err_cantConnect exception if they can't return a context within the timeout period.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>DPSCreateContextWithTimeoutFromZone()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSCreateContext()</b></font>

<p><font face="Helvetica"><b>DPSCreateNonsecureContext()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSCreateContext()</b></font>

<p><font face="Helvetica"><b>DPSCreateStreamContext()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSCreateContext()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSDefineUserObject(), DPSUndefineUserObject()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a user object</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>DPSDefineUserObject(</b>int <i>index</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSUndefineUserObject(</b>int <i>index</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSDefineUserObject()</b> associates <i>index</i> with the PostScript object that's on the top of the operand stack, thereby creating a user object (as defined by the PostScript language).&nbsp; If <i>index</i> is 0, the object is assigned the next available index number.&nbsp; The function returns the new index, which can then be passed to a <b>pswrap</b>-generated function that takes a user object.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">To avoid coming into conflict with user objects defined by the Client Library or Application Kit, use <b>DPSDefineUserObject()</b> rather than the PostScript operator <b>defineuserobject</b> or the single-operator functions <b>DPSdefineuserobject()</b> and <b>PSdefineuserobject()</b>.</font>

<p><font face="Times"><b>DPSUndefineUserObject()</b> removes the association between <i>index</i> and the PostScript object it refers to, thus destroying the user object.&nbsp; By destroying a user object that's no longer needed, you can let the garbage collector reclaim the previously associated PostScript object.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSDefineUserObject()</b>, if successful in assigning an index, returns the index that the object was assigned.&nbsp; If unsuccessful, it returns 0.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>DPSDiscardEvents()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSGetEvent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSDoUserPath(), DPSDoUserPathWithMatrix()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Send an encoded PostScript path to the Window Server</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSDoUserPath(</b>void *<i>coords</i>, int <i>numCoords</i>, DPSNumberFormat <i>numType</i>, unsigned char *<i>ops</i>, int <i>numOps</i>, void *<i>bbox</i>, int <i>action</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSDoUserPathWithMatrix(</b>void *<i>coords</i>, int <i>numCoords</i>, DPSNumberFormat <i>numType</i>, unsigned char *<i>ops</i>, int <i>numOps</i>, void *<i>bbox</i>, int <i>action</i>, float <i>matrix</i>[6]<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSDoUserPath()</b> and <b>DPSDoUserPathWithMatrix()</b> send an encoded user path to the Window Server and then execute, upon that path, the operator specified by <i>action</i>.&nbsp; The use of these functions, rather than the analogous step-by-step path construction, is encouraged; rendering an encoded path is much more efficient than executing the individual PostScript operators that would otherwise be needed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An encoded user path consists of an array of coordinate values, a sequence of PostScript operators, and a bounding box specification.&nbsp; The values in the coordinate array are used as operands to the operators; the operands are distributed to the operators in the order that they're given.&nbsp; The resulting path must fit within the bounding box.</font>

<p><font face="Times">The coordinates, operators, and bounding box are given by the functions' first five arguments:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The array of coordinate values is given by <i>coords</i>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>numCoords</i> is the number of elements in <i>coords</i>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><img src="../../../Images/sp.gif" width=3 height=1><font face="Times"><i>numType</i> specifies the data type of the coordinates, as described below.&nbsp; All the values in <i>coords</i> must be of the same type.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>ops</i> is the sequence of PostScript operators, represented by constants as listed below.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The&nbsp; bounding box is defined by the four coordinate values that you pass as an array in the <i>bbox</i> argument.&nbsp; These are passed as operands to the <b>setbbox</b> operator.&nbsp; (If you don't supply a <b>setbbox</b> as part of the <i>ops</i> sequence, one is inserted for you.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The following integer constants represent the data types that you can pass as the <i>numType</i> argument:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica"><b>Constant</b></font></td>

<td><font face="Helvetica"><b>Meaning</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">dps_float</font></td>

<td><font face="Times">single-precision floating-point number</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">dps_long</font></td>

<td><font face="Times">32-bit integer</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">dps_short</font></td>

<td><font face="Times">8-bit integer</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You can also specify 16- and 32-bit fixed-point real numbers.&nbsp; For 16-bit fixed-point numbers, use <b>dps_short</b> plus the number of bits in the fractional portion.&nbsp; For 32-bit fixed-point numbers, use <b>dps_long</b> plus the number of bits in the fractional portion.</font>

<p><font face="Times">These constants are provided for <i>ops</i>:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">dps_setbbox</font><br>
<font face="Times">dps_moveto</font><br>
<font face="Times">dps_rmoveto</font><br>
<font face="Times">dps_lineto</font><br>
<font face="Times">dps_rlineto</font><br>
<font face="Times">dps_curveto</font><br>
<font face="Times">dps_rcurveto</font><br>
<font face="Times">dps_arc</font><br>
<font face="Times">dps_arcn</font><br>
<font face="Times">dps_arct</font><br>
<font face="Times">dps_closepath</font><br>
<font face="Times">dps_ucache</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Once the user path has been constructed, the operator specified by <i>action</i> is executed.&nbsp; The value of <i>action</i> is an index into Display PostScript's encoded system names; the following constants, provided as a convenience, represent the most commonly used actions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">dps_uappend</font><br>
<font face="Times">dps_ufill</font><br>
<font face="Times">dps_ueofill</font><br>
<font face="Times">dps_ustroke</font><br>
<font face="Times">dps_ustrokepath</font><br>
<font face="Times">dps_inufill</font><br>
<font face="Times">dps_inueofill</font><br>
<font face="Times">dps_inustroke</font><br>
<font face="Times">dps_def</font><br>
<font face="Times">dps_put</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>DPSDoUserPathWithMatrix()</b>'s <i>matrix</i> argument represents the transformation matrix operand used by the <b>ustroke</b>, <b>inustroke</b>, and <b>ustrokepath</b> operators.&nbsp; If <i>matrix</i> is NULL, the argument is ignored.</font>

<p><font face="Times">The following program fragment demonstrates the use of <b>DPSDoUserPath()</b> as it creates and strokes a user path (an isosceles triangle) within a bounding rectangle whose lower left corner is located at (0, 0) and whose width and height are 200.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">short&nbsp;&nbsp; coords[6] = {0, 0, 200, 0, 100, 200};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp; ops[4] = {dps_moveto, dps_lineto,dps_lineto,</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">dps_closepath};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">short&nbsp;&nbsp; bbox[4] = {0, 0, 200, 200};</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">DPSDoUserPath(coords, 6, dps_short, ops, 4, bbox, dps_ustroke);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">If an application calls <b>DPSDoUserPath()</b> with large values (~10,000-20,000) of <i>numCoords</i> and/or <i>numOps</i>, it may generate a Display PostScript error.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>DPSDoUserPathWithMatrix()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSDoUserPath()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSFlush(), DPSSendEOF()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Send PostScript data to the Window Server</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSFlush()</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSSendEOF(</b>DPSContext <i>context</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSFlush()</b> flushes the application's output buffer, forcing any buffered PostScript code or data to the Window Server.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>DPSSendEOF()</b> sends a PostScript end-of-file marker to the given context.&nbsp; The connection to the context isn't closed or disturbed in any way by this function.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>DPSGetEvent(), DPSPeekEvent(), DPSDiscardEvents()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Access events from the Window Server</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>DPSGetEvent(</b>DPSContext <i>context</i>, NXEvent *<i>anEvent</i>, int <i>mask</i>, double <i>timeout</i>, int <i>threshold</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>DPSPeekEvent(</b>DPSContext <i>context</i>, NXEvent *<i>anEvent</i>, int <i>mask</i>, double <i>timeout</i>, int <i>threshold</i><b>)</b></font><br>
<font face="Times">void <b>DPSDiscardEvents(</b>DPSContext <i>context</i>, int <i>mask</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSGetEvent()</b> and <b>DPSPeekEvent()</b> are macros that access event records in an application's event queue.&nbsp; These routines are provided primarily for programs that don't use the Application Kit.&nbsp; An application based on the Kit should use the corresponding Application class methods (such as <b>getNextEvent:</b> and <b>peekNextEvent:into:</b>) or the function <b>NXGetOrPeekEvent()</b> so that it can be journaled.&nbsp; <b>DPSDiscardEvents()</b> removes all event records of a specified type from the queue.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>DPSGetEvent()</b> and <b>DPSPeekEvent()</b> differ only in how they treat the accessed event record.&nbsp; <b>DPSGetEvent()</b> removes the record from the queue after making its data available to the application; <b>DPSPeekEvent()</b> leaves the record in the queue.</font>

<p><font face="Times"><b>DPSGetEvent()</b> and <b>DPSPeekEvent()</b> take the same parameters.&nbsp; The first, <i>context</i>, represents a PostScript execution context within the Window Server.&nbsp; Virtually all applications have only one execution context, which can be returned using <b>DPSGetCurrentContext()</b>.&nbsp; Applications having more than one execution context can use the constant DPS_ALLCONTEXTS to access events from all contexts belonging to them.</font>

<p><font face="Times">The second argument, <i>anEvent</i>, is a pointer to an event record.&nbsp; If <b>DPSGetEvent()</b> or <b>DPSPeekEvent()</b> is successful in accessing an event record, the record's data is copied into the storage referred to by <i>anEvent</i>.</font>

<p><font face="Times"><i>mask</i> determines the types of events sought.&nbsp; See the section &quot;Types and Constants&quot; for a list of the constants that represent the event type masks.&nbsp; To check for more than one type of event, you combine individual constants using the bitwise OR operator.</font>

<p><font face="Times">If an event matching the event mask isn't available in the queue, <b>DPSGetEvent()</b> or <b>DPSPeekEvent()</b> waits until one arrives or until <i>timeout</i> seconds have elapsed, whichever occurs first.&nbsp; The value of <i>timeout</i> can be in the range of 0.0 to NX_FOREVER.&nbsp; If <i>timeout</i> is 0.0, the routine returns an event only if one is waiting in the queue when the routine asks for it.&nbsp; If <i>timeout</i> is NX_ FOREVER, the routine waits until an appropriate event arrives before returning.</font>

<p><font face="Times">The last argument, <i>threshold</i>, is an integer in the range 0 through 31 that determines which other services may be provided during a call to <b>DPSGetEvent()</b> or <b>DPSPeekEvent()</b>.</font>

<p><font face="Times">Requests for services are registered by the functions <b>DPSAddTimedEntry()</b>, <b>DPSAddPort()</b>, and <b>DPSAddFD()</b>.&nbsp; Each of these functions takes an argument specifying a priority level.&nbsp; If this level is equal to or greater than <i>threshold</i>, the service is provided before <b>DPSGetEvent()</b> or <b>DPSPeekEvent()</b> returns.</font>

<p><font face="Times"><b>DPSDiscardEvents()</b>'s two parameters, <i>context</i> and <i>mask</i>, are the same as those for <b>DPSGetEvent()</b> and <b>DPSPeekEvent()</b>. <b>DPSDiscardEvents()</b> removes from the application's event queue those records whose event types match <i>mask</i> and whose context matches <i>context</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSGetEvent()</b> and <b>DPSPeekEvent()</b> return 1 if they are successful in accessing an event record and 0 if they aren't.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSAddFD()</b>, <b>DPSAddPort()</b>, <b>DPSAddTimedEntry()</b>, <b>DPSPostEvent()</b>, <b>NXGetOrPeekEvent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSInterruptContext()</b></font>

<p><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">This function is unimplemented in the NEXTSTEP version of the Client Library.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>DPSNameFromTypeAndIndex()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Access the system and user name tables</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">const char *<b>DPSNameFromTypeAndIndex(</b>short <i>type</i>, int <i>index</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSNameFromTypeAndIndex()</b> returns the text associated with <i>index</i> from the system or user name table.&nbsp; If <i>type</i> is</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1, the text is returned from the system name table; if <i>type</i> is 0, it's returned from the user name table.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The name tables are used primarily by the Client Library and <b>pswrap</b>; few programmers will access them directly.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">This function returns a read-only character string.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>DPSPeekEvent()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSGetEvent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSPostEvent()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create an event</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>DPSPostEvent(</b>NXEvent *<i>anEvent</i>, int <i>atStart</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSPostEvent()</b> lets you add an event record to your application's event queue without involving the Window Server.&nbsp; <i>anEvent </i>is a pointer to the event record to be added.&nbsp; <i>atStart</i> specifies where the new record will be placed in relation to any other records in the queue.&nbsp; If <i>atStart</i> is TRUE, the event is posted in front of all others and so will be the next one your application receives.&nbsp; If <i>atStart</i> is FALSE, the event is posted behind all others and so won't be returned until events that precede it are processed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You can free, reuse, or otherwise mangle <i>anEvent</i> after you've posted it without fear of corrupting the posted record. <b>DPSEvent()</b> copies the record it receives and posts the copy.</font>

<p><font face="Times">Note that event records you post using <b>DPSPostEvent()</b> aren't filtered by an event filter function set with <b>DPSSetEventFunc()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSPostEvent()</b> returns 0 if successful in posting the event record; it returns</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1 if unsuccessful in posting the record because the event queue is full.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSSetEventFunc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSPrintError(), DPSPrintErrorToStream()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Print error messages</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSPrintError(</b>FILE *<i>fp</i>, const DPSBinObjSeq <i>error</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSPrintErrorToStream(</b>NXStream *<i>stream</i>, const DPSBinObjSeq <i>error</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSPrintError()</b> and <b>DPSPrintErrorToStream()</b> format and print error messages received from a PostScript execution context in the Window Server.&nbsp; The error message is extracted from the binary object sequence <i>error</i>.&nbsp; <b>DPSPrintError()</b> prints the error message to the file identified by <i>fp</i>; <b>DPSPrintErrorToStream()</b> prints the error message to <i>stream</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You rarely need to call these functions directly.&nbsp; However, if you reset the error handler for a PostScript execution context, the new handler you install could use one of these functions to process errors that it receives.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>DPSPrintErrorToStream()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSPrintError()</b></font>

<p><font face="Helvetica"><b>DPSRemoveFD()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSAddFD()</b></font>

<p><font face="Helvetica"><b>DPSRemovePort()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSAddPort()</b></font>

<p><font face="Helvetica"><b>DPSRemoveTimedEntry()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See DPSAddTimedEntry()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSResetContext()</b></font>

<p><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">This function is unimplemented in the NEXTSTEP version of the Client Library.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>DPSSetDeadKeysEnabled()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Allow dead key processing for a context's events</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSSetDeadKeysEnabled(</b>DPSContext <i>context</i>, int <i>flag</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSSetDeadKeysEnabled()</b> turns dead key processing on or off for <i>context</i>.&nbsp; If flag is 0, dead key processing is turned off; otherwise, it's turned on (the default).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Dead key processing is a technique for extending the range of characters that can be entered from the keyboard.&nbsp; In NEXTSTEP, it provides one way for users to enter accented characters.&nbsp; For example, a user can type Alternate-e followed by the letter &quot;e&quot;&quot; to produce the letter &quot;&eacute;&quot;&quot;.&nbsp; The first keyboard input, Alternate-e, seems to have no effect--it's the &quot;dead key&quot;&quot;. However, it signals Client Library routines that it and the following character should be analyzed as a pair.&nbsp; If, within NEXTSTEP, the pair of characters has been associated with a third character, a keyboard event record representing the third character is placed in the application's event queue, and the first two event records are discarded.&nbsp; If there is no such association between the two characters, the two event records are added to the event queue.</font>

<p><font face="Times">See the <i>NeXT User's Reference</i> manual for a listing of the keys that produce accent characters.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>DPSSetEventFunc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the function that filters events</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">DPSEventFilterFunc <b>DPSSetEventFunc(</b>DPSContext <i>context</i>, DPSEventFilterFunc <i>func</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSSetEventFunc()</b> establishes the function <i>func</i> as the function to be called when an event record is returned from the PostScript context <i>context</i> in the Window Server.&nbsp; The registered function is called before the event record is put in the event queue.&nbsp; If the registered function returns 0, the record is discarded.&nbsp; If the registered function returns 1, the record is passed on for further processing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Only event records coming from the Window Server are filtered by the registered function.&nbsp; Records that you post to the event queue using <b>DPSPostEvent()</b> aren't affected.</font>

<p><font face="Times">A DPSEventFilterFunc function takes the following form:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">int *<i>func</i>(NXEvent *<i>anEvent</i>)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSSetEventFunc()</b> returns a pointer to the previously registered event function.&nbsp; This lets you chain together the current and previous event functions.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSPostEvent()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSSetTracking()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Coalesce mouse events</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>DPSSetTracking(</b>int <i>flag</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSSetTracking()</b> turns mouse event-coalescing on or off for the current context.&nbsp; If <i>flag</i> is 0, coalescing is turned off; otherwise, it's turned on (the default).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Event coalescing is an optimization that's useful when tracking the mouse.&nbsp; When the mouse is moved, numerous events flow into the event queue.&nbsp; To reduce the number of events awaiting removal by the application, adjacent mouse-moved events are replaced by the most recent event of the contiguous group.&nbsp; The same is done for left and right mouse-dragged events, with the addition that a mouse-up event replaces mouse-dragged events that come before it in the queue.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSSetTracking()</b> returns the previous state of the event-coalescing switch.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSStartWaitCursorTimer()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Initiate a count down for the wait cursor</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">void <b>DPSStartWaitCursorTimer()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSStartWaitCursorTimer()</b> triggers the mechanism that displays a wait cursor when an application is busy and can't respond to user input.&nbsp; In most cases, wait cursor support is automatic:&nbsp; You'll only need to call this function if your application starts a time-consuming operation that's not initiated by a user-generated event.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Client Library routines and the Window Server cooperate to display the wait cursor whenever more than a preset amount of time elapses between the time an application takes an event record from the event queue and the time the application is again ready to consume events.&nbsp; However, when an application starts an operation that isn't initiated by an event--such as one caused by receiving a Mach message or by processing data from a file (see <b>DPSAddPort()</b> and <b>DPSAddFD()</b>)--the wait cursor mechanism is bypassed.&nbsp; To ensure proper wait cursor behavior in these cases, call <b>DPSStartWaitCursorTimer()</b> before beginning the time-consuming operation.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>DPSAddFD()</b>, <b>DPSAddPort()</b>, <b>setwaitcursorenabled</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSSynchronizeContext()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Synchronize a context with your application</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>DPSSynchronizeContext(</b>DPSContext <i>context</i>, int <i>flag</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSSynchronizeContext()</b> causes <b>DPSWaitContext()</b> to be called after each <b>pswrap</b> function is called, thus synchronizing the PostScript context with your application.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>DPSTraceContext(), DPSTraceEvents()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Trace data and events</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/dpsNeXT.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>DPSTraceContext(</b>DPSContext <i>context</i>, int <i>flag</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>DPSTraceEvents(</b>DPSContext <i>context</i>, int <i>flag</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>DPSTraceContext()</b> and <b>DPSTraceEvents()</b> control the tracing of data and events between a PostScript execution context (or contexts) in the Window Server and an application process.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first argument for both functions, <i>context</i>, specifies the context to be traced.&nbsp; An application's single context can be returned with <b>DPSGetCurrentContext()</b>.&nbsp; Applications having more than one execution context can use the constant DPS_ALLCONTEXTS to trace all contexts belonging to them.</font>

<p><font face="Times">The second argument, <i>flag</i>, determines whether tracing is enabled.</font>

<p><font face="Times">When data tracing is enabled (<b>DPSTraceContext()</b>), a copy of the PostScript code generated by an application and the values returned to it by the Window Server is sent to UNIX standard error.&nbsp; Values returned to the application are marked by the prepended string:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">% value returned ==&gt;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">When event tracing is enabled (<b>DPSTraceEvents()</b>), information about each event that the application receives is sent to UNIX standard error.&nbsp; For example, for a left mouse-down event the listing might look like this:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">Receiving: LMouseDown at: 343.0,69.0 time: 1271899</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">flags: 0x0 win: 6 ctxt: 76128 data: 1111,1</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The listing displays the fields of the event record:&nbsp; type, location, time, flags, local window number, PostScript execution context, and data.&nbsp; The contents of the data field listing depends on the event type; for instance, in the preceding example the event number and the click count were displayed.</font>

<p><font face="Times">For applications based on the Application Kit, there are two preferable methods for turning on data tracing:&nbsp; You can use the NXShowPS command-line switch when you launch an application from Terminal.&nbsp; Alternatively, when you run the application under GDB, you can use the <b>showps</b> and <b>shownops</b> commands to control tracing output.&nbsp; Similarly, there are more convenient ways to turn on event tracing:&nbsp; You can use the <b>NXTraceEvents</b> command-line switch when you launch an application from Terminal.&nbsp; Alternatively, when you run the application under GDB, you can use the <b>traceevents</b> and <b>tracenoevents</b> commands to control event-tracing output.</font>

<p><font face="Times">Only one tracing context can be created for the supplied <i>context</i>.&nbsp; If you attempt to create additional tracing contexts for a context that's already being traced, no new context is created and <b>DPSTraceContext()</b> returns</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times"><b>DPSTraceContext()</b> returns 0 if successful in creating a tracing context, or</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1 if not.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>NX_EVENTCODEMASK()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Generate an event mask for an event type</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">dpsclient/event.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">int <b>NX_EVENTCODEMASK(</b>int <i>type</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This handy utility macro returns an event mask that corresponds to the given (single) event type.</font></td></tr>

</table>



<p>

</body>
</html>
