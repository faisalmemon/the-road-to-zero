<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/GeneralRef/16_Sound/DriverFunctions/DriverFunctions.rtf -->
<!-- Date: Sun Jun 28 20:07:09 1998 -->
<head>
<title>DriverFunctions</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dsp_boot(), snddriver_dsp_reset()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Start the DSP</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dsp_boot(</b>port_t <i>commandPort</i>, int *<i>bootImage</i>, int <i>imageSize</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_dsp_reset(</b>port_t <i>commandPort</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_dsp_boot()</b> enqueues a command to boot the DSP.&nbsp; The arguments are as follows:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>commandPort</i> is the DSP command port, as retrieved by <b>snddriver_get_dsp_cmd_port()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>bootImage</i> is a pointer to a DSP program image that's downloaded to the DSP (program memory location 0x0) and immediately executed.&nbsp; The image is created by reading a &quot;.lod&quot; file that's assembled from DSP56001 assembly code.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>imageSize</i> is the size of the DSP boot image, in bytes.&nbsp; The image must not exceed 512 words (24-bit DSP words right-justified within 32-bit integers).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>priority</i> is one of the three priority constants SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_HIGH_PRIORITY.&nbsp; The sound driver sorts the commands in its DSP command queue according to priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Booting the DSP clears neither external memory nor on-chip data memory.</font>

<p><font face="Times"><b>snddriver_dsp_reset()</b> puts the DSP in its reset state.&nbsp; By this it's meant that the DSP's execution is immediately halted and a bootstrap program is awaited.&nbsp; Booting the DSP automatically resets it, thus you don't need to call this function before calling <b>snddriver_boot_dsp()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_dsp_dma_read()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_dsp_dma_write()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dsp_dma_write(), snddriver_dsp_dma_read()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Transfer data to and from the DSP via DMA</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dsp_dma_write(</b>port_t <i>commandPort</i>, int <i>elementCount</i>, int <i>dataFormat</i>, pointer_t <i>data</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_dsp_dma_read(</b>port_t <i>commandPort</i>, int <i>elementCount</i>, int <i>dataFormat</i>, pointer_t <i>data</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions enqueue commands that perform application-initiated DMA transfers to and from the DSP.&nbsp; You must include complex DMA protocol to use these functions.&nbsp; The arguments to the two functions are similar:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>commandPort</i> is the DSP command port, as retrieved by <b>snddriver_get_dsp_cmd_port()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>elementCount</i> is the number of data elements to send during each transfer.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>dataFormat</i> is an integer constant that describes the size and packing of an individual data element.&nbsp; These are</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">DSP_MODE8</font></td>

<td><font face="Times">1 byte per element</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">DSP_MODE16</font></td>

<td><font face="Times">2 bytes per element</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">DSP_MODE24</font></td>

<td><font face="Times">3 bytes per element</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">DSP_MODE32</font></td>

<td><font face="Times">3 bytes per element, right-justified in 4</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">DSP_MODE2416</font></td>

<td><font face="Times">2 bytes per element, packed and right-justified in 4</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>data</i> is a pointer to the data that you're transferring.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">There are three rules regarding the size and alignment of a DMA transfer buffer:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The size in bytes of a single DMA transfer buffer, reckoned as <i>elementCount</i> * bytes-per-element, must be a multiple of 16. Note that bytes-per-element isn't given directly as an argument.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The data must be &quot;quad-aligned&quot;; in other words, the starting address (<i>data</i>) must be a multiple of 16.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">All the data in a transfer buffer must lie on the same page of virtual memory.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If you're writing data, the <b>snddriver_dsp_dma_write()</b> function enqueues a command to send the data to the DSP and then immediately returns.&nbsp; <b>snddriver_dsp_dma_read()</b>, on the other hand, waits until it has read the prescribed amount of data and returns with <i>data</i> filled.&nbsp; DMA-transfer commands are always enqueued with high priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_dsp_read()</b>, <b>snddriver_dsp_write()</b>, <b>snddriver_dsp_protocol()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dsp_host_cmd()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Enqueue a DSP command</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dsp_host_cmd(</b>port_t <i>commandPort</i>, u_int <i>hostCommand</i>, u_int <i>priority</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_dsp_host_cmd()</b> enqueues a command on the sound driver's DSP command queue that interrupts the DSP and causes it to execute one of 32 interrupt routines (or <i>host commands</i>).&nbsp; Its arguments are as follows:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>commandPort</i> is the DSP command port, as retrieved by <b>snddriver_get_dsp_cmd_port()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>hostCommand</i> is an integer that represents the host command you want to execute.&nbsp; The first 22 host commands are already defined (or reserved).&nbsp; The host commands provided by NeXT are represented by constants (prefix &quot;DSP_hc_&quot;) that are defined in <b>/usr/include/nextdev/snd_dsp.h</b>.&nbsp; Creating your own host command requires a familiarity with DSP programming that lies beyond the scope of this description.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>priority</i> is one of the three priority constants SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_HIGH_PRIORITY.&nbsp; The sound driver sorts the commands in its DSP command queue according to priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">When the DSP receives a host command, it sets the HC flag in the Command Vector Register.&nbsp; After executing the command, the DSP clears the flag.&nbsp; You should always precede a call to <b>snddriver_dsp_host_cmd()</b> with a call to <b>snddriver_dspcmd_req_condition()</b> that waits for HC to clear in order to avoid overwriting a previously requested, but as yet unexecuted, host command:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* CVR_HC is defined in &lt;nextdev/snd_dspreg.h&gt; */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">err = snddriver_dspcmd_req_condition(commandPort, CVR_HC, 0, ...);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Now enqueue the host command request. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">err = snddriver_dsp_host_cmd(...);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_dspcmd_req_condition()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dsp_protocol()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the sound driver's protocol vis-a-vis the DSP</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dsp_protocol(</b>port_t <i>devicePort</i>, port_t <i>ownerPort</i>, int <i>protocol</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_dsp_protocol()</b> lets you establish the manner in which the sound driver communicates with the DSP; specifically, it determines whether to create 0, 1, or 2 DSP-reply buffers and whether DSP interrupts are enabled.&nbsp; The existence of the DSP-reply buffers determines whether you can use streams to transfer data.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function's first two arguments are the sound driver device port and the DSP owner port, as acquired through <b>SNDAcquire()</b>.</font>

<p><font face="Times"><i>protocol</i> is the heart of the matter:&nbsp; It's a code that represents the protocol that you wish to establish.&nbsp; There are two ways to create the appropriate protocol:&nbsp; If you're using streams to access the DSP, then you should pass the protocol variable that's modified by calls to <b>snddriver_stream_setup()</b>, as explained (with an example) in the description of that function. Alternatively--or in addition to the foregoing--you can create a protocol code by or'ing the following DSP protocol constants:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DSP_PROTO_RAW represents the barest protocol.&nbsp; The sound driver makes no assumptions about how the DSP is being used:&nbsp; No DSP-reply buffers are created and the DSP can't interrupt the host.&nbsp; You can't use streams in raw protocol; to transfer data, you use the <b>snddriver_dsp_write()</b> and <b>snddriver_dsp_read()</b> functions.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">All the other protocols create at least one DSP-reply buffer and allow DSP interrupts, thus allowing you to transfer data through a stream:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DSP_PROTO_DSPMSG (&quot;DSP-message&quot;) creates a buffer that can hold 512 DSP-reply messages.&nbsp; A message from the DSP (as it lies in the reply buffer) is a 24-bit word right-justified in 32 bits.&nbsp; To receive the contents of this buffer, you enqueue a request through <b>snddriver_dspcmd_req_msg()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DSP_PROTO_DSPERR (&quot;DSP-error&quot;) creates an additional 512-message DSP-reply buffer that collects error messages sent from the DSP.&nbsp; An error message is identified as having its MSB (bit 23) set.&nbsp; You can request the contents of the error buffer through <b>snddriver_dspcmd_req_err()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DSP_PROTO_C_DMA (&quot;complex DMA&quot;) implies DSP message mode (a single DSP-reply buffer is created) and allows DSP-initiated DMA transfers.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DSP_PROTO_HFABORT (&quot;host flag abort&quot;) causes the driver to take note if the DSP aborts.&nbsp; (The DSP indicates that it has aborted by setting HF2 and HF3.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">To get the documented behavior from these protocols, you <i>must</i> include SNDDRIVER_DSP_PROTO_RAW.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">A protocol of 0 produces Release 1.0 behavior; this is roughly equivalent to a combination of DSP message, DSP error, and host flag abort modes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_stream_setup()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_dsp_read()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_dsp_write()</b></font>

<p><font face="Helvetica"><b>snddriver_dsp_read_data()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_dsp_write()</b></font>

<p><font face="Helvetica"><b>snddriver_dsp_read_messages()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_dsp_write()</b></font>

<p><font face="Helvetica"><b>snddriver_dsp_reset()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_dsp_boot()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dsp_set_flags()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the DSP host flags</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dsp_set_flags(</b>port_t <i>commandPort</i>, u_int <i>flagMask</i>, u_int <i>flagValue</i>, u_int <i>priority</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_dsp_set_flags()</b> enqueues a command to modify one or both of the DSP host interface flags HF0 (host flag 0) and HF1 (host flag 1).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <i>flagMask</i> argument defines which of the host flags you want to affect.&nbsp; The flags are represented by the constants SNDDRIVER_ICR_HF0 and SNDDRIVER_ICR_HF1.&nbsp; You can set both flags at the same time by or'ing these two constants. (ICR stands for &quot;Interrupt Control Register&quot;; this is the register to which the host flags belong.)</font>

<p><font face="Times"><i>flagValue</i> is the value to which you're setting the flag(s).&nbsp; A host flag can be either on or off, states that are also referred to as &quot;set&quot; and &quot;cleared&quot;.&nbsp; To set a flag, you pass its constant identifier; to clear it, you pass 0.&nbsp; The following examples illustrate this concept:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Set HF0 (turn it on). */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_dsp_set_flags(..., SNDDRIVER_ICR_HF0,</font><br>
<img src="../../../Images/sp.gif" width=201 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0,...)</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Clear HF1. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_dsp_set_flags(..., SNDDRIVER_ICR_HF1,0,...)</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Set both flags. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_dsp_set_flags(...,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1,</font><br>
<img src="../../../Images/sp.gif" width=201 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1, ...)</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Set HF0 and clear HF1. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_dsp_set_flags(...,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1,</font><br>
<img src="../../../Images/sp.gif" width=201 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0, ...)</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Clear both flags. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_dsp_set_flags(...,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1, 0,...)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The other two arguments, <i>commandPort</i> and <i>priority</i>, are the DSP command port and command-queue priority, respectively. The DSP command port is retrieved through <b>snddriver_dsp_cmd_port()</b>; you set the priority to one of SNDDRIVER_HIGH_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_LOW_PRIORITY.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_dspcmd_req_condition()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dsp_write(), snddriver_dsp_read(), snddriver_dsp_read_data(), snddriver_dsp_read_messages()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Transfer data to and from the DSP</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dsp_write(</b>port_t <i>commandPort</i>, void *<i>buffer</i>, int <i>elementCount</i>, int <i>elementSize</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_dsp_read(</b>port_t <i>commandPort</i>, void *<i>buffer</i>, int <i>elementCount</i>, int <i>elementSize</i>, int <i>priority</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_dsp_read_messages(</b>port_t <i>commandPort</i>, void *<i>buffer</i>, int <i>elementCount</i>, int <i>elementSize</i>, int <i>priority</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_dsp_read_data(</b>port_t <i>commandPort</i>, void **<i>buffer</i>, int <i>elementCount</i>, int <i>elementSize</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_dsp_write()</b> enqueues a command to perform a one-shot, application-initiated data transfer to the DSP; <b>snddriver_dsp_read()</b> brings data back from the DSP in a like manner.&nbsp; You generally use these functions if you have a small amount of data to transfer or if the transfers are infrequent enough that the overhead of the obvious alternative--setting up a DMA stream--would be exorbitant.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The other two functions, <b>snddriver_dsp_read_messages()</b> and <b>snddriver_dsp_read_data()</b> are auxiliary to <b>snddriver_dsp_read()</b>.&nbsp; When you call <b>snddriver_dsp_read()</b>, it, in turn, calls one of the auxiliary functions; which of the two functions it calls depends on the current DSP protocol, as described below.&nbsp; You can call these functions yourself by-passing <b>snddriver_dsp_read()</b>, although you should adhere to the same protocol rules that <b>snddriver_dsp_read()</b> obeys.</font>

<p><font face="Times">The arguments to all four functions are similar:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>commandPort</i> is the DSP command port, as retrieved through <b>snddriver_get_dsp_cmd_port().</b></font></td></tr>

<tr valign=top>

<td width=105 height=13></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>buffer</i>, as used by <b>snddriver_dsp_write()</b>, is a pointer to the data you want to send to the DSP.&nbsp; For the <b>snddriver_dsp_read...()</b> functions, it's a pointer to the location where you want the retrieved data to be stored.&nbsp; Note that for <b>snddriver_dsp_read_data()</b>, <i>buffer</i> is the address of a pointer; this allows the function to allocate memory for the data if you haven't allocated it yourself.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>elementCount</i> and <i>elementSize</i> are the number of data elements to transfer and the size, in bytes, of a single element, respectively.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>priority</i> is an integer used to sort the command on the DSP command queue.&nbsp; The sound driver defines three priorities represented by the constants SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, and SNDDRIVER_HIGH_PRIORITY.&nbsp; You normally set all application-initiated data transfers to low priority, thus reserving medium and high priority for operations that need to jump to the head of the DSP command queue.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Of these functions, <b>snddriver_dsp_write()</b> is most straightforward:&nbsp; When it's called, a transfer-data-to-the-DSP command is sorted (by priority) into the DSP command queue.&nbsp; If, when its turn comes, the command can't be executed, the driver simply pushes it back on the queue and tries again.&nbsp; No other commands of equal or lower priority can be executed while a frustrated write command is sitting on top of the queue.&nbsp; Note, however, that higher priority commands <i>will</i> get through.</font>

<p><font face="Times">As mentioned earlier, <b>snddriver_dsp_read()</b> calls one of its two auxiliary functions as determined by the current DSP protocol:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If your application is in raw protocol, then <b>snddriver_dsp_read_data()</b> is used to read data from the DSP transmit registers.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If DSP message protocol is included, <b>snddriver_dsp_read_messages()</b> is used to read data from the DSP-reply buffer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The difference between the two mechanisms is generally transparent such that you can call <b>snddriver_read_data()</b> without regard for the current protocol.&nbsp; However, the manner in which the underlying functions handles incomplete reads is significant: If the read can't be completed (typically because the DSP hasn't generated enough data), <b>snddriver_dsp_read_data()</b> blocks the DSP command queue in the fashion of <b>snddriver_dsp_write()</b>.&nbsp; In the same situation, <b>snddriver_dsp_read_messages() </b>waits for more data without blocking the command queue.&nbsp; Thus <b>snddriver_dsp_read_messages()</b> can safely be called from a separate thread at any time.&nbsp; This isn't true of <b>snddriver_dsp_read_data()</b>; you should be scrupulous about ensuring that sufficient data has been processed by the DSP before you attempt to read it through this function (or through <b>snddriver_dsp_read()</b> while in raw protocol).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_dsp_dma_read()</b>, <b>snddriver_dsp_dma_write()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dspcmd_req_condition()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Request a DSP host interface register condition</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dspcmd_req_condition(</b>port_t <i>commandPort</i>, u_int <i>registerMask</i>, u_int <i>conditionFlags</i>, int <i>priority</i>, port<b>_</b>t <i>replyPort</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_dspcmd_req_condition()</b> does two things:&nbsp; It causes the DSP command queue to block until the specified host interface register condition is true, and it registers a request for an asynchronous message to be sent to <i>replyPort</i> when the condition is fulfilled.&nbsp; The function returns immediately.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You specify a condition through a combination of the <i>registerMask</i> and <i>conditionFlags</i> arguments:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>registerMask</i> specifies the host interface registers (actually, the bits therein) that you're interested in.&nbsp; It's created by <b>or</b><i>'</i>ing the register-bit constants defined in <b>nextdev/snd_dspregs.h</b>.&nbsp; A subset of these are also defined as sound driver constants in <b>sound/snddriver_client.h</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>conditionFlags</i> encodes the states of the register bits that define a satisfied condition.&nbsp; To specify that you want a register bit set, you <b>or</b> the register-bit constant that represents it; if you want it clear, you exclude the constant.&nbsp; If you want all the specified bits to be clear, set <i>conditionFlags</i> to 0.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">In the following example, the command queue is blocked until HF0 is set and HF1 is clear (both flags are in the Interrupt Control Register):</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Block until HF0 is set and HF1 is clear. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_dspcmd_req_condition(...,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">SNDDRIVER_ICR_HF2, ...)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The condition request is sorted into the DSP command queue according to <i>priority</i>, which must be one of SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_HIGH_PRIORITY.</font>

<p><font face="Times">The message that's sent to the reply port when the condition is fulfilled contains the value of the host interface register.&nbsp; By setting the <i>registerMask</i> argument to 0, you can use the <b>snddriver_dspcmd_req_condition()</b> function to simply poll for this value.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_dsp_set_flags()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_dspcmd_req_err()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_dspcmd_req_msg()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_dspcmd_req_msg(), snddriver_dspcmd_req_err()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Request the contents of the DSP-reply buffers</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_dspcmd_req_msg(</b>port_t <i>commandPort</i>, port_t <i>replyPort</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_dspcmd_req_err(</b>port_t <i>commandPort</i>, port_t <i>replyPort</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The <b>snddriver_dspcmd_req_msg()</b> and <b>snddriver_dspcmd_req_err()</b> functions are part of the mechanism by which your application retrieves messages from the sound driver's DSP-reply buffers.&nbsp; They request that the contents of the appropriate buffer (as described below) be sent in a Mach message to <i>replyPort</i>, a valid port that must already be allocated.&nbsp; Simply requesting a message is only half of the story:&nbsp; You then have to receive the message that's been sent, usually by sitting in a <b>msg_receive()</b> loop.&nbsp; You typically process the Mach messages that these functions induce by passing the messages to the <b>snddriver_reply_handler()</b> function.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The utility of these functions depends on your application's DSP protocol:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">You should never use these functions in raw protocol since the sound driver doesn't create any DSP-reply buffers.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">By including DSP message protocol, a single DSP-reply buffer is created in which both error and non-error messages are stored; thus <b>...req_msg()</b> is of use, but <b>...req_err()</b> isn't.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">DSP error protocol deems that two buffers be created, one for error messages and the other for non-error messages.&nbsp; Both functions are useful in this protocol.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">DSP protocol and how to set it is explained in the description of the <b>snddriver_set_dsp_protocol()</b> function.&nbsp; For both functions, the <i>commandPort</i> argument is the DSP command port as retrieved by <b>snddriver_get_dsp_cmd_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_set_dsp_protocol()</b>, <b>snddriver_reply_handler()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_get_device_parms()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_device_parms()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_get_dsp_cmd_port()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the DSP command port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_get_dsp_cmd_port(</b>port_t <i>devicePort</i>, port_t <i>ownerPort</i>, port_t *<i>commandPort</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_get_dsp_cmd_port()</b> attempts to get the <i>DSP command port</i>, the port through which the sound driver issues commands to the DSP.&nbsp; If it's successful, the port is returned in the <i>commandPort</i> argument, which needn't have been previously allocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first two arguments, <i>devicePort</i> and <i>ownerPort</i>, are the sound driver device port and the DSP owner port, as acquired through <b>SNDAcquire()</b>.</font>

<p><font face="Times">The DSP command port is required as an argument by almost all sound driver functions that communicate with the DSP.&nbsp; The one notable exception, for which you don't have to get the command port as it's gotten implicitly when needed, is if you send and retrieve DSP data via streams after having booted the DSP through the <b>SNDBootDSP()</b> sound library function.&nbsp; But even in this case getting the command port as a reflex to getting the DSP owner port won't serve you ill.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_get_volume()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_device_parms()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_new_device_port()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Reallocate the sound driver device port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_new_device_port(</b>port_t <i>devicePort</i>, port_t <i>superuserPort</i>, port_t *<i>newDevicePort</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function deallocates the sound driver device port <i>devicePort</i>, as previously acquired through <b>SNDAcquire()</b>, then allocates a new port to the device which it returns as <i>newDevicePort</i>.&nbsp; When the old device port is deallocated, so, too, are all its resource owner ports and sound streams; thus any currently operating sound driver tasks, such as recording and playing sounds, are aborted.&nbsp; Because of the ruthlessness of this act, you must be the UNIX superuser to call this function, as verified by the <i>superuserPort</i> argument, for which you should pass the return value of <b>host_priv_self()</b>.&nbsp; The new device port's registration with regard to the Network Name Server is the same as that of the old; in other words, if the old port had been registered (through <b>netname_check_in()</b>), the new one will be registered automatically.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_reply_handler()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Respond to asynchronous sound driver messages</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_reply_handler(</b>msg_header_t *<i>reply</i>, snddriver_handlers_t *<i>handlers</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_reply_handler()</b> helps your application respond to asynchronous sound driver messages.&nbsp; The function is designed around the <b>snddriver_handlers</b> structure, which provides a correspondence between the sound driver messages and a list of C functions that you provide.&nbsp; When you receive a message from the sound driver, you pass the message and a <b>snddriver_handlers</b> structure to <b>snddriver_reply_handler()</b> which then executes the handler function that corresponds to the message.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The definition of the <b>snddriver_handlers</b> structure (<b>typedef</b>'d, for convenience, as <b>snddriver_handlers_t</b>) reveals the nature of the functions that you can register as reply handlers:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct snddriver_handlers {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *arg;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeout;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_tagged_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; started;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_tagged_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; completed;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_tagged_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aborted;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_tagged_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paused;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_tagged_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resumed;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_tagged_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overflow;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_recorded_data_t&nbsp; recorded_data;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_dsp_cond_true_t&nbsp; condition_true;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_dsp_msg_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dsp_message;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sndreply_dsp_msg_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dsp_error;</font><br>
<img src="../../../Images/sp.gif" width=145 height=1><font face="Courier" size="-1">} snddriver_handlers_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The structure's <b>arg</b> field is a value that's passed to the reply handlers when they're called by <b>snddriver_reply_handler()</b>; you can set it to whatever value best suits your application, but keep in mind that the value must fit within the size of a pointer (four bytes).&nbsp; The <b>timeout</b> field is currently unused.</font>

<p><font face="Times">The final ten fields are the heart of the structure:&nbsp; Each corresponds to a particular sound driver message.&nbsp; The first six of these correspond to messages that indicate a change in the state of a stream (&quot;stream-state&quot; messages); in other words, the sound driver sends a specific message when a stream starts processing data, when it completes its processing, when it aborts, and so on.&nbsp; By setting a field to a particular function, you register that function as the handler for the message to which the field corresponds.&nbsp; For example, to establish a function named <b>handleStreamStart()</b> as the function that's executed when your application receives a stream-started message from the sound driver, you would do the following:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Create a snddriver_handlers_t and register the</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* function handleStreamStart() (which we'll assume already</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* exists) to process stream-started messages.</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">snddriver_handlers_t replyHandlers;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">replyHandlers.started = handleStreamStart;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">While this registers <b>handleStreamStart()</b> as the handler for stream-started messages, you must also tell the sound driver that you actually want such messages sent to your application.&nbsp; To do this, you set the <i>msgStarted</i> boolean argument to true when you call <b>snddriver_stream_start_reading()</b> or <b>snddriver_stream_start_writing()</b>.&nbsp; Analogous <i>msg...</i> message flags exist for the other five stream-state messages.</font>

<p><font face="Times">When the sound driver sends a stream-state message to your application, it sends it to the port that you specify as the last argument (<i>replyPort</i>) to <b>snddriver_stream_start_reading()</b> or <b>snddriver_stream_start_writing()</b>.&nbsp; To receive the message, you create a <b>msg_header_t</b> structure, set its <b>local_port</b> field to the stream's reply port, and then wait for the message to arrive by sitting in a message receive (<b>msg_receive()</b>) loop.&nbsp; After so capturing the message, you then pass it, along with your handler structure, to <b>snddriver_reply_handler()</b>.&nbsp; This is demonstrated by the example below.</font>

<p><font face="Times">Notice, from the definition of <b>snddriver_handlers</b>, that the six stream-state handlers are all of type <b>sndreply_tagged_t</b>.&nbsp; This type represents a two-argument function protocol that's defined as</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef void (*sndreply_tagged_t) (void *arg, int tag);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The functions that you register to handle the stream-state messages must adhere to this protocol.&nbsp; The values of the arguments are set by <b>snddriver_reply_handler()</b>:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>arg</i> is given the value of the <i>arg</i> field of the <b>snddriver_handlers</b> structure in which the function is registered.&nbsp; As mentioned earlier, you can set the structure's <i>arg</i> field to a (four-byte) value that suits the needs of your application.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>tag</i> is the region-identifying tag that you provide as an argument to <b>snddriver_stream_start_writing()</b> or <b>snddriver_stream_start_reading()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The seventh of the ten <b>snddriver_handlers</b> handler fields--<b>recorded_data</b>--also applies to streams.&nbsp; However, unlike the fist six, which are optional, <b>recorded_data</b> is essential when you're reading data from a stream.&nbsp; Its importance arises from the way that the sound driver handles read data:&nbsp; It keeps the data in the kernel's virtual memory until you ask to bring it into your application.&nbsp; The only way to bring this data back is to supply a <b>recorded_data</b> handler that does so.&nbsp; The following program excerpt demonstrates a typical way to achieve this effect.&nbsp; In the example, details such as acquiring the sound driver and sound resource owner ports are omitted.&nbsp; The read stream shown here is anonymous--the code can be used equally well for a stream that reads from sound-in or from the DSP:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* The code shown in the example requires the following header</font><br>
<img src="../../../Images/sp.gif" width=145 height=1><font face="Courier" size="-1">files&nbsp; */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;sound/snddriver_client.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach.h&gt;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Define a read stream tag, a read pointer, and a byte count</font><br>
<img src="../../../Images/sp.gif" width=145 height=1><font face="Courier" size="-1">variable. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define READ_TAG 1</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">static short *readData;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">static int readCount;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Create a recorded_data handler; the function's protocol is</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* explained following the example.</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">static void read_completed(void *arg, int tag, void *kernelData,</font><br>
<img src="../../../Images/sp.gif" width=320 height=1><font face="Courier" size="-1">int size)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Make sure this is the read stream. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (tag == READ_TAG) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">readData = (short *)kernelData;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">readCount = size;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Define a read port, a reply port, and a reply structure. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">port_t readPort, replyPort;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">snddriver_handlers_t replyHandlers;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Allocate a Mach message header. msg_header_t and MSG_SIZE_MAX</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* (and msg_receive, below) are defined in mach.h.</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">msg_header_t *reply_msg = (msg_header_t *)malloc(MSG_SIZE_MAX);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Create an error-check variable. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int err;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Allocate the reply port. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">err = port_allocate(task_self(), &amp;replyPort);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Set the recorded_data handler. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">replyHandlers.recorded_data = read_completed;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Set the amount of data you want to read; for the purposes of</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* this example, an arbitrary amount is specified.</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">readCount = 1024;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Here, a number of activities -- such as acquiring the sound</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* driver port and sound resource owner port, setting up a read</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* stream through snddriver_stream_setup(), and (possibly)</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* booting the DSP and sending it data -- are omitted.</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Enqueue a read request.&nbsp; The six 0 arguments are the message</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* request flags.</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">err = snddriver_stream_start_reading(readPort, 0, readCount,</font><br>
<img src="../../../Images/sp.gif" width=278 height=1><font face="Courier" size="-1">READ_TAG, 0,0,0,0,0,0, replyPort);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">.&nbsp; .&nbsp; .</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Sit in a message-receive loop. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while(1) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Set up the reply message.&nbsp; This must be done inside the</font><br>
<img src="../../../Images/sp.gif" width=187 height=1><font face="Courier" size="-1">* loop since msg_receive() may change the message header.</font><br>
<img src="../../../Images/sp.gif" width=187 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">replyMsg-&gt;msg_size = MSG_SIZE_MAX;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">replyMsg-&gt;msg_local_port = replyPort;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">err = msg_receive(replyMsg, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Dispatch the message to the reply handlers.*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">err = snddriver_reply_handler(replyMsg, &amp;replyHandlers);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Provide a means to break out of the loop. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">As implied by the example, you don't need to tell the sound driver that you want a data-recorded message to be sent to your application; the message is always sent automatically.&nbsp; The example also illustrates the rule that the reply port used to receive messages while in the <b>msg_receive()</b> loop is that which is specified as the final argument to the <b>snddriver_stream_start_reading()</b> function.</font>

<p><font face="Times">The data type of the <b>recorded_data</b> field dictates the protocol of the function that you design to bring data back to the application.&nbsp; The type is <b>sndreply_recorded_data_t</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef void (*sndreply_recorded_data_t)(void *arg, int tag,</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">void *kernelData, int size);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The first two arguments, <i>arg</i> and <i>tag</i>, are the same as in the <b>snddreply_tagged_t</b> type.&nbsp; <i>kernelData</i> is a pointer to the recorded data as it resides in the kernel; <i>size</i> is the size of the recorded data in bytes.</font>

<p><font face="Times">The final three <b>snddriver_handlers</b> fields correspond to messages that are inspired by the DSP:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The <b>condition_true</b> handler is called when a requested DSP host interface register condition comes true.&nbsp; (More accurately, the handler is called when the message that indicates that the condition is true is passed to <b>snddriver_reply_handler()</b>.)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>dsp_message</b> handles general messages that the sound driver receives from the DSP.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>dsp_error</b> does the same for DSP error messages.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For each of these three handlers, there is a corresponding sound driver function that enqueues a request for a condition, a DSP message, or a DSP error message, respectively:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>snddriver_dspcmd_req_condition()</b> blocks the DSP command queue until the state of the DSP host interface registers satisfies a requested condition.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>snddriver_dspcmd_req_msg()</b> requests that the messages in the DSP-reply buffer be sent to your application.&nbsp; You must include DSP-message protocol for this to have an effect.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>snddriver_dspcmd_req_err()</b> requests that the 512-byte DSP-reply error buffer be sent in a message.&nbsp; You must include DSP-error protocol for this to have an effect.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">As with the <b>snddriver_stream_start...()</b> functions, the three DSP request functions require that you provide a reply port as an argument.&nbsp; It's to this reply port that the sound driver sends the requested DSP-inspired messages.&nbsp; A single call to one of these functions causes a single reply message to be sent to your application.&nbsp; Thus, for each call to <b>snddriver_dspcmd_req_msg()</b>, for example, your application will receive one message from the sound driver.</font>

<p><font face="Times">The <b>condition_true</b> handler is of type <b>sndreply_dsp_cond_true_t</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef void (*sndreply_dsp_cond_true_t)(void *arg, u_int mask,</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">u_int flags, u_int registers);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>arg</i> is the value of the <b>arg</b> field.&nbsp; The next two arguments, <i>mask</i> and <i>flags</i>, are given the values that were passed to <b>snddriver_dspcmd_req_condition()</b> (which also has <i>mask</i> and <i>flags</i> arguments).&nbsp; <i>registers</i> encodes the current status of the four DSP host interface registers in a single 32-bit vector.&nbsp; See the description of <b>snddriver_dspcmd_req_condition()</b> for more information on how this works.</font>

<p><font face="Times">The <b>dsp_message</b> and <b>dsp_error</b> are of type <b>sndreply_dsp_msg_t</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef void (*sndreply_dsp_msg_t)(void *arg, int *data, int size);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>arg</i> is the value of the <b>arg</b> field.&nbsp; <i>data</i> is a pointer to the contents of the appropriate DSP-message buffer (regular or error, as the handler is <b>dsp_message</b> or <b>dsp_error</b>).&nbsp; <i>size</i> is the size of the buffer contents, in bytes.</font>

<p><font face="Times"><b>snddriver_reply_handler()</b> ignores messages for which you haven't created and registered a handler function.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_stream_start_reading()</b>, <b>snddriver_stream_start_writing()</b>, <b>snddriver_dspcmd_req_condition()</b>, <b>snddriver_dspcmd_req_msg()</b>, <b>snddriver_dspcmd_req_err()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_set_device_parms(), snddriver_get_device_parms(), snddriver_set_volume(), snddriver_get_volume(), snddriver_set_ramp()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set and get sound playback attributes</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_set_device_parms(</b>port_t <i>devicePort</i>, boolean_t <i>speakerOn</i>, boolean_t <i>filterOn</i>, boolean_t <i>zerofill</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_get_device_parms(</b>port_t <i>devicePort</i>, boolean_t *<i>speakerOn</i>, boolean_t *<i>filterOn</i>, boolean_t *<i>zerofill</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_set_volume(</b>port_t <i>devicePort</i>, int <i>leftVolume</i>, int <i>rightVolume</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_get_volume(</b>port_t <i>devicePort</i>, int *<i>leftVolume</i>, int *<i>rightVolume</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_set_ramp(</b>port_t <i>devicePort</i>, int <i>rampOn</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions set and get attributes of the sound playback system.&nbsp; Each takes, as its first argument, the sound driver device port as acquired through <b>SNDAcquire()</b>.&nbsp; You needn't acquire ownership of sound-out to set the playback attributes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The NXSoundOut class can be used in place of all these functions.</font>

<p><font face="Times"><b>snddriver_set_device_parms()</b> sets three attributes as specified by the values of its boolean arguments:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The internal speaker is turned on or off as <i>speakerOn</i> is true or false.&nbsp; Calling the function with alternating true and false <i>speakerOn</i> values is equivalent to toggling the Mute key (Command Mute) on the keyboard.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Similarly, the value of <i>filterOn</i> turns the de-emphasis filter on or off.&nbsp; The filter can be controlled from the keyboard by toggling the louder key while holding down the Command key (this isn't marked on the keyboard).&nbsp; In addition, the de-emphasis filter is automatically turned on when a de-emphasis format sound is played and returned to its previous state when the sound is done playing.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">During playback, low sampling rate (22.05 kHz) sounds are converted to the high sampling rate (44.1 kHz) as they are sent to the DAC (which converts data at 44.1 kHz only).&nbsp; To do this, the sound driver emits an extra sample for every existing sample in the sound data.&nbsp; The value of <i>zerofill</i> determines whether these extra samples are set to 0 (true) or if they're copies of the existing samples (false).&nbsp; In almost all cases, copying the samples is preferable, since zerofilling results in a decrease in power.&nbsp; Note that you can't toggle this attribute from the keyboard.&nbsp; Also, keep in mind that CODEC rate sounds are converted to 22.05 kHz before being sent to the DAC and so are also affected by the state of <i>zerofill</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>snddriver_get_device_parms()</b> returns, by reference in its final three arguments, the values of the attributes described above.</font>

<p><font face="Times"><b>snddriver_set_volume()</b> sets the volume of the internal speaker and similarly adjusts the signal that's sent to the stereo headphone jack (the signal to the line-out jacks is unaffected).&nbsp; The two channels of the stereo signal are set independent of each other, specified as the values of <i>leftVolume</i> and <i>rightVolume.</i>&nbsp; The volume of the internal speaker is the sum of these two values.&nbsp; Volume values are integers in the range 1 to 43, inclusive, where the unit is equal to 2 decibels.&nbsp; A volume of 1 is inaudible and 43 is full blast.&nbsp; An argument value outside this range will yield some unexpected volume within the range.&nbsp; You can also adjust playback volume by pressing the volume keys on the keyboard.&nbsp; Each discrete tap on a volume key increments or decrements both the left and the right volume settings by 1.</font>

<p><font face="Times"><b>snddriver_get_volume()</b> returns the left and right playback volumes by reference in <i>leftVolume</i> and <i>rightVolume</i>, respectively.</font>

<p><font face="Times">By default, sounds are ramped during playback:&nbsp; The first few samples are ramped up from zero and the last samples are ramped down.&nbsp; This helps prevent clicks at the beginnings and ends of sounds.&nbsp; <b>snddriver_set_ramp()</b> enables or disables this feature as its <i>rampOn</i> argument is nonzero or zero.&nbsp; You almost always want ramping enabled; the one obvious case in which it's undesirable is if you're chaining a series of separate sounds that are meant to be played seamlessly, one immediately after the other.&nbsp; In this case, ramping will cause annoying amplitude dips at each seam.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>SNDSetVolume()</b>, + <b>setVolume::</b> (Sound),</font> <img src="../../../Images/c2D.gif" width=8 height=4> <font face="Times"><b>setAttenuationLeft:right:</b> (NXSoundOut)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_set_dsp_owner_port(), snddriver_set_sndin_owner_port(), snddriver_set_sndout_owner_port()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Acquire ownership of sound resources</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_set_dsp_owner_port(</b>port_t <i>devicePort</i>, port_t <i>ownerPort</i>, port_t *<i>negotiationPort</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_set_sndin_owner_port(</b>port_t <i>devicePort</i>, port_t <i>ownerPort</i>, port_t *<i>negotiationPort</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_set_sndout_owner_port(</b>port_t <i>devicePort</i>, port_t <i>ownerPort</i>, port_t *<i>negotiationPort</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions try to acquire ownership of the DSP, sound-in, or sound-out by setting the resource's owner port to a port that you supply.&nbsp; They duplicate part of the functionality provided by <b>SNDAcquire()</b>; the latter should, in most cases, be used to the exclusion of these.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The arguments are the same for all three functions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>devicePort</i> is a valid port to the sound driver device, as acquired through <b>SNDAcquire()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>ownerPort</i> is the port that will become the owner port for the requested resource if the function is successful.&nbsp; You must have already allocated <i>ownerPort</i> through the function <b>port_allocate()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the function successfully acquires ownership of the resource, then the port pointed to by <i>negotiationPort</i> is registered as the negotiation port for the resource.&nbsp; However, if the function isn't successful--most likely because ownership of the resource has already been claimed--then the currently registered negotiation port is returned in the <i>negotiationPort </i>argument.&nbsp; By convention you point <i>negotiationPort</i> to <i>ownerPort</i> before calling these functions, thereby making the owner port accessible to other tasks.&nbsp; Similarly, if your bid for ownership fails and the current owner has followed this convention, then you can use the port returned in <i>negotiationPort</i> as the owner port for the resource.&nbsp; Note, however, that if the function call fails, there's no way to determine if the port pointed to by <i>negotiationPort</i> is actually the owner port.&nbsp; If you want to acquire sole ownership of a resource, set <i>negotiationPort</i> to something other than the <i>ownerPort</i> before calling these functions.&nbsp; This will ensure that only the caller will have access to the resource (assuming that the function is successful).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A single port can be used to claim ownership of more than one device.&nbsp; This is sometimes necessary when setting up a multiple-device stream (as explained in <b>snddriver_stream_setup()</b>).&nbsp; In the following example, the same port attempts to own both the DSP and sound-out:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">err = port_allocate(task_self(), &amp;ownerPort)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Acquire ownership of the DSP. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">err=snddriver_set_dsp_owner_port(devPort, ownerPort, &amp;negPort);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Acquire ownership of sound-out. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">err=snddriver_set_sndout_owner_port(devPort,ownerPort,&amp;negPort);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">After you've claimed ownership of a resource, you should do something with it.&nbsp; With sound-in you set up a stream port through which you read (record) data.&nbsp; This is done by calling the <b>snddriver_stream_setup()</b> and <b>snddriver_stream_start_reading() </b>functions.&nbsp; Analogously, with sound-out you set up a stream through which you write (playback) data through the <b>snddriver_stream_start_writing()</b> function.</font>

<p><font face="Times">If you claim ownership of the DSP you should also acquire the DSP command port by calling <b>snddriver_get_dsp_cmd_port()</b>. Most of the functions that access the DSP require the command port as an argument.&nbsp; You can also set up streams to the DSP as you would to sound-in or sound-out.&nbsp; Successfully setting the DSP's owner port puts the DSP in its reset state.</font>

<p><font face="Times">To relinquish ownership of a resource, you deallocate the owner port by calling <b>port_deallocate()</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">err = port_deallocate(task_self(), ownerPort);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Deallocating a resource's owner unregisters the resource's negotiation port.&nbsp; All ports are automatically deallocated when your application exits.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_stream_setup()</b>, <b>snddriver_get_dsp_cmd_port()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_set_ramp()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_device_parms()</b></font>

<p><font face="Helvetica"><b>snddriver_set_sndin_owner_port()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_dsp_owner_port()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_set_sndout_bufcount(), snddriver_set_sndout_bufsize(), snddriver_stream_ndma()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Configure stream transfer buffers</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_set_sndout_bufcount(</b>port_t <i>devicePort</i>, port_t <i>sndoutPort</i>, int <i>count</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_set_sndout_bufsize(</b>port_t <i>devicePort</i>, port_t <i>sndoutPort</i>, int <i>size</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>snddriver_stream_ndma(</b>port_t <i>streamPort</i>, int <i>regionTag</i>, int <i>count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions let you control the number and size of the DMA buffers that are used to transfer data in a stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>snddriver_set_sndout_bufcount()</b> sets the number of buffers that are used when playing back sounds; the <i>count</i> argument, which must be greater than 0, establishes the buffer count.&nbsp; Four buffers are used in the default configuration.</font>

<p><font face="Times"><b>snddriver_set_sndout_bufsize()</b> sets the size of the sound-out buffers (in bytes) to the value of the <i>size</i> argument.&nbsp; This function is needed only if you're using a linked stream to sound-out (see the <b>snddriver_stream_setup()</b> function for more on linked streams).&nbsp; The value of <i>size</i> must be no greater than <b>vm_page_size</b>, the size of a page of virtual memory; the default is <b>vm_page_size</b>.&nbsp; If you're writing directly to the sound-out stream--in other words if the stream to sound-out is configured as SNDDRIVER_STREAM_TO_SNDOUT_22 or ...SNDOUT_44--the size of the sound-out buffers is computed from the <i>sampleCount</i> argument to <b>snddriver_stream_setup()</b> and the size set here is ignored.</font>

<p><font face="Times">For both of these functions, the <i>devicePort</i> and <i>sndoutPort</i> arguments are ports to the sound driver device and to sound-out, as acquired through <b>SNDAcquire()</b>.</font>

<p><font face="Times"><b>snddriver_stream_ndma()</b> sets, to <i>count</i>, the number of DMA transfer buffers that are used to receive data from sound-in, and to transmit and receive data to and from the DSP.&nbsp; The DMA buffer count can be set on a region-by-region basis; the stream and region to which a particular setting applies are identified by the <i>streamPort</i> and <i>regionTag</i> arguments, respectively.&nbsp; Note that in a linked stream to sound-out, the buffer count to and from the DSP is automatically set to the sound-out buffer count (overruling the setting made through this function).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_stream_setup()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_set_sndout_bufsize()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_sndout_bufcount()</b></font>

<p><font face="Helvetica"><b>snddriver_set_sndout_owner_port()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_dsp_owner_port()</b></font>

<p><font face="Helvetica"><b>snddriver_set_volume()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_set_device_parms()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_stream_control(), snddriver_stream_nsamples()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Control and query a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_stream_control(</b>port_t <i>streamPort</i>, int <i>regionTag</i>, int <i>control</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_stream_nsamples(</b>port_t <i>streamPort</i>, int *<i>byteCount</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>snddriver_stream_control()</b> provides control over an active stream by allowing you to apply a controlling operation to one or more of the stream's enqueued regions.&nbsp; The stream and the regions therein are identified by the function's first two arguments:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>streamPort</i> is the stream's port, as created by <b>snddriver_stream_setup()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>regionTag</i> is the integer identifier that you gave the region (or regions) in a previous call to <b>snddriver_stream_start_writing()</b> or <b>snddriver_stream_start_reading()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A tag value of 0 causes the controlling operation to be applied to all regions enqueued on the stream.</font>

<p><font face="Times">You specify the controlling operation by passing one of the following constants as the control argument:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_PAUSE_STREAM causes the stream to pause.&nbsp; If data is currently being read from or written to the specified region, the read or write is immediately suspended.&nbsp; If the region isn't yet active, the pause takes effect when the region comes to the top of the stream's queue (it's paused just before the first sample is read or written).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_RESUME_STREAM resumes a previously paused stream.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_ABORT_STREAM terminates the stream's activity when the specified region comes to the top of the queue; the queue is then cleared.&nbsp; If the region is currently being acted upon, the stream is terminated immediately.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_AWAIT_STREAM is used to retrieve a partially recorded region from a stream that's reading data--normally, you can't retrieve such data until the entire region has been filled.&nbsp; If the specified region is currently active, a data-recorded message is sent to the reply port that you registered in <b>snddriver_stream_start_reading()</b>.&nbsp; You then pass the message to <b>snddriver_reply_handler()</b> which calls the <b>recorded_data</b> reply handler.&nbsp; The unrecorded portion of the region continues.&nbsp; If the specified region isn't currently active, this has no effect.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">While you can use any of these four at the same time by or'ing them in <i>control</i>, the only combination that's of use is SNDDRIVER_AWAIT_STREAM or'd with one of the other three.&nbsp; For example, by setting <i>regionTag</i> to 0 and <i>control</i> to</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">SNDDRIVER_PAUSE_STREAM | SNDDRIVER_AWAIT_STREAM</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">you immediately pause the stream and can then bring back data from the current region.</font>

<p><font face="Times">You can request that a stream-paused, stream-resumed, or stream-aborted message be sent to the reply port when you pause, resume, or abort a stream, respectively, by setting the appropriate <i>msg...</i> flag to true in your call to <b>snddriver_stream_start_...()</b>.</font>

<p><font face="Times"><b>snddriver_stream_nsamples()</b> returns the number of bytes (<i>not</i> samples, despite the name of the function) that have been read from or written to a particular stream.&nbsp; The steam is specified by <i>streamPort</i>.&nbsp; The byte count is returned by reference in the <i>byteCount</i> argument.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_stream_setup()</b>, <b>snddriver_stream_start_writing()</b>, <b>snddriver_stream_start_writing()</b>, <b>snddriver_reply_handler()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_stream_nsamples()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_stream_control()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_stream_setup()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Configure a sound stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_stream_setup(</b>port_t <i>devicePort</i>, port_t <i>ownerPort</i>, int <i>dataPath</i>, int <i>sampleCount</i>, int <i>sampleSize</i>, int <i>lowWater</i>, int <i>highWater</i>, int *<i>protocol</i>, port_t *<i>streamPort</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">A stream, as it applies to the sound driver, is a path through which an indefinitely long sequence of data passes.&nbsp; One end of a sound driver stream typically lies in your application's memory, while at the other end is a sound device.&nbsp; For example, to record a sound from the microphone you create a stream from sound-in to your application.&nbsp; Analogously, a stream from your application to sound-out is required to play back sound data.&nbsp; A single stream of data can pass through more than one sound device; for example, you can send data from your application to the DSP from whence it issues directly to sound-out.&nbsp; Thus you can DSP-process and play your sound data in one motion, without incurring the overhead of bringing the processed data back into your application.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>snddriver_stream_setup()</b> function creates a port to a sound stream.&nbsp; The port, returned in the <i>streamPort</i> argument, is used as an identifier in subsequent calls to functions that write to, read from, and otherwise control the stream (as listed at the end of this description).</font>

<p><font face="Times">The function's first two arguments are the usual capability ports:&nbsp; <i>devicePort</i> is a port to the sound driver device, and <i>ownerPort </i>is the owner port for <i>all</i> resources that are touched by the stream, as acquired through <b>SNDAcquire()</b>.</font>

<p><font face="Times">You establish the stream's course--the source and destination of its data--by setting <i>dataPath</i> to one of constants listed below. There are two types of data paths:&nbsp; &quot;simple&quot; and &quot;linked.&quot;&nbsp; The simple data paths (listed below) connect your application to a sound resource:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_STREAM_FROM_SNDIN; read samples from the CODEC microphone.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_STREAM_TO_SNDOUT_44; write samples to the stereo DAC at the high sampling rate (44.1 kHz).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_STREAM_TO_SNDOUT_22; write samples to the stereo DAC at the low sampling rate (22.05 kHz).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DMA_STREAM_TO_DSP; write data via DMA to the DSP.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DMA_STREAM_FROM_DSP; read data via DMA from the DSP.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Six linked data paths connect the DSP directly to sound-out:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_STREAM_DSP_TO_SNDOUT_44 and ...SNDOUT_22; DSP-processed samples are sent directly to sound-out at the low or high sampling rate.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_STREAM_THROUGH_DSP_TO_SNDOUT_44 and ...SNDOUT_22; data flows from your application to the DSP and thence directly to sound-out at the high or low sampling rate.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_44 and ...SNDOUT_22; data flows from your application to the DSP and thence directly to sound-out using DMA.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Data is transferred through a stream in buffers.&nbsp; The <i>sampleCount</i> argument establishes the length of a single transfer buffer in samples (or data elements); the size of a single sample is set by the <i>sampleSize</i> argument.&nbsp; The maximum size for a transfer buffer (in bytes) is that of a page of virtual memory, as given by the global read-only variable <b>vm_page_size</b>.&nbsp; Typically, the transfer buffer size is set to this limit:&nbsp; If, for example, the samples that you're sending through the stream are two bytes wide, then, to follow this convention, you would set <i>sampleCount</i> to <b>vm_page_size</b>/2.&nbsp; If the stream uses DMA, then the size of a transfer buffer (in bytes) must be a power of 2 greater than or equal to 16.</font>

<p><font face="Times">For some applications--particularly those in which latency is an issue--setting the number of transfer buffers that are used can be as important as setting the size of the buffers.&nbsp; This is done through the <b>snddriver_set_sndout_bufcount()</b> and <b>snddriver_stream_ndma()</b> functions.</font>

<p><font face="Times">The range of acceptable values for the <i>sampleSize</i> argument depends on the stream's data path:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If you're reading from sound-in into your application, then <i>sampleSize</i> must be set to 1 to accommodate the 8-bit mu-law samples generated by the CODEC microphone input.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If you're writing from your application to sound-out or from the DSP to sound-out , then <i>sampleSize</i> must be 2 since the DAC expects 16-bit interleaved-stereo samples.&nbsp; Note that while the DAC processes data only at the high sampling rate, the sound driver performs the conversion from low to high for you.&nbsp; This isn't true for playback of CODEC-rate sounds for which you typically download a sampling-rate conversion program to the DSP, and then create a stream that goes through the DSP and then directly to sound-out.&nbsp; This is what the <b>SNDStartPlaying()</b> function does, for example.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">In all the other paths, your application writes to or reads from the DSP.&nbsp; Here, <i>sampleSize</i> can be 1, 2, or 4, according to the sample size expected by or produced by your DSP program.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <i>lowWater</i> and <i>highWater</i> arguments are memory threshold values, measured in bytes, that are inspected by the sound driver.&nbsp; During an operation such as recording or playback, successive pages of sound data are locked into physical memory (or &quot;wired down&quot;) during which time they're read from or written to.&nbsp; As a page is completed, it's unwired.&nbsp; The driver tries to maintain at least <i>lowWater</i> bytes of wired-down memory; if the amount drops below this threshold, the driver wires down pages until it reaches the <i>highWater</i> mark.</font>

<p><font face="Times">If your stream touches the DSP, then you need to set the DSP protocol by passing the appropriate value to <b>snddriver_dsp_protocol()</b>.&nbsp; The <i>protocol</i> argument found here helps you create this value:&nbsp; The function or's the appropriate protocol constants, as determined by the characteristics of the stream that you're setting up, into <i>protocol</i> and returns the new value by reference.&nbsp; You then pass the variable to <b>snddriver_dsp_protocol()</b>.&nbsp; You should initialize your protocol variable to SNDDRIVER_DSP_PROTO_RAW before calling <b>snddriver_stream_setup()</b>, as shown in the following example:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Initialize the protocol variable. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int protocol = SNDDRIVER_DSP_PROTO_RAW;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int err;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Set up a stream to the DSP. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">err = snddriver_stream_setup(..., SNDDRIVER_STREAM_TO_DSP,</font><br>
<img src="../../../Images/sp.gif" width=376 height=1><font face="Courier" size="-1">.., &amp;protocol, ...);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Set up a stream from the DSP. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">err = snddriver_stream_setup(..., SNDDRIVER_STREAM_FROM_DSP,</font><br>
<img src="../../../Images/sp.gif" width=376 height=1><font face="Courier" size="-1">..., &amp;protocol, ...);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Pass the protocol to the sound driver. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">err = snddriver_dsp_protocol(..., protocol);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (err != 0)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">. . .</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The protocol constants are described as part of the <b>snddriver_dsp_protocol()</b> function.</font>

<p><font face="Times">Having created a stream, you can read from it, write to it, and control it by passing the port returned in <i>streamPort</i> to the following functions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>snddriver_stream_start_reading()</b> and <b>snddriver_stream_start_writing()</b> read from and write to a stream, respectively. Streams from sound-in or from the DSP can only be read; similarly, streams to sound-out or to the DSP can only be written.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>snddriver_stream_control()</b> pauses, resumes, and aborts an active stream.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>snddriver_stream_nsamples()</b> measures the amount of data that has passed through the stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For sound-in and sound-out, streams are the only way to travel.&nbsp; This isn't true of the DSP; the sound driver provides a one-shot, non-stream DSP read and write mechanism, embodied in <b>snddriver_dsp_read()</b>, <b>snddriver_dsp_dma_read()</b>, and analogous <b>...write()</b> functions, that can be more efficient for short data transfers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_stream_start_reading()</b>, <b>snddriver_stream_start_writing()</b>, <b>snddriver_set_sndout_bufcount()</b>, <b>snddriver_stream_ndma()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica"><b>snddriver_stream_start_reading()</b></font> <img src="../../../Images/cAE.gif" width=14 height=7> <font face="Helvetica"><b>See snddriver_stream_start_writing()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>snddriver_stream_start_writing(), snddriver_stream_start_reading()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Send data to and retrieve data fom a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times">sound/snddriver_client.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times">kern_return_t <b>snddriver_stream_start_writing(</b>port_t <i>streamPort</i>, void *<i>data</i>, int <i>sampleCount</i>, int <i>regionTag</i>, boolean_t <i>preempt</i>, boolean_t <i>deallocateWhenDone</i>, boolean_t <i>msgStarted</i>, boolean_t <i>msgCompleted</i>, boolean_t <i>msgAborted</i>, boolean_t <i>msgPaused</i>, boolean_t <i>msgResumed</i>, boolean_t <i>msgUnderrun</i>, port_t <i>replyPort</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>snddriver_stream_start_reading(</b>port_t <i>streamPort</i>, char *<i>filename</i>, int <i>sampleCount</i>, int <i>regionTag</i>, boolean_t <i>msgStarted</i>, boolean_t <i>msgCompleted</i>, boolean_t <i>msgAborted</i>, boolean_t <i>msgPaused</i>, boolean_t <i>msgResumed</i>, boolean_t <i>msgOverrun</i>, port_t <i>replyPort</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These two functions cause data to be written to or read from a sound stream identified by <i>streamPort</i>, which must have been created by a previous call to <b>snddriver_stream_setup()</b>.&nbsp; The two functions operate in much the same manner:&nbsp; Each invocation enqueues a single region of data that's operated on (either read from or written to) asynchronously by the sound driver.&nbsp; However, there's a fundamental difference between the two functions in that <b>...writing()</b> enqueues a region that you pass as the <i>data</i> argument, while <b>...reading()</b> stores the data it reads in a region that it allocates itself.&nbsp; To bring the read data back into your application, you must create and register a reply-handler function that transfers the data when the read is complete.&nbsp; The mechanism for doing this is explained (and an example given) in the <b>snddriver_reply_handler()</b> function description.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The <b>...reading()</b> argument <i>filename--</i>which would imply that the read data is written to a file--is currently unused. Also note that <i>the</i> data buffer you pass to <b>...writing()</b> is write-protected:&nbsp; Any changes you make to the data after it's been enqueued won't be seen by the driver.</font>

<p><font face="Times"><i>sampleCount</i> is the number of samples in the region that's being written or read.&nbsp; If you're writing to the DSP, <i>sampleCount</i> must be a multiple of the <i>sampleCount</i> argument to <b>snddriver_stream_setup()</b>.&nbsp; In all other cases, <i>sampleCount</i> can be any value.</font>

<p><font face="Times"><i>regionTag</i> is an integer that identifies the region.&nbsp; While you can give each region a distinct tag, you usually create a single tag value for each stream that you set up.&nbsp; For example, if you have a stream that reads data from sound-in and another that writes to sound-out, you would create two tag values, one for either stream, and then tag each region with the value associated with its stream.</font>

<p><font face="Times">If the <i>preempt</i> flag (<b>...writing()</b> only) is true, the sound driver starts writing <i>data</i> immediately after the current transfer buffer has been completely processed.&nbsp; When it's finished with the preempting region, the driver returns to its region queue, disregarding the rest of the partially-processed preempted region.</font>

<p><font face="Times">If <i>deallocateWhenDone</i> (<b>...writing()</b> only) is true, the region's data is deallocated after it's written.</font>

<p><font face="Times">The six <i>msg...</i> flags register requests for stream-state messages to be sent asynchronously to the port <i>replyPort</i>.&nbsp; The first flags, <i>msgStarted</i> and <i>msgCompleted</i>, if true, cause messages to be sent just as the driver begins its first and just after it finishes its last transfer of data from the region, respectively.&nbsp; The conditions referred to by the next three arguments, <i>msgAborted</i>, <i>msgPaused</i>, and <i>msgResumed</i>, occur as a result of calls to <b>snddriver_stream_control()</b>.&nbsp; The <i>msgUnderrun</i> (for <b>...writing()</b>) or <i>msgOverrun</i> (for <b>...reading()</b>) argument, if true, causes a message to be sent if the driver can't transfer data quickly enough to keep up with real time.&nbsp; In general this is only signficant if data is being read from sound-in or written to sound-out:&nbsp; Underrun results in brief pauses in playback; overrun causes incoming samples to be lost.&nbsp; You normally process the asynchronous messages that you receive by passing them to the <b>snddriver_reply_handler()</b> function.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN  </b></font><font face="Times">Returns an error code:&nbsp; 0 on success, nonzero on failure.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>snddriver_reply_handler</b>, <b>snddriver_stream_setup</b></font></td></tr>

</table>



<p>

</body>
</html>
