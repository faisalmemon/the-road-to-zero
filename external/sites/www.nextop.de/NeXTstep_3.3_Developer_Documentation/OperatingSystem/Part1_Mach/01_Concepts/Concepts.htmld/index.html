<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/OperatingSystem/Part1_Mach/01_Concepts/Concepts.rtf -->
<!-- Date: Sun Jun 28 20:09:14 1998 -->
<head>
<title>Concepts</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3" color="#FF00FF"><b>1</b></font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+3"><i>Mach Concepts</i></font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Mach, the operating system of all NeXT computers, was designed by researchers at Carnegie Mellon University (CMU).&nbsp; Mach is based on a simple communication-oriented kernel, and is designed to support distributed and parallel computation while still providing UNIX 4.3BSD compatibility.</font>

<p><font face="Times">The NeXT Mach operating system is a port of CMU Release 2.0, with additional features both from NeXT and from later versions of CMU Mach.&nbsp; NeXT-only features include the Bootstrap Server and loadable kernel servers.&nbsp; Features from CMU Release 2.5 and beyond include scheduling and some details of messaging.</font>

<p><font face="Times">Mach consists of the following components:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A small, extensible system kernel that provides scheduling, virtual memory, and interprocess communications; the kernel exports a small number of abstractions to the user through an integrated interface.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Operating system support environments that provide distributed file access, transparent network interprocess communication, remote execution facilities, and UNIX 4.3BSD emulation.&nbsp; Many traditional operating system functions can be implemented by user programs or servers outside the kernel.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Although Mach's design is conceptually unlike that of UNIX 4.3BSD, it maintains UNIX 4.3BSD compatibility.&nbsp; Mach system calls are upwardly compatible with those of UNIX 4.3BSD, and Mach supports UNIX 4.3BSD commands.&nbsp; This compatibility is transparent to user programs and requires no special libraries or other utilities.&nbsp; Most programs that operate under UNIX 4.3BSD operate under Mach without modification, after being recompiled.</font>

<p><font face="Times">Mach provides the following features not found in UNIX 4.3BSD:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Multiple tasks, each with a large, paged virtual memory space</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Multiple threads of execution within each task, with a flexible scheduling facility</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Flexible sharing of memory between tasks</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Efficient and consistent message-based interprocess communication</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Memory-mapped files</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Transparent network extensibility</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A flexible, capability-based approach to security and protection</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Support for multiprocessor scheduling</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Mach is sometimes referred to as an object-oriented operating system because it provides most services through user-level programs accessible by a consistent system of message passing.&nbsp; It's important, however, to distinguish between Mach objects and messages and the Objective C objects and messages used in higher-level software kits such as the Application Kit</font><font size="-2"><sup><sup>TM</sup></sup></font><font face="Times">.&nbsp; Mach objects and messages are distinct from those used in the kits.&nbsp; Kit objects can, however, communicate with the operating system by sending Mach messages to Mach objects or by using the standard UNIX system call interface.</font>

<p><font face="Times">This chapter describes both the Mach kernel and user-level programs that interact with it, but doesn't attempt to redocument standard features of UNIX 4.3BSD.&nbsp; (See the &quot;Suggested Reading&quot; section at the end of this manual for information about available UNIX 4.3BSD documentation.)&nbsp; Individual Mach functions are described in detail in Chapter 4, &quot;Mach Functions,&quot; and summarized in the <i>NEXTSTEP Programming Interface Summary</i>.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+2"><b>Design Philosophy</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Several factors were considered in choosing an operating system for NeXT computers.&nbsp; It was important that the operating system be:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Multiuser and multitasking</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Network-compatible</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">An excellent program-development environment</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Well-represented in the university, research, and business communities</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Extensible and robust</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Capable of providing room for growth and future extensions</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Although a standard version of the UNIX operating system would have satisfied many of these criteria, NeXT wanted an operating system offering better performance and a better foundation for future extensions.&nbsp; Mach, with its UNIX 4.3BSD compatibility and improved system design, provided these.</font>

<p><font face="Times">UNIX 4.3BSD compatibility is important because as a multitasking, multiuser operating system, the UNIX environment has gained wide acceptance in many fields, particularly education.&nbsp; Since the creation of the UNIX operating system in 1969, many hours have been spent testing, improving, and extending its features.&nbsp; Currently the UNIX environment is considered one of the best for developing both small and large applications.</font>

<p><font face="Times">However, the success and longevity of the UNIX operating system have exacted their own costs.&nbsp; Many of the features that made the UNIX operating system popular have disappeared in the quest for functionality beyond the scope of the original design.&nbsp; During two decades, the UNIX operating system has grown from a system designed for 16-bit minicomputers without paged memory or networking, to a system that supports multiprocessor mainframes with virtual memory and support for both local and wide-area networks.&nbsp; As a result of these extensions, the UNIX kernel (originally attractive to developers because of its small size, handful of system calls, and ease of modification) has grown to immense proportions.</font>

<p><font face="Times">As new features have been added to the kernel, its size and complexity have grown to the point where its underlying conceptual structure is obscured.&nbsp; Over time, programmers have added multiple routines that perform similar services for different kernel features.&nbsp; The complexity added by each of these extensions ensures that future kernel extensions will be based on an even less sound understanding of what already exists.&nbsp; The result is a system whose complex internal state and interactions make it very difficult to extend, debug, and configure.</font>

<p><font face="Times">Not only has the UNIX kernel grown more complex as new features have been added, so has the interface presented to programmers who would like to make use of these features.&nbsp; For example, current UNIX systems provide an overwhelming variety of interprocess communication (IPC) facilities, including pipes, named pipes, sockets, and message queues. Unfortunately, none of these facilities is general enough to replace the others.&nbsp; As a result, the programmer must understand not only how to use a variety of IPC facilities, but also the tradeoffs involved in choosing one over another.</font>

<p><font face="Times">While retaining UNIX 4.3BSD functionality, Mach departs from current UNIX design and returns to the tenets on which the UNIX operating system was originally built.&nbsp; Foremost among these is the idea that the kernel should be as small as possible, containing only a set of conceptually simple, yet powerful, primitive functions that programmers can use to construct more complex objects.</font>

<p><font face="Times">Mach is designed to put most services provided by the current UNIX kernel into independent user-level programs, with the Mach kernel itself providing only the most basic services:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Processor scheduling</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Interprocess communication</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Management of virtual memory</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">These services and others are accessed through a single form of IPC, regardless of whether they're provided by the kernel or by user-level programs.&nbsp; Modularity and a consistent pattern of IPC simplify the interface presented to the programmer.&nbsp; For example, a network expert can implement a new protocol without having to understand or modify other subsystems in the operating system.</font>

<p><font face="Times">Modularity has other advantages as well.&nbsp; Moving functionality to user-level programs makes the kernel smaller and therefore easier to comprehend and debug.&nbsp; Another advantage is the ability to use standard debuggers and other tools to develop new system services rather than having to use special, less powerful tools.&nbsp; Also, configuring the system is simply a matter of choosing which user-level services to initiate, rather than building and linking a new kernel.</font>

<p><font face="Times">The movement of Mach toward providing most operating system features as user-level processes is an evolutionary one. Currently, Mach supports some features within the kernel while others exist at the user level.&nbsp; Although Mach will change as it evolves, its developers are committed to maintaining UNIX 4.3BSD compatibility at each stage of development.&nbsp; If you design your programs to run under UNIX 4.3BSD, they'll run under current and subsequent releases of the Mach operating system. However, if you choose to take advantage of features unique to Mach, future releases of the operating system may require you to modify and recompile some of your programs.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+2"><b>The Mach Kernel</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Mach minimizes kernel size by moving most kernel services into user-level processes.&nbsp; The kernel itself contains only the services needed to implement a communication system between various user-level processes.&nbsp; The kernel exports several abstractions to users, including tasks, threads, ports, and messages.</font>

<p><font face="Times">The functionality of the Mach kernel can be divided into the following categories:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Task and thread creation and management facilities</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Port management facilities</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Basic message functions and support facilities</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Virtual memory management functions</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Scheduling functions</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Descriptions of these areas of functionality are provided in the following sections.&nbsp; Messages are described in detail in Chapter 2, &quot;Using Mach Messages.&quot;</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Mach Tasks and Threads</b></font>

<p><font face="Times">Mach splits the traditional UNIX notion of a process into two abstractions, the task and the thread:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A <i>task</i> is the environment within which program execution occurs.&nbsp; It's also the basic unit of resource allocation--each task includes a paged virtual address space and port rights that protect access to system resources such as processors, communication capabilities, and virtual memory.&nbsp; The task itself performs no computation; rather, it's a framework for running threads.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A <i>thread</i> is the basic unit of execution.&nbsp; It's a lightweight process executing within a task, and consists solely of the processor state (such as program counter and hardware registers) necessary for independent execution.&nbsp; Each thread executes within the context of a single task, though each task may contain more than one thread.&nbsp; All threads within a task share the virtual memory address space and communication rights of that task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The task is the basic unit of protection--all threads within a task have access to all that task's capabilities, and aren't protected from each other.</font>

<p><font face="Times">A traditional UNIX process is represented in Mach as a task with a single thread of execution.&nbsp; One major difference between a UNIX process and a Mach task is that creating a new thread in a task is faster and more conservative of system resources than creating a new UNIX process.&nbsp; Creating a new UNIX process involves making a copy of the parent task's address space, but threads share the address space of their task.</font>

<p><font face="Times">Threads are the basic unit of scheduling.&nbsp; On a multiprocessor host, multiple threads from one task may be executing simultaneously within the task's one address space.&nbsp; A thread may be in a <i>suspended</i> state (prevented from running), or in a <i>runnable</i> state (that is, either currently running or scheduled to run).&nbsp; A nonnegative suspend count is associated with each thread.&nbsp; The suspend count is 0 for runnable threads and positive for suspended threads.</font>

<p><font face="Times">Tasks can be suspended or <i>resumed</i> (made runnable) as a whole.&nbsp; A thread can execute only when both it and its task are runnable.</font>

<p><font face="Times">Multiple threads executing within a single task are useful if several program operations need to execute concurrently while accessing the same data.&nbsp; For example, a word processing application could be designed as multiple threads within a single task. The main thread of execution could provide the basic services of the program:&nbsp; formatting text, processing user requests, and so on.&nbsp; Another thread could check the spelling of each word as it's typed in.&nbsp; A third thread could modify the shape of the cursor based on its position within the text window.&nbsp; Since these threads must have access to the same data and should execute concurrently, Mach's design is particularly advantageous.</font>

<p><font face="Times">In addition, threads are well adapted for use with computers that incorporate a multiprocessor architecture.&nbsp; With some multiprocessor machines, individual threads can execute on separate processors, vastly improving overall application performance.</font>

<p><font face="Times">To create and use threads in an application, you should use the C-thread functions.&nbsp; C threads are described later in this chapter; each C-thread function is described in detail in Chapter 4.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Task and Thread Ports</b></font>

<p><font face="Times">Both tasks and threads are represented by ports.&nbsp; (Ports in Mach are message queues; they're described in the following section.)&nbsp; The task port and the thread port are the arguments used in Mach function calls to identify to the kernel which task or thread is to be affected by the call.&nbsp; The two functions <b>task_self()</b> and <b>thread_self()</b> return the task and thread ports of the currently executing thread.</font>

<p><font face="Times">Tasks can have access to the task and thread ports of other tasks and threads.&nbsp; For example, a task that creates another task or thread gets access to the new task port or thread port.&nbsp; Also, any thread can pass access to these ports in a message to another thread in the same or a different task.</font>

<p><font face="Times">Having access to a task or thread port enables the possessor to perform Mach function calls on behalf of that task or thread. Access to a task's port indirectly permits access to all threads within that task with the <b>task_threads()</b> call; however, access to a thread's port doesn't imply access to its task's port.</font>

<p><font face="Times">The task port and thread port are often called <i>kernel ports</i>.&nbsp; In addition to the kernel ports, tasks and threads have a number of special ports associated with them.&nbsp; These are ports that the kernel must know about to communicate with the task or thread in a structured manner.</font>

<p><font face="Times">A task has three ports associated with it, in addition to its kernel port:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Notify port</i>--The port on which the task receives messages from the kernel advising it of changes in port access rights and of the status of messages it has sent.&nbsp; For example, if a thread is unsuccessful in sending a message to another thread's port, its notify port will contain a status message stating that the port has been intentionally destroyed, that the port's task no longer exists, or that there has been a network failure.&nbsp; The task can get this port's value from the function <b>task_notify()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap></td>

<td><font face="Times">Note that if a task's notify port is PORT_NULL, no notification messages are generated.&nbsp; This port is set to PORT_NULL at task creation, so a task that wants to receive notifications must explicitly set its notify port with the function <b>task_set_special_port()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Exception port</i>--The port on which the task receives messages from the kernel when an exception occurs.&nbsp; <i>Exceptions</i> are synchronous interruptions to the normal flow of program control caused by the program itself.&nbsp; They include illegal memory accesses, protection violations, arithmetic exceptions, and hardware instructions intended to support emulation, debugging, and error detection.&nbsp; Some of these exceptions are handled transparently by the operating system, but some must be reported to the user program.&nbsp; A default exception port is inherited from the parent at task creation time.&nbsp; This port can be changed by the task or any one of its threads in order to take an active role in handling exceptions.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Bootstrap port</i>--The port to which a new task can send a message that will return any other system service ports that the task needs (for example, a port to the Network Name Server).&nbsp; A default bootstrap port is inherited from the parent at task creation.&nbsp; This is the one port that the kernel doesn't actually use; it just makes it available to a new task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A thread has two ports, in addition to its kernel port:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Reply port</i>--Used in Mach remote procedure calls (remote procedure calls are described in Chapter 2).&nbsp; The <b>thread_reply() </b>function returns the reply port of the calling thread.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Exception port</i>--The port to which the kernel sends exceptions occurring in this thread.&nbsp; This port is set to PORT_NULL at thread creation and can be set subsequently with the function <b>thread_set_exception_port()</b>.&nbsp; As long as the thread exception port is PORT_NULL, the task exception port is used instead.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Customarily, only threads within a task manipulate that task's state, but this custom isn't enforced by the Mach kernel.&nbsp; A debugger task, for example, can manipulate the state of the task being debugged by getting the task's kernel port and using it in Mach function calls.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Mach Ports and Messages</b></font>

<p><font face="Times">In Mach, communication among operating system objects is achieved through messages.&nbsp; Mach messaging is implemented by three kernel abstractions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Port</i>--A protected communication channel (implemented as a finite-length message queue) to which messages may be sent and logically queued until reception.&nbsp; The port is also the basic object reference mechanism in Mach; its use is similar to that of object references in an object-oriented system.&nbsp; That is, operations on objects are requested by sending messages to and from the ports that represent them.&nbsp; When a task is created, a port that represents the task is simultaneously created.&nbsp; When the task is destroyed, its port is also destroyed.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Port set</i>--A group of ports, implemented as a queue combining the message queues of the constituent ports.&nbsp; A thread may use a port set to receive a message sent to any of several ports.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Message</i>--Used to communicate between objects; the message is passed to an object by being sent to the port that represents the object.&nbsp; Each message is a data stream consisting of two parts:&nbsp; a fixed-length header and a variable-length message body composed of zero or more typed data objects.&nbsp; The header contains information about the size of the message, its type, and its destination.&nbsp; The body contains the content (or a pointer to the content) of the message.&nbsp; Messages may be of any size, and may contain in-line data, pointers to data, and capabilities for ports.&nbsp; A single message may transfer up to the entire address space of a task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Message passing is the primary means of communication both among tasks and between tasks and the kernel.&nbsp; In fact, the only way one object can communicate with another object is by sending a message to that object's port.&nbsp; System services, for example, are invoked by a thread in one task sending a message to another task that provides the desired service.&nbsp; The only functions implemented by system traps are those directly concerned with message communication; all the rest are implemented by messages to the kernel port of a task.</font>

<p><font face="Times">Threads within a single task also use messages and ports to communicate with each other.&nbsp; For example, one thread can suspend or resume the execution of another thread by sending the appropriate message to the thread's port.&nbsp; A thread can also suspend or resume the execution of all threads within another task by sending the appropriate message to the task's port.</font>

<p><font face="Times">The indirection provided by message passing allows objects to be arbitrarily placed in the network without regard to programming details.&nbsp; For example, a thread can suspend another thread by sending a suspend message to the port representing that other thread even if the request is initiated on another node in a network.&nbsp; It's thus possible to run varying system configurations on different classes of machines while providing a consistent interface to all resources.&nbsp; The actual system running on any particular machine is more a function of its servers than its kernel.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Port Access Rights</b></font>

<p><font face="Times">Communication between objects is protected by a system of <i>port access rights</i>.&nbsp; Access rights to a port consist of the ability to send to or receive from that port.&nbsp; For example, before a task can send a message to a port, it must gain send rights to that port. Before a message can be received, a task must gain receive rights to the port containing the message.</font>

<p><font face="Times">The port access rights operate as follows:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Send access</i> to a port--Implies that a message can be sent to that port.&nbsp; If the port is destroyed during the time a task has send access, the kernel sends a message to that task's notify port indicating that the port has disappeared.&nbsp; For loadable kernel servers, this notification message isn't sent unless the server has requested notification by calling <b>kern_serv_notify()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>Receive access</i> to a port--Allows a message to be dequeued from that port.&nbsp; Only one task may have receive access for a given port at a time; however, more than one thread within that task may concurrently attempt to receive messages from a given port.&nbsp; When the receive rights to a port are destroyed, that port is destroyed and tasks holding send rights are notified. Receive access implies send rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Although multiple tasks may hold send rights to the same port, only one task at a time may hold receive rights to a port.</font>

<p><font face="Times">A thread's right of access is identical to that of the thread's task.&nbsp; Also, when a thread creates a port, send and receive rights are accorded to the task within which the thread is executing.&nbsp; Thus, all threads within the task have equivalent access rights to the new port.&nbsp; Thereafter, any thread within the task can deallocate any or all of these rights, or transfer them to other tasks.&nbsp; The transfer of port rights is accomplished through the Mach messaging system:&nbsp; Access to a port is gained by receiving a message containing a port capability (that is, a capability to either send or receive messages).</font>

<p><font face="Times">Port access rights can be passed in messages.&nbsp; The rights are interpreted by the kernel and transferred from the sender to the kernel upon message transmission and to the receiver upon message reception.&nbsp; Send rights are kept by the original task as well as being transmitted to the receiver task, but receive rights are removed from the original task at the time of the send, and appear in the user task when the receive is done.</font>

<p><font face="Times">During the time between a send and receive, the kernel holds the rights, and any messages sent to the port will be queued waiting for a new task to receive on the port.&nbsp; If the task that was intended to receive the rights dies before it receives them, the rights are handled as though the task had received them before it died.</font>

<p><font face="Times">The type usually used for ports is <b>port_t</b>.&nbsp; However, ports can also be referred to as the equivalent types <b>port_name_t</b> and <b>port_all_t</b>.&nbsp; The <b>port_name_t</b> type implies that no port access rights are being transferred; the port is merely being referred to by its name.&nbsp; The <b>port_all_t</b> type implies that all rights (both send and receive) for a port are being transferred.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Port Sets</b></font>

<p><font face="Times">Conceptually, a port set is a bag holding zero or more receive rights.&nbsp; A port set allows a thread to block while waiting for a message sent to any of several ports.&nbsp; A port may be a member of no more than one port set at any time, and a task can have only one port set.</font>

<p><font face="Times">A task's port set right, created by <b>port_set_allocate()</b>, allows the task to receive a message from the port set with <b>msg_receive()</b> and manipulate the port set with <b>port_set_add()</b>, <b>port_set_remove()</b>, <b>port_set_status()</b>, and <b>port_set_deallocate()</b>.&nbsp; Unlike port rights, a port set right can't be passed in messages.</font>

<p><font face="Times">Port set rights usually have the type <b>port_set_name_t</b>, which is equivalent to <b>port_name_t</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Port Names</b></font>

<p><font face="Times">Every task has its own port name space, used for port and port set names.&nbsp; For example, one task with receive rights for a port may know the port by the name 13, while another task with send rights for the same port may know it by the name 17.&nbsp; A task has only one name for a port, so if the task with send rights named 17 receives another message carrying send rights for the same port, the arriving rights will also be named 17.</font>

<p><font face="Times">Typically, these names are small integers, but this is implementation dependent.&nbsp; When a task receives a message carrying rights for a new port, the Mach kernel is free to choose any unused name.&nbsp; The <b>port_rename()</b> call can be used to change a task's name for a port.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Port Queues</b></font>

<p><font face="Times">Messages that are sent to a port are held there until removed by a thread.&nbsp; The queue associated with a port is of finite length and may become full.&nbsp; If an attempt is made to send a message to a port that's temporarily full, the sending thread has a choice of three alternatives:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">By default, the sender is suspended until it can successfully transmit the message.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The sender can have the kernel hold the message for later transmission to the currently full port.&nbsp; If the sender selects this action, it can't transmit further messages to the port (nor can it have the kernel hold additional messages for the port) until the kernel notifies it that the port has received the initial message.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The attempt to send a message to a full port can simply be reported to the sender as an error.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Extended Communication Functionality</b></font>

<p><font face="Times">The kernel's message-based communication facility is the building block on which more complicated facilities may be constructed; for example, it's the underlying communication mechanism for the Mach exception-handling facility.&nbsp; Two properties of the Mach communication facility simplify the process of extending the functionality of systems based on it:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Independence--A port is an independent entity from the tasks that use it to communicate.&nbsp; Port rights can be exchanged in messages, and are tracked by the kernel to maintain protection.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Network transparency--As described in the following section, user-level network message servers transparently extend the Mach communication facility across a network, allowing messages to be sent between tasks on different computers.&nbsp; The forwarding process is invisible to both the sender and the receiver of the message.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This combination of independence and network transparency enables Mach to support parallel and distributed architectures with no change to the operating system kernel.&nbsp; These properties of the communication facility also simplify the incorporation of new operating system functionality, because user-level programs can easily be added to the existing kernel without the need to modify the underlying kernel base.</font>

<p><font face="Times">Although messaging is similar to UNIX 4.3BSD stream sockets in that it permits reliable, kernel-mediated communication between tasks, messaging has a much more fundamental role within Mach.&nbsp; Whereas UNIX processes obtain system services through a variety of interfaces (for example, the <b>open()</b> system call for files, the <b>socket()</b> and <b>bind()</b> system calls for network connections, and numerous access protocols for user-level services), Mach provides all services through messaging.&nbsp; Because of this consistency of interprocess communication, the Mach operating system can easily be extended to incorporate new features.</font>

<p><font face="Times">As an alternative to messaging, Mach also supports interprocess communication using shared memory.&nbsp; However, if you use shared memory for interprocess communication, you're responsible for synchronizing the transmission and reception of the message.&nbsp; With the Mach messaging system, Mach itself schedules the transmission and reception of messages, thereby ensuring that no message is read before it's been sent in its entirety.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Messaging in a Network Environment</b></font>

<p><font face="Times">Mach's object-oriented design is well-suited for network operation.&nbsp; Messages may be sent between tasks on different computers just as they're sent between tasks on the same computer.&nbsp; The only difference is the transparent intervention of a new user-level object, the <i>network server</i>.</font>

<p><font face="Times">Programs called network servers act as intermediaries for messages sent between tasks on separate computers.&nbsp; Each network server implements <i>network ports</i> that represent ports for tasks on remote nodes.&nbsp; A unique <i>network port identifier</i> is used to distinguish each network port.</font>

<p><font face="Times">A message addressed to a remote port is first received at the local network port that represents the remote port.&nbsp; The network server, upon receiving the message, translates it into a form compatible with the network protocol and then transmits the message to the counterpart network server on the destination node.&nbsp; The destination server decodes the message, and determines its ultimate destination from the network port identifier in the message.&nbsp; Finally, the destination network server dispatches the message to the local port to which it was addressed.</font>

<p><font face="Times">This network messaging process is transparent to the sender; all routing services are provided by the network server.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Mach Virtual Memory Management</b></font>

<p><font face="Times">Each Mach task receives a 4-gigabyte virtual address space for its threads to execute in.&nbsp; This address space consists of a series of mappings between ranges of memory addressable to the task and memory objects.&nbsp; Besides accommodating the task and its threads, this space serves as the basis of the Mach messaging system and allows space for memory-mapped files.</font>

<p><font face="Times">A task can modify its address space in several ways.&nbsp; It can:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Allocate a region of virtual memory (on a page boundary).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Deallocate a region of virtual memory.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Set the protection status of a region of virtual memory.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Specify the inheritance of a region of virtual memory.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Create and manage a memory object that can then be mapped into the space of another task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The only restriction imposed by Mach on the nature of the regions that may be specified for virtual memory operations is that they must be aligned on system page boundaries.&nbsp; The size in bytes of a virtual memory page is contained in the <b>vm_page_size </b>variable.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Demand Paging</b></font>

<p><font face="Times">A NeXT computer's memory management hardware is responsible for mapping sections of the virtual memory space into pages of physical memory as needed.&nbsp; The process it uses to decide which virtual pages map to which physical pages is known as <i>demand paging</i>.</font>

<p><font face="Times">While a task is executing, only the page of memory containing the addresses referenced by the active thread must reside in physical memory.&nbsp; If the thread references an address not contained in a page of physical memory, the kernel requests the appropriate pager to read in the needed page from storage.&nbsp; Then, a NeXT computer's memory management unit maps the referenced virtual page onto this new physical page of memory.</font>

<p><font face="Times">If there are no further free pages of physical memory available, the Mach kernel makes room by requesting the pager to copy the least recently used page to the paging file on the disk.&nbsp; The kernel then reassigns the newly freed page of memory.</font>

<p><font face="Times">Mach's paged virtual address space makes it possible to run extremely large applications on a NeXT computer.&nbsp; With all but the largest applications, you can continue to allocate memory without concern for exceeding the system's capacity, although to prevent unnecessary performance degradation, you should deallocate memory that's no longer needed.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Inheritance and Protection of Memory</b></font>

<p><font face="Times">The Mach virtual memory management system also streamlines the creation of a new task (the child) from an existing task (the parent), an operation similar to forking a UNIX process.&nbsp; Traditionally, under the UNIX operating system, creating a new process entails creating a copy of the parent's address space.&nbsp; This is an inefficient operation since often the child task, during its existence, touches only a portion of its copy of the parent's address space.&nbsp; Under Mach, the child task initially shares the parent's address space and copying occurs only when needed, on a page-by-page basis.</font>

<p><font face="Times">A region of an address space represents the memory associated with a continuous range of addresses, marked by a starting address and an ending address.&nbsp; Regions consist of pages that have different protection or inheritance characteristics.&nbsp; The Mach kernel extends each region to include the entire virtual memory pages that contain the starting and ending addresses in the specified range.</font>

<p><font face="Times">Inheritance and protection are attached to a task's address space, not the physical memory contained in that address space. Tasks that share memory may specify different protection or inheritance for their shared regions.</font>

<p><br><br>

<p><font face="Helvetica"><b>Inheritance</b></font>

<p><font face="Times">A task may specify that pages of its address space be inherited by child tasks in three ways:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Copy--Pages marked as copy are logically copied by value, although for efficiency copy-on-write techniques are used.&nbsp; This means the first time the child task attempts to write to shared memory, a protection fault occurs.&nbsp; The kernel responds to this fault by making a copy, for the child task, of the page being written.&nbsp; This is the default mode of inheritance if no mode is specified.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Shared--Pages specified as shared can be read from and written to by both the parent and child.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">None--Pages marked as none aren't passed to a child.&nbsp; In this case, the child's corresponding address is left unallocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Inheritance may be specified globally or on a page-by-page basis when a task is forked.&nbsp; Inheritance may be changed at any time; only at the time of task creation is inheritance information used.</font>

<p><font face="Times">Copy-on-write sharing between unrelated tasks is typically the result of large message transfers.&nbsp; An entire address space may be sent in a single message with no actual data copy operations performed.</font>

<p><font face="Times">Currently the only way two Mach tasks can share the same physical memory is for one of the tasks to inherit shared access to memory from a parent.</font>

<p><br><br>

<p><font face="Helvetica"><b>Protection</b></font>

<p><font face="Times">Besides specifying page inheritance attributes, a task may assign protection values to protect the virtual pages of its address space by allowing or preventing access to that memory.&nbsp; Protection values are a combination of read, write, and execute permissions.</font>

<p><font face="Times">By default, when a child task inherits memory from a parent, it gets the same protection on that memory that its parent had.</font>

<p><font face="Times">Like inheritance, protection is specified on a per-page basis.&nbsp; For each group of pages there exist two protection values:&nbsp; the current and the maximum protection.&nbsp; The current protection is used to determine the access rights of an executing thread, and the maximum protection specifies the maximum value that the current protection may take.&nbsp; The maximum value may be lowered but not raised.&nbsp; If the maximum protection is lowered to a level below the current protection, the current protection is also lowered to that level.</font>

<p><font face="Times">For example, a parent task may create a child task and set the maximum protection value for some pages of memory to read-only.&nbsp; Thereafter, the parent task can be assured that the child won't be able to alter the information in those pages.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Interprocess Communication</b></font>

<p><font face="Times">Mach virtual memory management provides an efficient method of interprocess communication.&nbsp; Messages of any size (up to the limits imposed by the virtual address space) can be transferred between tasks by revising the mapping from the virtual address space of a process to physical address space.&nbsp; This is accomplished by mapping an unused portion of the virtual address space of the receiving process onto the addresses of the sender's message.</font>

<p><font face="Times">The efficiency of this method can be appreciated more fully when compared to the standard UNIX method.&nbsp; Under the UNIX operating system, a message must be physically copied from the address space of the sender into the address space of the kernel.&nbsp; From there, the message is copied into the address space of the receiver.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Memory-Mapped Files</b></font>

<p><font face="Times">Memory-mapped files are a further benefit of the Mach virtual memory system.&nbsp; Under Mach, all or part of a disk file can be mapped onto a section of virtual memory.&nbsp; A reference to a position within this section is equivalent to a reference to the same position in the physical file.&nbsp; If that portion of the file isn't currently in memory, a page fault occurs, prompting the kernel to request the file system to read the needed section of the file into physical memory.&nbsp; From the point of view of the process, the entire file is in memory at once.</font>

<p><font face="Times">With Mach, the use of memory-mapped files is optional and currently only supports reading files.&nbsp; Mach also supports the standard UNIX <b>read()</b>, <b>lseek()</b>, and <b>write()</b> system calls.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Paging Objects</b></font>

<p><font face="Times">A <i>paging object</i> is a secondary storage object that's mapped into a task's virtual memory.&nbsp; Paging objects are commonly files managed by a file server, but as far as the Mach kernel is concerned, a paging object may be implemented by any port that can handle requests to read and write data.</font>

<p><font face="Times">Physical pages in an address space have paging objects associated with them.&nbsp; These objects identify the backing storage to be used when a page is to be read in as the result of a reference or written to in order to free physical memory.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Virtual Memory Functions</b></font>

<p><font face="Times">The Mach kernel provides a set of functions to allow a programmer to manipulate the virtual address space of a task.&nbsp; The two most fundamental ones are <b>vm_allocate()</b> to get new virtual memory and <b>vm_deallocate()</b> to free virtual memory.&nbsp; The programmer also has available the UNIX functions <b>malloc()</b>, <b>calloc()</b>, and <b>free()</b>, which have been reimplemented to use <b>vm_allocate()</b> and <b>vm_deallocate()</b>.</font>

<p><font face="Times">In addition to memory explicitly allocated using <b>vm_allocate()</b>, memory may appear in a task's address space as the result of a <b>msg_receive()</b> operation.</font>

<p><font face="Times">The decision to use one allocation method rather than another should be based on several factors.&nbsp; The <b>vm_allocate()</b> function always adds new, zero-filled virtual memory in page-aligned chunks that are multiples of the page size.&nbsp; The <b>malloc()</b> function allocates approximately the size asked for (plus a few bytes) out of a preallocated heap. The <b>calloc()</b> function is the same as <b>malloc()</b> except that it zeros the memory before returning it.&nbsp; Both <b>malloc()</b> and <b>calloc()</b> are library subroutine calls; <b>vm_allocate()</b> is a Mach kernel function, which is somewhat more expensive.</font>

<p><font face="Times">The most obvious basis on which to choose an allocation function is the size of the desired space.&nbsp; One other consideration is the desirability of page-aligned storage.&nbsp; If the memory that's allocated is to be passed <i>out-of-line</i> in a message (referred to by a pointer in the message), it's more efficient if it's page-aligned.</font>

<p><font face="Times">Note that it's essential that the correct deallocation function be used.&nbsp; If memory has been allocated with <b>vm_allocate()</b>, it must be deallocated with <b>vm_deallocate()</b>; if it was allocated with <b>malloc()</b> it must be deallocated with <b>free()</b>.&nbsp; Memory that's received out-of-line from a message has been allocated by the kernel with <b>vm_allocate()</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Program Examples:&nbsp; Virtual Memory</b></font>

<p><font face="Times">The following three examples demonstrate various aspects of the use of virtual memory functions in C programs.</font>

<p><font face="Times">The first program, <b>vm_read.c</b>, demonstrates the use of <b>vm_allocate()</b>, <b>vm_deallocate()</b>, and another virtual memory function called <b>vm_read()</b>.&nbsp; First some memory is allocated and filled with data.&nbsp; The <b>vm_read()</b> Mach function is then called, with reading starting at the previously allocated chunk.&nbsp; The contents of the two pieces of memory (that is, the one retrieved by <b>vm_allocate()</b> and the one by <b>vm_read()</b>) are compared.&nbsp; The <b>vm_deallocate()</b> function is then used to get rid of the two chunks of memory.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/mach.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;stdio.h&gt;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main(int argc, char *argv[])</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data1, *temp;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data2;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, min;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">unsigned int&nbsp; data_cnt;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">kern_return_t rtn;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (argc &gt; 1) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_read takes no switches.&nbsp; &#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;This program is an example vm_read\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_allocate(task_self(), (vm_address_t *)&amp;data1,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">temp = data1;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (i = 0; (i &lt; vm_page_size); i++)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">temp[i] = i;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Filled space allocated with some data.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Doing vm_read....\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_read(task_self(), (vm_address_t)data1,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size, (pointer_t *)&amp;data2, &amp;data_cnt))</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">!= KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_read failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Successful vm_read.\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (vm_page_size != data_cnt) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vmread: Number of bytes read not equal to number&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;available and requested.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">min = (vm_page_size &lt; data_cnt) ? vm_page_size : data_cnt;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (i = 0; (i &lt; min); i++) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if (data1[i] != data2[i]) {</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">printf(&#34;vmread: Data not read correctly.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Checked data successfully.\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_deallocate(task_self(), (vm_address_t)data1,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_deallocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_deallocate(task_self(), (vm_address_t)data2,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">data_cnt)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_deallocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The next program, <b>vm_copy.c</b>, demonstrates the use of <b>vm_allocate()</b>, <b>vm_deallocate()</b>, and <b>vm_copy()</b>.&nbsp; First, some memory is allocated and filled with data.&nbsp; Then another chunk of memory is allocated, and <b>vm_copy()</b> is called to copy the contents of the first chunk to the second.&nbsp; The data in the two spaces is compared to be sure it's the same, checking <b>vm_copy()</b>.&nbsp; The <b>vm_deallocate()</b> function is then used to get rid of the two chunks of memory.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/mach.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;stdio.h&gt;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main(int argc, char *argv[])</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data1, *data2, *temp;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp; rtn;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (argc &gt; 1) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_copy takes no switches.&nbsp;&nbsp;&nbsp; &#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;This program is an example vm_copy\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_allocate(task_self(), (vm_address_t *)&amp;data1,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">temp = data1;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (i = 0; (i &lt; vm_page_size / sizeof(int)); i++)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">temp[i] = i;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: set data\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_allocate(task_self(), (vm_address_t *)&amp;data2,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_copy(task_self(), (vm_address_t)data1, vm_page_size,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">(vm_address_t)data2)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_copy failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: copied data\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (i = 0; (i &lt; vm_page_size / sizeof(int)); i++) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if (data1[i] != data2[i]) {</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Data not copied correctly.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Successful vm_copy.\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_deallocate(task_self(), (vm_address_t)data1,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_deallocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((rtn = vm_deallocate(task_self(), (vm_address_t)data2,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">vm_page_size)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_deallocate failed&#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Finished successfully!\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The following program, <b>copy_on_write.c</b>, demonstrates the use of <b>vm_inherit()</b> and copy-on-write memory.&nbsp; A child and parent task share memory, polling this memory to see whose turn it is to proceed.</font>

<p><font face="Times">First, some memory is allocated, and <b>vm_inherit()</b> is called on this memory, the variable <b>lock</b>.&nbsp; Then more memory is allocated for the copy-on-write test.&nbsp; A fork is executed, and the parent then stores new data in the copy-on-write memory previously allocated, and sets the shared variable signaling to the child that the parent is now waiting.&nbsp; The child, polling the shared variable, sees that the parent is waiting.&nbsp; The child prints the value of the variable <b>lock</b> and a value of the copy-on-write memory as the child sees it.&nbsp; The value of <b>lock</b> is what the parent set it to be, but the value of the copy-on-write memory is the original value and not what the parent changed it to be.&nbsp; The parent then awakens and prints out the two values once more.&nbsp; The program then ends with the parent signaling the child using the shared variable <b>lock</b>.</font>

<p><font face="Times">Typically you wouldn't do this synchronization directly as shown here, but would use C-thread functions (described later in this chapter).</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/mach.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;stdio.h&gt;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define NO_ONE_WAIT 0</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define PARENT_WAIT 1</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define CHILD_WAIT 2</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define COPY_ON_WRITE 0</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define PARENT_CHANGED 1</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define CHILD_CHANGED 2</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#define MAXDATA 100</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main(int argc, char *argv[])</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pid;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *mem;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *lock;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">kern_return_t ret;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (argc &gt; 1) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;cowtest takes no switches.&nbsp;&nbsp;&nbsp; &#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;This is an example of copy-on-write \n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;memory and the use of vm_inherit.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((ret = vm_allocate(task_self(), (vm_address_t *)&amp;lock,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">sizeof(int), TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate failed:&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((ret = vm_inherit(task_self(), (vm_address_t)lock,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">sizeof(int), VM_INHERIT_SHARE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_inherit failed:&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">*lock = NO_ONE_WAIT;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((ret = vm_allocate(task_self(), (vm_address_t *)&amp;mem,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">sizeof(int) * MAXDATA, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate failed:&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mem[0] = COPY_ON_WRITE;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;value of lock before fork: %d\n&#34;, *lock);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">pid = fork();</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (pid) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: copied memory = %d\n&#34;, mem[0]);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: changing to %d\n&#34;, PARENT_CHANGED);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mem[0] = PARENT_CHANGED;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: lock = %d\n&#34;, *lock);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: changing lock to %d\n&#34;, PARENT_WAIT);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">*lock = PARENT_WAIT;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">while (*lock == PARENT_WAIT)</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">/* wait for child to change the value */ ;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: copied memory = %d\n&#34;, mem[0]);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: lock = %d\n&#34;, *lock);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;PARENT: Finished.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">*lock = PARENT_WAIT;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while (*lock != PARENT_WAIT)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* wait for parent to change lock */ ;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;CHILD: copied memory = %d\n&#34;, mem[0]);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;CHILD: changing to %d\n&#34;, CHILD_CHANGED);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mem[0] = CHILD_CHANGED;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;CHILD: lock = %d\n&#34;, *lock);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;CHILD: changing lock to %d\n&#34;, CHILD_WAIT);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">*lock = CHILD_WAIT;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while (*lock == CHILD_WAIT)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* wait for parent to change lock */ ;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((ret = vm_deallocate(task_self(), (vm_address_t)lock,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">sizeof(int))) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_deallocate failed:&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((ret = vm_deallocate(task_self(), (vm_address_t)mem,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">MAXDATA * sizeof(char))) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;vm_deallocate failed:&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;CHILD: Finished.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Mach Scheduling</b></font>

<p><font face="Times">Each thread has a scheduling <i>priority</i> and <i>policy</i>.&nbsp; The priority is a number between 0 and 31 that indicates how likely the thread is to run.&nbsp; The higher the priority, the more likely the thread is to run.&nbsp; For example, a thread with priority 16 is more likely to run than a thread with priority 10.&nbsp; The policy is by default a timesharing policy, which means that whenever the running thread blocks or a certain amount of time passes, the highest-priority runnable thread is executed.&nbsp; Under the timesharing policy, a thread's priority gets lower as it runs (it <i>ages</i>), so that not even a high-priority thread can keep a low-priority thread from eventually running.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Priorities</b></font>

<p><font face="Times">Each thread has three types of priorities associated with it:&nbsp; its base priority, its current priority, and its maximum priority.&nbsp; The base priority is the one the thread starts with; it can be explicitly set using a function such as <b>cthread_priority()</b>.&nbsp; The current priority is the one at which the thread is executing; it may be lower than the base priority due to aging or a call to <b>thread_switch()</b>.&nbsp; The maximum priority is the highest priority at which the thread can execute.&nbsp; When a thread starts, it inherits its base priority from its parent task and its maximum priority is set to a system-defined maximum.</font>

<p><font face="Times">These priorities can be set at three levels:&nbsp; the thread, the task, and (on multiprocessors) the processor set.&nbsp; At the thread level, you can use <b>cthread_priority()</b> or <b>thread_priority()</b> to set the base priority and to optionally lower the maximum priority.&nbsp; You can raise or lower just the maximum priority using <b>cthread_max_priority()</b> or <b>thread_max_priority()</b>.&nbsp; To raise a thread's maximum priority, you must obtain the privileged port of the thread's processor set, which only the superuser can do.</font>

<p><font face="Times">At the task level, you can set the task's base priority using <b>task_priority()</b>.&nbsp; The task's base priority is inherited by all threads that it forks; you can also specify that all existing threads in the task get the new base priority.</font>

<p><font face="Times">You can get the priorities of running tasks using <b>task_info()</b> and <b>thread_info()</b>.&nbsp; Or, from a shell window, you can view the priorities of running tasks using the UNIX command <b>ps</b>.&nbsp; The <b>-l</b> option of <b>ps</b> displays, among other things, the lowest values for maximum priority and current priority that were found in all the threads in the task.&nbsp; The <b>-m</b> option displays the current priority of every thread in the task.&nbsp; The following example shows the <b>ps</b> displays for Terminal.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">localhost&gt; <b>ps -axu | grep Terminal</b></font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1658&nbsp;&nbsp; 2.8&nbsp; 2.4 1.31M&nbsp; 200K p2 S&nbsp;&nbsp;&nbsp;&nbsp; 0:00 grep Terminal</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 174&nbsp;&nbsp; 2.4 11.4 3.84M&nbsp; 936K p1 S&nbsp;&nbsp;&nbsp;&nbsp; 0:41 /NextApps/Terminal.app/T</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">localhost&gt; <b>ps -l 174</b></font><br>
<img src="../../../Images/sp.gif" width=147 height=1><font face="Courier" size="-1">F&nbsp; UID&nbsp;&nbsp; PID&nbsp; PPID CP PRI BASE VSIZE RSIZE WCHAN STAT TT&nbsp; TIME COMMAND</font><br>
<img src="../../../Images/sp.gif" width=147 height=1><font face="Courier" size="-1">1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 174&nbsp;&nbsp; 156&nbsp; 0&nbsp; 10&nbsp;&nbsp; 10 4.30M 1.14K&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; S&nbsp;&nbsp;&nbsp; ?&nbsp; 0:41 /NextAp</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">localhost&gt; <b>ps -m 174</b></font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PID TT&nbsp; %CPU STAT PRI&nbsp;&nbsp;&nbsp; SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USER&nbsp; COMMAND</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 174&nbsp; ?&nbsp;&nbsp; 1.8&nbsp; S&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 0:15.76&nbsp;&nbsp; 0:19.17&nbsp; /NextApps/Terminal.app/</font><br>
<img src="../../../Images/sp.gif" width=238 height=1><font face="Courier" size="-1">0.1&nbsp; S&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp; 0:06.15&nbsp;&nbsp; 0:00.54</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Policies</b></font>

<p><font face="Times">The NeXT Mach operating system has three scheduling policies:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Timesharing</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Interactive</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Fixed priority</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Every thread starts with the timesharing policy, no matter what policy the creator of the thread has.&nbsp; If you want the policy of any thread to be something other than timesharing, you must set that thread's policy using <b>thread_policy()</b>.</font>

<p><font face="Times">The interactive policy is a variant of timesharing that's designed to be optimized for interactive applications.&nbsp; If you have a non-NEXTSTEP application, such as a terminal-oriented editor, you should set the main thread's policy to interactive using <b>thread_policy()</b>.&nbsp; (The Application Kit automatically sets up the first thread in an application to have an interactive policy.) Currently, the interactive policy is exactly the same as timesharing, but in the future performance might be enhanced by, for example, making interactive policy threads have higher priorities than the other threads in the task.</font>

<p><font face="Times">Fixed priority can be a dangerous policy if you aren't familiar with all of its consequences.&nbsp; For this reason, the fixed-priority policy is disabled by default.&nbsp; If you want to use fixed priorities, you must enable them using <b>processor_set_policy_enable()</b>. Threads that have the fixed-priority policy have their current priority always equal to their base priority (unless their priority is depressed by <b>thread_switch()</b>).&nbsp; A thread with the fixed-priority policy runs until one of the following happens:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A higher-priority process becomes available to run.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A per-thread, user-specified amount of time (the <i>quantum</i>) passes.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The thread blocks, waiting for some event or system resource.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Because fixed-priority threads don't lose priority over time, they can prevent lower-priority threads from running.&nbsp; The opposite can happen, too; a low-priority, fixed-priority thread can be kept from running for enough time by higher-priority threads.&nbsp; The first problem can be solved in some cases by the fixed-priority thread calling <b>thread_switch()</b> to temporarily depress its priority or hand off the processor to another thread.&nbsp; The fixed-priority policy is often used for real-time problems, such as on-line transaction processing.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+2"><b>Mach C-Thread Functions</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Mach provides a set of low-level, language-independent functions for manipulating threads of control.&nbsp; The C-thread functions are higher-level, C language functions in a run-time library that provide an interface to the Mach facilities.&nbsp; The constructs provided in the C-thread functions are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Forking and joining of threads</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Protection of critical regions with mutual exclusion (mutex) variables</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Condition variables for synchronization of threads</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Another way of protecting critical regions and synchronizing threads is to use the Mach Kit's locking classes.&nbsp; The Mach Kit provides an object-oriented interface to a few limited areas of Mach functionality.&nbsp; See the <i>NEXTSTEP General Reference</i> for information on the Mach Kit.</font>

<p><font face="Times">If you intend to build multithreaded applications, you should use the C-thread functions rather than the Mach kernel functions. The C-thread functions are a natural and efficient set of functions for multithreaded applications, whereas the Mach thread functions are designed to provide the low-level mechanisms that packages such as the C-thread functions can be built with.&nbsp; An on-line example of a multithreaded NEXTSTEP application is under the directory <b>/NextDeveloper/Examples/AppKit/SortingInAction</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Using External Functions and Methods</b></font>

<p><font face="Times">Many of the functions and methods provided by NEXTSTEP weren't designed with multithreaded applications in mind.&nbsp; As a result, they might not work correctly when called simultaneously by two or more of your application's threads.&nbsp; (A function or method that can safely be called by more than one thread at once is <i>thread-safe</i>.)&nbsp; In general, unless you know that a function or method is thread-safe, you should assume that it isn't.</font>

<p><font face="Times">The following are thread-safe:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Distributed Objects, which is described in the <i>General Reference</i></font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Mach functions (except for <b>mach_error()</b>)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">UNIX system calls (you should use <b>cthread_errno()</b> instead of <b>errno</b>)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">NEXTSTEP exception handling (for example, <b>NX_RAISE()</b>)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The <b>malloc()</b> function and its related functions, though their thread safety can be disabled by calling <b>malloc_singlethreaded()</b> (which in general should not be done)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The Objective C runtime system is not thread-safe by default.&nbsp; To make it thread-safe, use the function <b>objc_setMultithreaded()</b>.</font>

<p><font face="Times">The following are <i>not</i> thread-safe:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Application Kit (messages to kit objects should be sent only from the main thread)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">DPS client routines</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The Window Server (drawing should be done only from the main thread)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Standard I/O functions, such as <b>printf()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Most of the functions in the libc library</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">In particular, the <b>usleep()</b> function should never be used in multithreaded programs.&nbsp; As an alternative, you can use the <b>thread_switch()</b> Mach function, as follows:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">thread_switch(THREAD_NULL, SWITCH_OPTION_WAIT, msecs);</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Using Shared Variables</b></font>

<p><font face="Times">All global and static variables are shared among all threads:&nbsp; If one thread modifies such a variable, all other threads will observe the new value.&nbsp; In addition, a variable reachable from a pointer is shared among all threads that can dereference that pointer.&nbsp; This includes objects pointed to by shared variables of pointer type, as well as arguments passed by reference in <b>cthread_fork()</b>.&nbsp; You should be careful to declare all shared variables as <b>volatile</b>, or the optimizer might remove references to them.</font>

<p><font face="Times">When pointers are shared, some care is required to avoid problems with dangling references.&nbsp; You must ensure that the lifetime of the object pointed to is long enough to allow the other threads to dereference the pointer.&nbsp; Since there's no bound on the relative execution speed of threads, the simplest solution is to share pointers to global or heap-allocated objects only.&nbsp; If a pointer to a local variable is shared, the function that variable is defined in must remain active until it can be guaranteed that the pointer will no longer be dereferenced by other threads.&nbsp; The synchronization functions can be used to ensure this.</font>

<p><font face="Times">Unless a library has been designed to work in the presence of reentrancy, you should assume that the library makes unprotected use of shared data.&nbsp; You must protect against this through the use of a mutex that's locked before every library call (or sequence of library calls) and unlocked afterward.&nbsp; For example, you should lock a mutex before calling <b>printf()</b> and unlock the mutex afterward.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Synchronization of Variables</b></font>

<p><font face="Times">This section describes mutual exclusion and synchronization functions, which are used to constrain the possible interleavings of the execution streams of threads.&nbsp; These functions manipulate <i>mutex</i> and <i>condition</i> variables, which are defined as follows:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct mutex {...} *mutex_t;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct condition {...} *condition_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Mutually exclusive access to mutable data is necessary to prevent corruption of data.&nbsp; As a simple example, consider concurrent attempts to update a simple counter.&nbsp; If two threads fetch the current value into a (thread-local) register, increment, and write the value back in some order, the counter will only be incremented once, losing one thread's operation.&nbsp; A mutex solves this problem by making the fetch-increment-deposit action atomic.&nbsp; Before fetching a counter, a thread locks the associated mutex, and after depositing a new value the thread unlocks the mutex:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_lock(m);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">count += 1;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_unlock(m);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If any other thread tries to use the counter in the meantime, it will block when it tries to lock the mutex.&nbsp; If more than one thread tries to lock the mutex at the same time, only one will succeed; the rest will block.</font>

<p><font face="Times">Condition variables are used when one thread wants to wait until another thread has finished doing something.&nbsp; Every condition variable should be protected by a mutex.&nbsp; Conceptually, the condition is a boolean function of the shared data that the mutex protects.&nbsp; Commonly, a thread locks the mutex and inspects the shared data.&nbsp; If it doesn't like what it finds, it waits, using a condition variable:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_lock(mutex_t m);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">while ( /* condition isn't true */ )</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">condition_wait(condition_t c, mutex_t m);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">. . .</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_unlock(mutex_t m);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The call to <b>condition_wait()</b> temporarily unlocks the mutex to give other threads a chance to get in and modify the shared data. Eventually, one of them should signal the condition (which wakes up the blocked thread) before it unlocks the mutex:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_lock(mutex_t m);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">. . .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* modify shared data */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">condition_signal(condition_t c);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_unlock(mutex_t m);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">At that point, the original thread will regain its lock and can look at the shared data to see if things have improved.&nbsp; It can't assume that it will like what it sees, because some other thread may have slipped in and altered the data after the condition was signaled.</font>

<p><font face="Times">You must take special care with data structures that are dynamically allocated and deallocated.&nbsp; In particular, if the mutex that's controlling access to a dynamically allocated record is part of the record, make sure that no thread is waiting for the mutex before freeing the record.</font>

<p><font face="Times">Attempting to lock a mutex that one already holds is another common error.&nbsp; The offending thread will block waiting for itself. This can happen when a thread is traversing a complicated data structure, locking as it goes, and reaches the same data by different paths.&nbsp; Another instance of this is when a thread is locking elements in an array, say to swap them, and it doesn't check for the special case that the elements are the same.</font>

<p><font face="Times">You must be careful to avoid deadlock, a condition in which one or more threads are permanently blocked waiting for each other.&nbsp; The above scenarios are a special case of deadlock.&nbsp; The easiest way to avoid deadlock with mutexes is to impose a total ordering on the mutexes, and then ensure that threads only lock mutexes in increasing order.</font>

<p><font face="Times">You must decide what kind of granularity to use in protecting shared data with mutexes.&nbsp; The two extremes are to have one mutex protecting all shared memory, or to have one mutex for every byte of shared memory.&nbsp; Finer granularity normally increases the possible parallelism because less data is locked at any one time.&nbsp; However, it also increases the overhead lost to locking and unlocking mutexes and increases the possibility of deadlock.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Program Example:&nbsp; C Threads</b></font>

<p><font face="Times">This section demonstrates the use of the C-thread functions in writing a multithreaded program.&nbsp; The program is an example of how to structure a program with a single master thread that spawns a number of concurrent slaves.&nbsp; The master thread waits until all the slaves have finished and then exits.</font>

<p><font face="Times">Once created, a slave thread simply loops calling a function that makes the processor available to other threads.&nbsp; After this loop is finished, the slave thread informs the master that it's done, and then dies.&nbsp; In a more useful version of this program, each slave process would do something while looping.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;stdio.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/cthreads.h&gt;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">volatile int count;&nbsp;&nbsp;&nbsp; /* number of slave threads active */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock;&nbsp;&nbsp;&nbsp;&nbsp; /* mutual exclusion for count */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print;&nbsp;&nbsp;&nbsp; /* mutual exclusion for printfs */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">condition_t&nbsp; done;&nbsp;&nbsp;&nbsp;&nbsp; /* signaled each time a slave finishes */</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void init()</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Allocate mutex variables &#34;lock&#34; and &#34;print&#34;. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">lock = mutex_alloc();</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">print = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Allocate condition variable &#34;done&#34;. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">done = condition_alloc();</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">count = 0;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* Each slave just loops, yielding the processor on each</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* iteration.&nbsp; When it's finished, it decrements the global</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* count and signals that it's done.</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void slave(int n)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int i;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (i = 0; i &lt; 100; i += 1)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">cthread_yield();</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* If any thread wants to access the count variable, it</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* first locks the mutex.&nbsp; When the mutex is locked, any</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* other thread wanting the count variable must wait until</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* the mutex is unlocked.</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_lock(lock);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">count -= 1;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_lock(print);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Slave %d finished.\n&#34;, n);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_unlock(print);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Signal that this slave has finished. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">condition_signal(done);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_unlock(lock);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* The master spawns a given number of slaves and then waits</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* for them all to finish.</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void master(int nslaves)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int i;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (i = 1; i &lt;= nslaves; i++) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_lock(lock);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Increment count with the creation of each slave thread.&nbsp; */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">count += 1;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Fork a slave and detach it.&nbsp; */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)slave, (any_t)i));</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_unlock(lock);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_lock(lock);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* Master thread loops waiting on the condition done.&nbsp; Each</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* time the master thread is signaled by a condition_signal</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">* call, it tests the count for a value of zero.</font><br>
<img src="../../../Images/sp.gif" width=159 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while (count != 0)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">condition_wait(done, lock);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_unlock(lock);</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_lock(print);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;All %d slaves have finished.\n&#34;, nslaves);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mutex_unlock(print);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">init();</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">master(15);&nbsp; /* Create master thread and 15 slaves. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+2"><b>Mach Exception Handling</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Exceptions are synchronous interruptions to the normal flow of program control caused by the occurrence of unusual conditions during program execution.&nbsp; Raising an exception causes the operating system to manage recovery from the unusual condition.</font>

<p><font face="Times">Exceptions include:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Illegal accesses (bus errors, segmentation and protection violations)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Arithmetic errors (overflow, underflow, divide by zero)</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Hardware instructions intended to support facilities such as emulation, debugging, and error detection</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Software interrupts and other actions caused by asynchronous external events aren't considered to be exceptions.</font>

<p><font face="Times">Although many exceptions, such as page faults, can be handled by the operating system and dismissed transparently to the user, the remaining exceptions are exported to the user by the operating system's exception-handling facility (for example, by invoking a handler or producing a core dump).</font>

<p><font face="Times">Four major classes of applications use exceptions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Debugging--Debuggers rely on exceptions generated by hardware trace and breakpoint facilities.&nbsp; Other exceptions that indicate errors must be reported to the debugger; the presence of the debugger indicates the user's interest in any anomalous program behavior.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Core dumps--In the absence of a debugger, a fatal exception can cause the execution state of a program to be saved in a file for later examination.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Error handling--Certain applications sometimes handle their own exceptions (particularly arithmetic).&nbsp; For example, an error handler could substitute 0 for the result of a floating underflow and continue execution.&nbsp; Error handlers are often required by high-level languages.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Emulation--Generally, computers generate exceptions upon encountering operation codes that can't be executed by the hardware.&nbsp; Emulators can be built to execute the desired operation in software.&nbsp; Such emulators serve to extend the instruction set of the underlying machine by performing instructions that aren't present in the hardware.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The following sections contrast the UNIX approach to error handling with the general model upon which the Mach exception-handling facility is built, and then present specific information about the Mach exception-handling facility.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>The UNIX Approach to Exception Handling</b></font>

<p><font face="Times">Designers of operating systems have approached exceptions in a variety of ways.&nbsp; The drawbacks of most approaches include limited functionality (often the result of designing only for debuggers) and lack of extensibility to a multithreaded environment.</font>

<p><font face="Times">The UNIX operating system generalizes exception handling to the signal facility, which handles all interruptions to normal program flow.&nbsp; The varying requirements of different types of interruptions (such as exceptions, timer expiration, or a control character from the terminal) entail semantics that vary from signal to signal; the default action can be nothing, stop, continue from stop, or terminate (with or without a core dump).&nbsp; The user can change these defaults or specify a handler to be invoked by a signal.&nbsp; The interface to these handlers includes a partial machine context, but registers outside this context aren't accessible.</font>

<p><font face="Times">Debugging support in UNIX is centralized in the <b>ptrace()</b> system call:&nbsp; It performs all data transfer and process control needed by debuggers, and interacts with the signal facility to make signals visible to debuggers (including signals that would otherwise invoke error handlers or emulators).&nbsp; The occurrence of a signal in a debugged process causes that process to stop in a peculiar manner and notify the debugger that something has happened.&nbsp; This notification is implemented by special treatment of debugged processes in the <b>wait()</b> system call; this call usually detects terminated processes, but also detects stopped processes that are being debugged.&nbsp; One consequence of these features and their implementation is that debuggers are restricted to debugging processes that are the immediate children of the debugger.</font>

<p><font face="Times">Two major problems with the UNIX signal facility are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Executing the signal handler in the same context as the exception makes many registers inaccessible.&nbsp; These registers are often the very registers that an arithmetic error handler needs to modify (for example, by substituting 0 for a floating underflow).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The entire concept of signals is predicated on single-threaded applications.&nbsp; Adapting signals to multithreaded applications is difficult and complicates the interface to them.&nbsp; At least half a dozen major changes to the UNIX signal implementation in the Mach kernel have been required for this reason.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The typical use of signal handlers is to detect and respond to external events; for this they're adequate, but as an exception-handling facility, they leave much to be desired.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>A Model for Generalized Exception Handling</b></font>

<p><font face="Times">The Mach exception-handling facility is based on a model whose generality is sufficient to describe virtually all uses of exceptions, including those made by the four classes of applications discussed earlier.</font>

<p><font face="Times">The Mach exception-handling model divides applications that use exceptions into two major classes:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Error handlers--Perform recovery actions in response to an exception and resume execution of the thread involved.&nbsp; This class includes both error handlers and emulators.&nbsp; Error handlers typically execute in the same address space as that thread for efficiency reasons (access to state).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Debuggers--Examine the state of an entire application to investigate why an exception occurred or why the program is misbehaving.&nbsp; This class includes both interactive debuggers and the servers that produce core dumps; the latter can be viewed as front ends to debuggers that examine core dumps.&nbsp; Debuggers usually execute in address spaces distinct from the application for protection reasons.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This chapter uses the terms <i>error handler</i> and <i>debugger</i> to refer to these two classes (for example, a core dumper is a debugger).&nbsp; The term <i>handler</i> is used to refer to any application that uses exceptions.</font>

<p><font face="Times">The Mach exception-handling model is derived by examining the requirements common to error handlers and debuggers. Specifically, the occurrence of an exception requires suspension of the thread involved and notification of a handler.&nbsp; The handler receives the notification and performs some computation (for example, an error handler fixes the error, a debugger decides what to do next), after which the thread is either resumed or terminated.</font>

<p><font face="Times">The model presented in this section covers all uses of exceptions.&nbsp; The occurrence of an exception invokes a four-step process involving the thread that caused the exception (victim) and the entity that handles the exception (handler, which may be the operating system):</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">1.</font></td>

<td><font face="Times">Victim does a <i>raise</i>, causing notification of the occurrence of an exception.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">2.</font></td>

<td><font face="Times">Victim does a <i>wait</i>, synchronizing with completion of exception handling.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">3.</font></td>

<td><font face="Times">Handler does a <i>catch</i>, receiving notification.&nbsp; This notification usually identifies the exception and the victim, although some of this identification may be implicit in where and how the notification is received.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">4.</font></td>

<td><font face="Times">Handler takes either of two possible actions:&nbsp; <i>clear</i> the exception (causing the victim to return from the <i>wait</i>), or <i>terminate </i>the victim thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The primitives appearing in bold in this model constitute the high-level model interface to exceptions and can be viewed as operating on <i>exception objects</i>.&nbsp; The handler will usually perform other functions between the <i>catch</i> step and the <i>clear</i> or <i>terminate</i> step; these functions are part of the handler application itself, rather than part of the exception model.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Exception Handling in Mach</b></font>

<p><font face="Times">The Mach exception-handling facility was designed as a general implementation of the exception-handling model described above.&nbsp; The major design goals for this new facility were:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Single facility with consistent semantics for all exceptions</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Clean and simple interface</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Full support for debuggers and error handlers</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">No duplication of functionality within kernel</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Support for user-defined exceptions</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A consequence of these goals is a rejection of the notion of a handler executing in the same context as the exception it's handling.&nbsp; There is no clean and straightforward way to make a thread's context available to the thread itself; this results in a single thread having multiple contexts (a currently executing context and one or more saved exception contexts).&nbsp; In turn this causes serious naming and functionality problems for operations that access or manipulate thread contexts.&nbsp; Because Mach supports multiple threads within the same task, it's sufficient to stop the thread that caused the exception and execute the handler as another thread in the same task.</font>

<p><font face="Times">The Mach exception-handling facility implements the exception-handling model with Mach kernel functions to avoid duplicating kernel functionality.&nbsp; Because the handler never executes in the context of the victim thread, the <i>raise</i>, <i>wait</i>, <i>notify</i>, and <i>clear </i>primitives constitute a remote procedure call (RPC).&nbsp; They're therefore implemented using a message-based RPC provided by the Mach communication facility.&nbsp; The remaining <i>terminate</i> primitive is exactly the <b>thread_terminate()</b> or <b>task_terminate() </b>function; no special action is required to terminate the thread or task instead of completing the RPC.</font>

<p><font face="Times">The exception RPC consists of two messages:&nbsp; an initial message to invoke the RPC, and a reply message to complete the RPC. The initial message contains the following items:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Send and reply ports for the RPC</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The identities of the thread that caused the exception and of the corresponding task</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">A machine-independent exception class (see the section &quot;Exception Classification&quot;)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Two machine-dependent fields that further identify the exception</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If the RPC is completed, the reply message contains the two RPC ports and a return code from the handler that handled the exception (success in almost all cases).&nbsp; MiG-generated stub routines perform the generation and decoding of the messages; this allows users to avoid dealing directly with the contents of the messages.&nbsp; (MiG is described in Chapter 2.)</font>

<p><font face="Times">An exception RPC corresponds to our exception model as follows:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>raise</i>--Send initial message.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>wait</i>--Wait for and receive reply message.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>catch</i>--Receive initial message.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><i>clear</i>--Send reply message.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Exception Ports</b></font>

<p><font face="Times">The two messages that constitute the RPC are sent to and received from ports corresponding to the handler (initial message) and victim (reply message).&nbsp; The handler's port is registered as the exception port for either the victim's task or thread; the kernel consults this registration when an exception occurs.&nbsp; The reply port is specified in the initial message; for hardware exceptions, the kernel allocates the reply port and caches it for reuse on a per-thread basis.&nbsp; Mach kernel functions are available to register a port as an exception port for a task or thread, and to return the port currently registered; these functions for implementing debuggers and error handlers are described in the section &quot;Program Example: Exception Handling.&quot;</font>

<p><font face="Times">Registering exception ports for both tasks and threads effects a separation of concerns between error handlers and debuggers. Error handlers are supported by the thread exception ports because error handlers usually affect only the victim thread; different threads within a task can have different error handlers.&nbsp; The registered exception port for a thread defaults to the null port at thread creation; this defaults the initial error handler to no handler.&nbsp; Debuggers are supported by the task exception ports because debuggers operate on the application level; this includes at least all the threads in the victim's task, so at most one debugger is associated with a single task.&nbsp; The registered exception port for a task is inherited from the parent task at task creation; this supports debuggers that handle trees of tasks (such as a multitasking parallel program) and inheritance of core-dump servers.</font>

<p><font face="Times">The presence of both task and thread exception ports creates a potential conflict because both are applicable to any exception. This is resolved by examining the differences between error handlers and debuggers.&nbsp; Error handlers use exceptions to implement portions of an application; an error handler is an integral part of the application that generates its exceptions. Exceptions handled by an error handler may be unusual, but they don't indicate anomalous or erroneous behavior.&nbsp; In contrast, debuggers use exceptions to investigate anomalous or erroneous application behavior; as a result debuggers have little interest in exceptions successfully handled by error handlers.&nbsp; This implies that exceptions should invoke error handlers in preference to debuggers; this preference is implemented by having thread exception ports take precedence over task exception ports in determining where to direct the RPC invoked by an exception.&nbsp; If neither an error handler nor a debugger can successfully handle an exception, the task is terminated.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>User Extensibility</b></font>

<p><font face="Times">The Mach exception-handling facility permits you to define and handle your own exceptions in addition to those defined by the system.</font>

<p><font face="Times">The software class of exceptions (see the section &quot;Exception Classification&quot;) contains a range of codes reserved for user-defined exceptions; this allows the handling of these exceptions to be integrated into the handling of system-defined exceptions.&nbsp; The same ports are used in both cases, and the interface to handlers is identical.</font>

<p><font face="Times">An advantage of this approach is that user-defined exceptions can immediately be recognized as such, even by debuggers that can't decode the machine-dependent fields that identify the exact exception.</font>

<p><font face="Times">Generation of user-defined exceptions is facilitated by a MiG stub routine that implements the exception RPC (in turn this routine is generated automatically from an interface description of the exception RPC).&nbsp; User code that detects an exception simply obtains the appropriate exception port from the kernel and calls this stub routine; the stub routine handles the RPC and returns a return code from the handler.&nbsp; Alternatively, you may use the MiG exception interface with your own exceptions and exception ports; this approach may be advantageous for applications that handle only user-defined exceptions.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Implementing Error Handlers</b></font>

<p><font face="Times">Error handlers are supported by thread exception ports and invoked by remote procedure calls on those ports.&nbsp; An error handler is associated with a thread by registering a port on which the error handler receives exception RPCs as the exception port of the thread.&nbsp; This registration causes all exceptions occurring in the thread to invoke RPCs to the error handler's port.&nbsp; Since most error handlers can't handle all possible exceptions that could occur, they must check each exception and forward it to the corresponding task exception port if it can't be handled.&nbsp; This forwarding can be performed by obtaining the exception port for the task specified in the initial message and sending the initial message there.&nbsp; Alternatively, the error handler can return a failure code in the reply message; this causes the sender of the initial message to reinitiate the RPC using the task exception port.</font>

<p><font face="Times">Implementation of error handlers requires additional functionality beyond completing the RPC.&nbsp; This functionality is supported by separate Mach kernel functions that can also be used by other applications.&nbsp; The most common actions and corresponding functions are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read/write register state:&nbsp; <b>thread_get_state()</b>, <b>thread_set_state()</b></font></td></tr>

<tr valign=top>

<td width=105 height=13></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read/write memory state:&nbsp; Access memory directly within task; otherwise <b>vm_read()</b>, <b>vm_write()</b></font></td></tr>

<tr valign=top>

<td width=105 height=13></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Terminate thread:&nbsp; <b>thread_terminate()</b></font></td></tr>

<tr valign=top>

<td width=105 height=13></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Resume thread:&nbsp; Send reply message to complete RPC (<b>msg_send()</b>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Some applications may require that error handlers execute in the context of (that is, on the stack of) the thread that caused the exception (such as emulation of UNIX signal handlers).&nbsp; Although this appears to conflict with the principle of never executing an error handler in the context of the victim thread, it can be implemented by using a system-invoked error handler to set up the application's handler.&nbsp; Specifically, the error handler invoked by the exception RPC modifies the victim thread so that the application's handler is executed when the thread is resumed.&nbsp; Unwinding the stack when the application's error handler finishes is the responsibility of the application developer.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Implementing Debuggers</b></font>

<p><font face="Times">Debuggers are supported by the task exception ports; exceptions invoke debuggers with remote procedure calls on those ports. A debugger is associated with a task by registering a port on which the debugger receives exception RPCs as the task's exception port.&nbsp; An exception RPC stops only the victim thread pending RPC completion; other threads in the task continue running.&nbsp; This has two consequences:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the debugger wants to stop the entire task, a <b>task_suspend()</b> must be performed.&nbsp; A straightforward way to accomplish this is to do it inside the exception RPC and then complete the RPC; the victim thread can't resume execution upon RPC completion because its task has been suspended.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Multiple exceptions from a multithreaded task may be outstanding for the debugger on a single debugger invocation.&nbsp; If the debugger doesn't handle these pending exceptions for the task, some may appear to occur at impossible times (such as a breakpoint occurring after the user has removed it).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The Mach exception-handling facility is one small component of the kernel that can be used by debuggers.&nbsp; The various actions required to support debuggers are implemented using general-purpose functions that also support other applications.&nbsp; Some of the more important debugger actions and corresponding kernel functions are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Detect event:&nbsp; <b>msg_receive()</b>.&nbsp; System components that generate or detect external events (such as interrupt characters on a terminal) signal the events by sending messages.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read and write application memory (includes setting breakpoints):&nbsp; <b>vm_read()</b>, <b>vm_write()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read and write application registers (includes setting single-step mode if available):&nbsp; <b>thread_get_state()</b>, <b>thread_set_state()</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Continue application:&nbsp; Task and thread control functions.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">End debugging session:&nbsp; <b>task_terminate()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Exceptions that invoke error handlers using thread exception ports aren't visible to debuggers.&nbsp; A debugger that wants to detect error handler invocation can insert one or more breakpoints in the error handler itself; exceptions caused by these breakpoints will be reported to the debugger.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Debugger Attachment</b></font>

<p><font face="Times">The independence property of the Mach kernel described previously allows Mach to support debugger attachment and detachment without change to the kernel itself.&nbsp; Traditional UNIX systems require that the debugged process be the child of the debugger; this makes it impossible to debug a process that wasn't started by the debugger.&nbsp; Subsequent developers have expended considerable effort to implement an <b>attach</b> primitive that allows a debugger to attach to a previously started process and debug it; this allows analysis of failures that may not be repeatable.&nbsp; Similarly these systems allow a debugger to detach from a running process and exit without affecting the process.&nbsp; No design change is required to support this functionality; the debugger need only obtain the port representing the task to be debugged, and may then use all of the functions previously discussed to debug that task.&nbsp; A debugger can detach from a task by resetting the task's exception port to its former value; there is no other connection between the debugger and task being debugged.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Parallel and Distributed Debugging</b></font>

<p><font face="Times">The design of the exception-handling facility also supports parallel and distributed debugging without change.&nbsp; There are several cases to be considered based on the structure of the debugger and the application being debugged.&nbsp; In all of these cases the debugger itself may be a parallel or distributed application consisting of multiple tasks and threads.</font>

<p><font face="Times">For parallel applications composed of multiple threads within a single task, a debugger need only register its exception RPC port as that task's exception port.&nbsp; Multiple concurrent exceptions result in multiple RPC invocations being queued to that port; each invocation identifies the thread involved.&nbsp; The Mach communication facility allows the debugger to accept all of these RPCs before responding to any of them, and to respond to them in any order.&nbsp; (Of course the debugger must keep track of the RPCs and make sure they're all responded to when continuing the application.)&nbsp; A straightforward implementation is to suspend the task in response to the first RPC, and then complete all pending exception RPCs recording the threads and exceptions involved.&nbsp; The exceptions can then be reported to the user all at once.</font>

<p><font face="Times">For parallel applications composed of multiple tasks within a single machine, only minor changes to the above debugger logic are required.&nbsp; The debugger must now register its exception RPC port as the task exception port for each task, and may choose to identify components of the parallel application by tasks instead of threads.&nbsp; Suspending or resuming the entire application now requires an operation on each task.&nbsp; If the application dynamically creates tasks, an additional interface to report these new tasks to the debugger may be required so that the new tasks can be suspended and resumed by the debugger.</font>

<p><font face="Times">Network transparency allows the components of a debugger and the debugged application to be spread throughout a network; all required operations extend transparently across the network.&nbsp; This supports a number of possible debugging scenarios:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The application and the debugger are on separate hosts.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The application being debugged is distributed over the network.&nbsp; The debugger doesn't require modifications beyond those needed to deal with applications composed of multiple tasks.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The debugger itself can be distributed over the network.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The last scenario is useful for implementing fast exception response in a debugger for applications that run in parallel on several distributed hosts; if the exception RPC stays within the host, suspending of all application components on that host can be done faster.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>GDB Enhancements</b></font>

<p><font face="Times">The Mach exception-handling facility and other Mach kernel functions have been used to enhance GDB (the GNU source-level debugger) for debugging multithreaded tasks.&nbsp; This enhanced version of GDB operates at the task level (that is, any exception causes GDB to suspend the entire task).&nbsp; A notion of the current thread has been added; this thread is used by any thread-specific command that doesn't specify a thread.&nbsp; New commands are provided to list the threads in the task, change the current thread, and examine or control individual threads.&nbsp; Thread-specific breakpoints are supported by logic that transparently continues the application from the breakpoint until the desired thread hits it.&nbsp; Implementation of attachment to running tasks, as described earlier in the section &quot;Debugger Attachment,&quot; is in progress, as are changes to deal with multiple concurrent breakpoints.</font>

<p><font face="Times">The existence of multiple threads within a debugged task complicates GDB's execution control logic.&nbsp; In addition to the <b>task_suspend()</b> required upon exception detection, resuming from a breakpoint becomes somewhat intricate.&nbsp; Standard GDB removes the breakpoint, single-steps the process, puts back the breakpoint and continues.&nbsp; The enhanced version must ensure that only the thread at the breakpoint executes while performing the single step; this requires switching from task suspension to suspension of all of the threads except one and then back again before resuming the application.</font>

<p><font face="Times">The Mach exception-handling facility is an important implementation base for the enhancements to GDB.&nbsp; Identification of the victim thread in the initial message makes it possible to handle multiple concurrent exceptions; all the UNIX functions (for example, <b>ptrace()</b>) are restricted to one current signal per task, and hence preclude handling of multiple concurrent exceptions. Additionally, the independence of the debugger from the debugged application makes it possible to implement debugger attachment without kernel modifications; the UNIX operating system requires extensive kernel modifications to achieve similar functionality.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Exception Classification</b></font>

<p><font face="Times">The Mach exception-handling facility employs a new hardware-independent classification of exceptions.&nbsp; This is in contrast to previous systems (such as UNIX), whose exception classifications are closely wedded to the hardware they were originally developed on.&nbsp; This new classification divides all exceptions into six classes based on the causes and uses of the exceptions; further hardware-specific and software-specific distinctions can be made within these classes as needed.&nbsp; The six classes are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Bad access--A user access to memory failed for some reason and the operating system was unable to recover (such as invalid memory or protection violation).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Bad instruction--A user executed an illegitimate instruction (such as an undefined instruction, reserved operand, or privileged instruction).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Arithmetic--A user arithmetic instruction failed for an arithmetic reason (such as overflow, underflow, or divide by zero).</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Emulation--A user executed an instruction requiring software emulation.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Software--A broad class including all exceptions intended to support software.&nbsp; These fall into three subclasses:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Hardware</font></td>

<td><font face="Times">Hardware instructions to support error detection (such as trap on overflow or trap on subscript out of range).</font></td></tr>

<tr valign=top>

<td width=124 height=12></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">Operating system</font></td>

<td><font face="Times">Exceptions detected by operating system during system call execution (such as no receiver on pipe).&nbsp; These are for operating system emulation (such as UNIX emulation).&nbsp; Mach doesn't use exceptions for system call errors.</font></td></tr>

<tr valign=top>

<td width=124 height=12></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times">User</font></td>

<td><font face="Times">Exceptions defined and caused by user software for its own purposes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Debugger--Hardware exceptions to support debuggers (such as breakpoint instruction and trace trap).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">In cases of potential confusion (for example, is it a bad instruction or an instruction requiring emulation?) the correct classification is always clear from the intended uses of the instruction as determined by the hardware and system designers.</font>

<p><font face="Times">Two machine-dependent fields are used to identify the precise exception within a class for flexibility in encoding exception numbers.&nbsp; Two fields are needed for emulation instructions containing a single argument (one for the instruction, one for the argument), but we have also found them useful for constructing machine-dependent exception classifications (for example, using one field to hold the trap number or vector, and the other to distinguish this trap from the others that use this number or vector).&nbsp; Cases in which two fields don't suffice require a separate interface to extract the additional machine-dependent status.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>Kernel Interface</b></font>

<p><font face="Times">This section lists functions that relate directly to the exception-handling facility.&nbsp; The following Mach functions let you raise exceptions, handle them, and get or set exception ports.&nbsp; See Chapter 4 for descriptions of each of these functions and macros.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>exception_raise()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>exc_server()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>mach_NeXT_exception()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>mach_NeXT_exception_string()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>task_set_exception_port()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>task_get_exception_port()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>thread_set_exception_port()</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times"><b>thread_get_exception_port()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Another important function is one you implement yourself:&nbsp; <b>catch_exception_raise()</b>.&nbsp; If you implement this function, it must have the following syntax:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=130></td>

<td><font face="Times">kern_return_t <b>catch_exception_raise(</b>port_t <i>exception_port</i>, port_t <i>thread</i>, port_t <i>task</i>, int <i>exception</i>, int <i>code</i>, int <i>subcode</i><b>)</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Program Example:&nbsp; Exception Handling</b></font>

<p><font face="Times">The following example shows how to raise and handle user-defined exceptions.&nbsp; The program sets up a new exception port, sets up a thread to listen to this port, and then raises an exception by calling <b>exception_raise()</b>.&nbsp; The thread that's listening to the exception port receives the exception message and passes it to <b>exc_server()</b>, which calls the user-implemented function <b>catch_exception_raise()</b>.</font>

<p><font face="Times">This program's implementation of <b>catch_exception_raise()</b> determines whether it understands the exception.&nbsp; If so, it handles the exception by displaying a message.&nbsp; If not, this implementation of <b>catch_exception_raise()</b> sets a global variable that indicates that its calling thread should forward the exception to the old exception port.&nbsp; This program doesn't know which exception handler is listening to the old exception port; it could be the default UNIX exception handler, GDB, or any other exception handler.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* raise.c: This program shows how to raise user-specified exceptions.</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* If you use GDB, you can't set any breakpoints or step through any</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* code between the call to task_set_exception_port and the return</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* from exception_raise().&nbsp; (You can never use GDB to debug exception</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* handling code, since GDB stops the program by generating an</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* EXC_BREAKPOINT exception.)</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/mach.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/exception.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/cthreads.h&gt;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#import &lt;mach/mig_errors.h&gt;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">port_t old_exc_port;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">port_t clear_port;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">port_t exc_port;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">} ports_t;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">volatile boolean_t pass_on = FALSE;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printing;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* Listen on the exception port. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">any_t exc_thread(ports_t *port_p)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; r;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *msg_data[2][64];</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">msg_header_t&nbsp;&nbsp; *imsg = (msg_header_t *)msg_data[0],</font><br>
<img src="../../../Images/sp.gif" width=257 height=1><font face="Courier" size="-1">*omsg = (msg_header_t *)msg_data[1];</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Wait for exceptions. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">while (1) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">imsg-&gt;msg_size = 64;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">imsg-&gt;msg_local_port = port_p-&gt;exc_port;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">r = msg_receive(imsg, MSG_OPTION_NONE, 0);</font>

<p><img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if (r==RCV_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">/* Give the message to the Mach exception server. */</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">if (exc_server(imsg, omsg)) {</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">/* Send the reply message that exc_serv gave us. */</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">r = msg_send(omsg, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">if (r != SEND_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">mach_error(&#34;exc_thread msg_send&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=264 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">else { /* exc_server refused to handle imsg. */</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">printf(&#34;exc_server didn't like the message\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">exit(2);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">else { /* msg_receive() returned an error. */</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">mach_error(&#34;exc_thread msg_receive&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">exit(3);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Pass the message to old exception handler, if necessary. */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if (pass_on == TRUE) {</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">imsg-&gt;msg_remote_port = port_p-&gt;old_exc_port;</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">imsg-&gt;msg_local_port = port_p-&gt;clear_port;</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">r = msg_send(imsg, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">if (r != SEND_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">mach_error(&#34;msg_send to old_exc_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">exit(4);</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* catch_exception_raise() is called by exc_server().&nbsp; The only</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">* exception it can handle is EXC_SOFTWARE.</font><br>
<img src="../../../Images/sp.gif" width=131 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">kern_return_t catch_exception_raise(port_t exception_port,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">port_t thread, port_t task, int exception, int code, int subcode)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if ((exception == EXC_SOFTWARE) &amp;&amp; (code == 0x20000)) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">pass_on = FALSE;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">/* Handle the exception so that the program can continue. */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Handling the exception\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">return KERN_SUCCESS;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">else { /* Pass the exception on to the old port. */</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">pass_on = TRUE;</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_NeXT_exception(&#34;Forwarding exception&#34;, exception,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">code, subcode);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">return KERN_FAILURE;&nbsp; /* Couldn't handle this exception. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; r;</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">ports_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ports;</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Save the old exception port for this task. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">r = task_get_exception_port(task_self(), &amp;(ports.old_exc_port));</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;task_get_exception_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Create a new exception port for this task. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">r = port_allocate(task_self(), &amp;(ports.exc_port));</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate 0&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">r = task_set_exception_port(task_self(), (ports.exc_port));</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;task_set_exception_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Fork the thread that listens to the exception port. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)exc_thread,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">(any_t)&amp;ports));</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* Raise the exception. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">ports.clear_port = thread_reply();</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#ifdef NOT_OUR_EXCEPTION</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">/* By default, EXC_BAD_ACCESS causes a core dump. */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">r = exception_raise(ports.exc_port, ports.clear_port,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">thread_self(), task_self(), EXC_BAD_ACCESS, 0, 0);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#else</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">r = exception_raise(ports.exc_port, ports.clear_port,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">thread_self(), task_self(), EXC_SOFTWARE, 0x20000, 0);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">#endif</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mach_error(&#34;catch_exception_raise didn't handle exception&#34;,</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">r);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">printf(&#34;Successfully called exception_raise\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">sleep(5);&nbsp; /* Exiting too soon can disturb other exception</font><br>
<img src="../../../Images/sp.gif" width=236 height=1><font face="Courier" size="-1">* handlers. */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>



</body>
</html>
