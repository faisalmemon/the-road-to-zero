<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/OperatingSystem/Part1_Mach/04_MachFunctions/MachFunctions.rtf -->
<!-- Date: Sun Jun 28 20:09:34 1998 -->
<head>
<title>MachFunctions</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3" color="#FF00FF"><b>4</b></font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+3"><i>Mach Functions</i></font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This chapter gives detailed descriptions of the C functions provided by the NeXT Mach operating system.&nbsp; It also describes some macros that behave like functions.&nbsp; For this chapter, the functions and macros are divided into five groups:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">C-thread functions--Use these to implement multiple threads in an application.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Mach kernel functions--Use these to get access to the Mach operating system.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Bootstrap Server functions--Use these to set up communication between the task that provides a local service and the tasks that use the service.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Network Name Server functions--Use these to set up communication between tasks that might not be on the same machine.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Kernel-server loader functions--Use these to load and unload loadable kernel servers, to add and delete servers to and from the kernel-server loader, and to get information about servers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Within each section, functions are subgrouped with other functions that perform related tasks.&nbsp; These subgroups are described in alphabetical order by the name of the first function listed in the subgroup.&nbsp; Functions within subgroups are also listed alphabetically, with a pointer to the subgroup description.</font>

<p><font face="Times">For convenience, these functions are summarized in the <i>NEXTSTEP Programming Interface Summary</i>.&nbsp; The summary lists functions by the same subgroups used in this chapter and combines several related subgroups under a heading such as &quot;Basic C-Thread Functions&quot; or &quot;Task Functions.&quot;&nbsp; For each function, the summary shows the calling sequence.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>C-Thread Functions</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">These functions provide a C language interface to the low-level, language-independent primitives for manipulating threads of control.</font>

<p><font face="Times">In a multithreaded application, you should use the C-thread functions whenever possible, rather than Mach kernel functions.&nbsp; If you need to call a Mach kernel function that requires a <b>thread_t</b> argument, you can find the Mach thread that corresponds to a particular C thread by calling <b>cthread_thread()</b>.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>condition_alloc(), mutex_alloc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a condition or mutex object</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">condition_t <b>condition_alloc(</b>void<b>)</b></font><br>
<font face="Times">mutex_t <b>mutex_alloc(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macros <b>condition_alloc()</b> and <b>mutex_alloc()</b> provide dynamic allocation of condition and mutex objects.&nbsp; When you're finished using these objects, you can deallocate them using <b>condition_free()</b> and <b>mutex_free()</b>.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">my_condition = condition_alloc();</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">my_mutex = mutex_alloc();</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_init()</b>, <b>mutex_init()</b>, <b>condition_free()</b>, <b>mutex_free()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_broadcast()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Broadcast a condition</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>condition_broadcast(</b>condition_t <i>c</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macro <b>condition_broadcast()</b> wakes up all threads that are waiting (with <b>condition_wait()</b>) for the condition <i>c</i>.&nbsp; This macro is similar to <b>condition_signal()</b>, except that <b>condition_signal()</b> doesn't wake up every waiting thread.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">any_t listen(any_t arg)</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">while(!data)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">condition_wait(my_condition, my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(my_mutex);</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Condition has been met\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">my_condition = condition_alloc();</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">my_mutex = mutex_alloc();</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)listen, (any_t)0));</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">data = 1;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">condition_broadcast(my_condition);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_signal()</b>, <b>condition_wait()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_clear(), mutex_clear()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Clear a condition or mutex object</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>condition_clear(</b>struct condition *<i>c</i><b>)</b></font><br>
<font face="Times">void <b>mutex_clear(</b>struct mutex *<i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">You must call one of these macros before freeing an object of type <b>struct condition</b> or <b>struct mutex</b>.&nbsp; See the discussion of <b>condition_init()</b> and <b>mutex_init()</b> for information on why you might want to use these types instead of <b>condition_t</b> and <b>mutex_t</b>.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">struct mystruct {</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">my_data_t&nbsp;&nbsp;&nbsp;&nbsp; data;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">struct mutex&nbsp; m;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct mystruct&nbsp; *mydata;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mydata = (struct mystruct *)malloc(sizeof (struct mystruct));</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_init(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_lock(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Do something to mydata that only one thread can do. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_unlock(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_clear(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">free(mydata);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_init()</b>, <b>mutex_init()</b>, <b>condition_free()</b>, <b>mutex_free()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_free(), mutex_free()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Deallocate a condition or mutex object</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>condition_free(</b>condition_t <i>c</i><b>)</b></font><br>
<font face="Times">void <b>mutex_free(</b>mutex_t <i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macros <b>condition_free()</b> and <b>mutex_free()</b> let you deallocate condition and mutex objects that were allocated dynamically. Before deallocating such an object, you must guarantee that no other thread will reference it.&nbsp; In particular, a thread blocked in <b>mutex_lock()</b> or <b>condition_wait()</b> should be viewed as referencing the object continually; freeing the object out from under such a thread is erroneous, and can result in bugs that are extremely difficult to track down.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_alloc()</b>, <b>mutex_alloc()</b>, <b>condition_clear()</b>, <b>mutex_clear()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_init(), mutex_init()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Initialize a condition variable or mutex</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>condition_init(</b>struct condition *<i>c</i><b>)</b></font><br>
<font face="Times">void <b>mutex_init(</b>struct mutex *<i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macros <b>condition_init()</b> and <b>mutex_init()</b> initialize an object of the <b>struct condition</b> or <b>struct mutex</b> referent type, so that its address can be used wherever an object of type <b>condition_t</b> or <b>mutex_t</b> is expected.&nbsp; Initialization of the referent type is most often used when you have included the referent type itself (rather than a pointer) in a larger structure, for more efficient storage allocation.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For instance, a data structure might contain a component of type <b>struct mutex</b> to allow each instance of that structure to be locked independently.&nbsp; During initialization of the instance, you would call <b>mutex_init()</b> on the <b>struct mutex</b> component.&nbsp; The alternative of using a <b>mutex_t</b> component and initializing it using <b>mutex_alloc()</b> would be less efficient.</font>

<p><font face="Times">If you're going to free a condition or mutex object of type <b>struct condition</b> or <b>struct mutex</b>, you should first clear it using <b>condition_clear()</b> or <b>mutex_clear()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">struct mystruct {</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">my_data_t&nbsp;&nbsp;&nbsp;&nbsp; data;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">struct mutex&nbsp; m;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct mystruct&nbsp; *mydata;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mydata = (struct mystruct *)malloc(sizeof (struct mystruct));</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_init(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_lock(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Do something to mydata that only one thread can do. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_unlock(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_clear(&amp;mydata-&gt;m);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">free(mydata);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_alloc()</b>, <b>mutex_alloc()</b>, <b>condition_clear()</b>, <b>mutex_clear()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_name(), condition_set_name(), mutex_name(), mutex_set_name()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Associate a string with a condition or mutex variable</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">char *<b>condition_name(</b>condition_t <i>c</i><b>)</b></font><br>
<font face="Times">void <b>condition_set_name(</b>condition_t <i>c</i>, char *<i>name</i><b>)</b></font><br>
<font face="Times">char *<b>mutex_name(</b>mutex_t <i>m</i><b>)</b></font><br>
<font face="Times">void <b>mutex_set_name(</b>mutex_t <i>m</i>, char *<i>name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These macros let you associate a name with a condition or a mutex object.&nbsp; The name is used when trace information is displayed.&nbsp; You can also use this name for your own application-dependent purposes.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Do something if this is a &#34;TYPE 1&#34; condition. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (strcmp(condition_name(c), &#34;TYPE 1&#34;) == 0)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Do something. */;</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_signal()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Signal a condition</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>condition_signal(</b>condition_t <i>c</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macro <b>condition_signal()</b> should be called when one thread needs to indicate that the condition represented by the condition variable is now true.&nbsp; If any other threads are waiting (using <b>condition_wait()</b>), at least one of them will be awakened. If no threads are waiting, nothing happens.&nbsp; The macro <b>condition_broadcast()</b> is similar to this one, except that it wakes up <i>all </i>threads that are waiting.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">any_t listen(any_t arg)</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">while(!data)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">condition_wait(my_condition, my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(my_mutex);</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Condition has been met\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">my_condition = condition_alloc();</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">my_mutex = mutex_alloc();</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)listen, (any_t)0));</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">data = 1;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(my_mutex);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">condition_signal(my_condition);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_broadcast()</b>, <b>condition_wait()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>condition_wait()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Wait on a condition</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>condition_wait(</b>condition_t <i>c</i>, mutex_t <i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>condition_wait()</b> unlocks the mutex it takes as a argument, suspends the calling thread until the specified condition is likely to be true, and locks the mutex again when the thread resumes.&nbsp; There's no guarantee that the condition will be true when the thread resumes, so this function should always be used as follows:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_t m;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">condition_t c;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_lock(m);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">while&nbsp;&nbsp;&nbsp; (/* condition isn't true */)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">condition_wait(c, m);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">mutex_unlock(m);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>condition_broadcast()</b>, <b>condition_signal()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_abort()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Interrupt a C thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>cthread_abort(</b>cthread_t <i>t</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function provides the functionality of <b>thread_abort()</b> to C threads.&nbsp; The <b>cthread_abort()</b> function interrupts system calls; it's usually used along with <b>thread_suspend()</b>, which stops a thread from executing any more user code.&nbsp; Calling <b>cthread_abort()</b> on a thread that isn't suspended is risky, since it's difficult to know exactly what system trap, if any, the thread might be executing and whether an interrupt return would cause the thread to do something useful.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">See <b>thread_abort()</b> for a full description of the use of this function.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>cthread_count()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the number of threads in this task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>cthread_count()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function returns the number of threads that exist in the current task.&nbsp; You can use this function to help make sure that your task doesn't create too many threads (over 200 or so).&nbsp; See <b>cthread_set_limit()</b> for information on restricting the number of threads in a task.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">printf(&#34;C thread count should be 1, is %d\n&#34;, cthread_count());</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)listen, (any_t)0));</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;C thread count should be 2, is %d\n&#34;, cthread_count());</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_limit()</b>, <b>cthread_set_limit()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_data(), cthread_set_data()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Associate data with a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">any_t <b>cthread_data(</b>cthread_t <i>t</i><b>)</b></font><br>
<font face="Times">void <b>cthread_set_data(</b>cthread_t <i>t</i>, any_t <i>data</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macros <b>cthread_data()</b> and <b>cthread_set_data()</b> let you associate arbitrary data with a thread, providing a simple form of thread-specific &quot;global&quot; variable.&nbsp; More elaborate mechanisms, such as per-thread property lists or hash tables, can then be built with these macros.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">int listen(any_t arg)</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;This thread's data is: %d\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">(int)cthread_data(cthread_self()));</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_t lthread;</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">lthread = cthread_fork((cthread_fn_t)listen, (any_t)0);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_set_data(lthread, (any_t)100);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_detach(lthread);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_name()</b>, <b>cthread_set_name()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_detach()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Detach a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>cthread_detach(</b>cthread_t <i>t</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>cthread_detach()</b> is used to indicate that <b>cthread_join()</b> will never be called on the given thread.&nbsp; This is usually known at the time the thread is forked, so the most efficient usage is the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><img src="../../../Images/sp.gif" width=18 height=1><font face="Times"><b>cthread_detach(cthread_fork</b>(<i>function</i>, <i>argument</i>)<b>)</b>;</font>

<p><font face="Times">A thread may, however, be detached at any time after it's forked, as long as no other attempt is made to join it or detach it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)listen, (any_t)reply_port));</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_fork()</b>, <b>cthread_join()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_errno()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get a thread's errno value</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>cthread_errno(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Use the <b>cthread_errno()</b> function to get the errno value for the current thread.&nbsp; In the UNIX operating system, <b>errno</b> is a process-wide global variable that's set to an error number when a UNIX system call fails.&nbsp; However, because Mach has multiple threads per process, Mach keeps errno information on a per-thread basis as well as in <b>errno</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Like the value of <b>errno</b>, the value returned by <b>cthread_errno()</b> is valid only if the last UNIX system call returned</font> <img src="../../../Images/c2D.gif" width=8 height=4><font face="Times">1.&nbsp; Errno values are defined in the header file <b>bsd/sys/errno.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">int ret;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">ret = chown(FILEPATH, newOwner, newGroup);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (ret == -1) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (cthread_errno() == ENAMETOOLONG)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_set_errno()</b>, <b>intro(2)</b> UNIX manual page</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_exit()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Exit a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>cthread_exit(</b>any_t <i>result</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>cthread_exit()</b> terminates the calling thread.&nbsp; The result is passed to the thread that joins the caller, or is discarded if the caller is detached.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An implicit <b>cthread_exit()</b> occurs when the top-level function of a thread returns, but it may also be called explicitly.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">cthread_exit(0);</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_detach()</b>, <b>cthread_fork()</b>, <b>cthread_join()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_fork()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Fork a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">cthread_t <b>cthread_fork(</b>any_t (*<i>function</i>)(), any_t <i>arg</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>cthread_fork()</b> takes two arguments:&nbsp; a function for the new thread to execute, and an argument to this function. The <b>cthread_fork()</b> function creates a new thread of control in which the specified function is executed concurrently with the caller's thread.&nbsp; This is the sole means of creating new threads.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>any_t</b> type represents a pointer to any C type.&nbsp; The <b>cthread_t</b> type is an integer-size handle that uniquely identifies a thread of control.&nbsp; Values of type <b>cthread_t</b> will be referred to as thread identifiers.&nbsp; Arguments larger than a pointer must be passed by reference.&nbsp; Similarly, multiple arguments must be simulated by passing a pointer to a structure containing several components.&nbsp; The call to <b>cthread_fork()</b> returns a thread identifier that can be passed to <b>cthread_join()</b> or <b>cthread_detach()</b>. Every thread must be either joined or detached exactly once.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)listen, (any_t)reply_port));</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_detach()</b>, <b>cthread_exit()</b>, <b>cthread_join()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_join()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Join threads</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">any_t <b>cthread_join(</b>cthread_t <i>t</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>cthread_join()</b> suspends the caller until the specified thread <i>t</i> terminates.&nbsp; The caller receives either the result of <i>t</i>'s top-level function or the argument with which <i>t</i> explicitly called <b>cthread_exit()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Attempting to join one's own thread results in deadlock.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">cthread_t t;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">t = cthread_fork((any_t (*)())listen, (any_t)reply_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . (Do some work, perhaps forking other threads.) */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result = cthread_join(t);&nbsp; /* Wait for the thread to finish executing. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . (Continue doing work) */</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_detach()</b>, <b>cthread_exit()</b>, <b>cthread_fork()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_limit(), cthread_set_limit()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get or set the maximum number of threads in this task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>cthread_limit(</b>void<b>)</b></font><br>
<font face="Times">void <b>cthread_set_limit(</b>int <i>limit</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>limit</i>:&nbsp; The new maximum number of C threads per task.&nbsp; Specify zero if you want no limit.</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions can help you to avoid creating too many threads.&nbsp; The danger in creating a large number of threads is that the kernel might run out of resources and panic.&nbsp; Usually, a task should avoid creating more than about 200 threads.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Use <b>cthread_set_limit()</b> to set a limit on the number of threads in the current task.&nbsp; When the limit is reached, new C threads will appear to fork successfully.&nbsp; However, they will have no associated Mach thread, so they won't do anything.</font>

<p><font face="Times">Use <b>cthread_limit()</b> to find out how many threads can exist in the current task.&nbsp; If the returned value is zero (the default), then no limit is currently being enforced.</font>

<p><font face="Helvetica"><b>Important:</b></font>&nbsp; <font face="Times">Use <b>cthread_count()</b> to determine when your task is approaching the maximum number of threads.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">cthread_set_limit(LIMIT);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Fork if we haven't reached the limit. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ( (LIMIT == 0) || (LIMIT &gt; cthread_count()) )</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((any_t (*)())a_thread,(any_t)0));</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_name(), cthread_set_name()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Associate a string with a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">char *<b>cthread_name(</b>cthread_t <i>t</i><b>)</b></font><br>
<font face="Times">void <b>cthread_set_name(</b>cthread_t <i>t</i>, char *<i>name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The functions <b>cthread_name()</b> and <b>cthread_set_name()</b> let you associate an arbitrary name with a thread.&nbsp; The name is used when trace information is displayed.&nbsp; The name may also be used for application-specific diagnostics.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">int listen(any_t arg)</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;This thread's name is: %s\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">cthread_name(cthread_self()));</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_t lthread;</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">lthread = cthread_fork((cthread_fn_t)listen, (any_t)0);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_set_name(lthread, &#34;lthread&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_detach(lthread);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_data()</b>, <b>cthread_set_data()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_priority(), cthread_max_priority()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the scheduling priority for a C thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>cthread_priority(</b>cthread_t <i>t</i>, int <i>priority</i>, boolean_t <i>set_max</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>cthread_max_priority(</b>cthread_t <i>t</i>, processor_set_t <i>processor_set</i>, int <i>max_priority</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>t</i>:&nbsp; The C thread whose priority is to be changed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>priority</i>:&nbsp; The new priority to change it to.</font>

<p><font face="Times"><i>set_max</i>:&nbsp; Also set <i>t</i>'s maximum priority if true.</font>

<p><font face="Times"><i>processor_set</i>:&nbsp; The privileged port for the processor set to which <i>thread</i> is currently assigned.</font>

<p><font face="Times"><i>max_priority</i>:&nbsp; The new maximum priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">These functions give C threads the functionality of <b>thread_priority()</b> and <b>thread_max_priority()</b>.&nbsp; See those functions for more details than are provided here.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>cthread_priority()</b> function changes the base priority and (optionally) the maximum priority of <i>t</i>.&nbsp; If the new base priority is higher than the scheduled priority of the currently executing thread, this thread might be preempted.&nbsp; The maximum priority of the thread is also set if <i>set_max</i> is true.&nbsp; This call fails if <i>priority</i> is greater than the current maximum priority of the thread.&nbsp; As a result, <b>cthread_priority()</b> can lower--but never raise--the value of a thread's maximum priority.</font>

<p><font face="Times">The <b>cthread_max_priority()</b> function changes the maximum priority of the thread.&nbsp; Because it requires the privileged port for the processor set, this call can reset the maximum priority to any legal value.&nbsp; If the new maximum priority is less than the thread's base priority, then the thread's base priority is set to the new maximum priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Get the privileged port for the default processor set. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Set the max priority. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=cthread_max_priority(cthread_self(), default_set_priv,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">priority);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to cthread_max_priority() failed&#34;,error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Set the thread's priority. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=cthread_priority(cthread_self(), priority, FALSE);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to cthread_priority() failed&#34;,error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Operation completed successfully</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>cthread</i> is not a C thread, <i>processor_set</i> is not a privileged port for a processor set, or <i>priority</i> is out of range (not in 0-31).</font>

<p><font face="Times">KERN_FAILURE:&nbsp; The requested operation would violate the thread's maximum priority (only for <b>cthread_priority()</b>) or the thread is not assigned to the processor set whose privileged port was presented.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_priority()</b>, <b>thread_max_priority()</b>, <b>thread_policy()</b>, <b>task_priority()</b>, <b>processor_set_priority()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_self()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Return the caller's C-thread identifier</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">cthread_t <b>cthread_self(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>cthread_self()</b> returns the caller's own C-thread identifier, which is the same value that was returned by <b>cthread_fork()</b> to the creator of the thread.&nbsp; The C-thread identifier uniquely identifies the thread, and hence may be used as a key in data structures that associate user data with individual threads.&nbsp; Since thread identifiers may be reused by the underlying implementation, you should be careful to clean up such associations when threads exit.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">printf(&#34;This thread's name is: %s\n&#34;,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_name(cthread_self()));</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_fork()</b>, <b>cthread_thread()</b>, <b>thread_self()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_set_errno_self()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the current thread's errno value</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>cthread_set_errno_self(</b>int <i>error</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Use this function to set the errno value for the current thread to <i>error</i>.&nbsp; In the UNIX operating system, <b>errno</b> is a process-wide global variable that's set to an error number when a UNIX system call fails.&nbsp; However, because Mach has multiple threads per process, Mach keeps errno information on a per-thread basis as well as in <b>errno</b>.&nbsp; This function has no effect on the value of <b>errno</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The current thread's errno value can be obtained by calling <b>cthread_errno()</b>.&nbsp; Errno values are defined in the header file <b>bsd/sys/errno.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">cthread_set_errno_self(EPERM);</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_errno()</b>, <b>intro(2)</b> UNIX manual page</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_thread()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Return the caller's Mach thread identifier</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">thread_t <b>cthread_thread(</b>cthread_t <i>t</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macro <b>cthread_thread()</b> returns the Mach thread that corresponds to the specified C thread <i>t</i>.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Save the cthread and thread values for the forked thread. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">l_cthread = cthread_fork((cthread_fn_t)listen, (any_t)0);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">cthread_detach(l_cthread);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">l_realthread = cthread_thread(l_cthread);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_fork()</b>, <b>cthread_self()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>cthread_yield()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Yield the processor to other threads</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>cthread_yield(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>cthread_yield()</b> is a hint to the scheduler, suggesting that this would be a convenient point to schedule another thread to run on the current processor.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">int i, n;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* n is set previously */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">for (i = 0; i &lt; n; i += 1)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_yield();</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>cthread_priority()</b>, <b>thread_switch()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>mutex_lock()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Lock a mutex variable</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>mutex_lock(</b>mutex_t <i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The macro <b>mutex_lock()</b> attempts to lock the mutex <i>m</i> and blocks until it succeeds.&nbsp; If several threads attempt to lock the same mutex concurrently, one will succeed, and the others will block until <i>m</i> is unlocked.&nbsp; A deadlock occurs if a thread attempts to lock a mutex it has already locked.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Only one thread at a time should call printf. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;Condition has been met\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>mutex_try_lock()</b>, <b>mutex_unlock()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>mutex_try_lock()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Try to lock a mutex variable</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">int <b>mutex_try_lock(</b>mutex_t <i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>mutex_try_lock()</b> attempts to lock the mutex <i>m</i>, like <b>mutex_lock()</b>, and returns true if it succeeds.&nbsp; If <i>m</i> is already locked, however, <b>mutex_try_lock()</b> immediately returns false rather than blocking.&nbsp; For example, a busy-waiting version of <b>mutex_lock()</b> could be written using <b>mutex_try_lock()</b>:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">void mutex_lock(mutex_t m)</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">for (;;)</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">if (mutex_try_lock(m))</font><br>
<img src="../../../Images/sp.gif" width=208 height=1><font face="Courier" size="-1">return;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>mutex_lock()</b>, <b>mutex_unlock()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>mutex_unlock()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Unlock a mutex variable</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/cthreads.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>mutex_unlock(</b>mutex_t <i>m</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>mutex_unlock()</b> unlocks <i>m</i>, giving other threads a chance to lock it.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Only one thread at a time should call printf. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;Condition has been met\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>mutex_lock()</b>, <b>mutex_try_lock()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>Mach Kernel Functions</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>exc_server()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Dispatch a message received on an exception port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;mach/exception.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">boolean_t <b>exc_server(</b>msg_header_t *<i>in</i>, msg_header_t *<i>out</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>in</i>:&nbsp; A message that was received on the exception port.&nbsp; This message structure should be at least 64 bytes long.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>out</i>:&nbsp; An empty message to be filled by <b>exc_server()</b> and then sent.&nbsp; This message buffer should be at least 32 bytes long.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function calls the appropriate exception handler.&nbsp; You should call this function after you've received a message on an exception port that you set up previously.&nbsp; Usually, this function is used along with a user-defined exception handler, which must have the following protocol:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td><font face="Times">kern_return_t <b>catch_exception_raise(</b>port_t <i>exception_port</i>, port_t <i>thread</i>, port_t <i>task</i>, int <i>exception</i>, int <i>code</i>, int <i>subcode</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">To receive a message on an exception port, you must first create a new port and make it the task or thread exception port.&nbsp; (You can't use the default task exception port because you can't get receive rights for it.)&nbsp; Before calling <b>msg_receive()</b>, you must set the <b>local_port</b> field of the header to the appropriate exception port and the <b>msg_size</b> field to the size of the structure for the incoming message.</font>

<p><font face="Times">If it accepted the incoming message, <b>exc_server()</b> returns true; otherwise it returns false.</font>

<p><font face="Times">You should keep a global value that indicates whether your exception handler successfully handled the exception.&nbsp; If it couldn't, then you should forward the exception message to the old exception port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">typedef struct {</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">port_t old_exc_port;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">port_t clear_port;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">port_t exc_port;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">} ports_t;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">volatile boolean_t&nbsp; pass_on = FALSE;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">mutex_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printing;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Listen on the exception port. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">any_t exc_thread(ports_t *port_p)</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; r;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *msg_data[2][64];</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">msg_header_t&nbsp;&nbsp; *imsg = (msg_header_t *)msg_data[0],</font><br>
<img src="../../../Images/sp.gif" width=238 height=1><font face="Courier" size="-1">*omsg = (msg_header_t *)msg_data[1];</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Wait for exceptions. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">while (1) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">imsg-&gt;msg_size = 64;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">imsg-&gt;msg_local_port = port_p-&gt;exc_port;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">r = msg_receive(imsg, MSG_OPTION_NONE, 0);</font>

<p><img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">if (r==RCV_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">/* Give the message to the Mach exception server. */</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">if (exc_server(imsg, omsg)) {</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">/* Send the reply message that exc_serv gave us. */</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">r = msg_send(omsg, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">if (r != SEND_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=245 height=1><font face="Courier" size="-1">mach_error(&#34;msg_send&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=245 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">else { /* exc_server refused to handle imsg. */</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">printf(&#34;exc_server didn't like the message\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">exit(2);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">else { /* msg_receive() returned an error. */</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">mach_error(&#34;msg_receive&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">exit(3);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* Pass the message to old exception handler, if necessary. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">if (pass_on == TRUE) {</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">imsg-&gt;msg_remote_port = port_p-&gt;old_exc_port;</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">imsg-&gt;msg_local_port = port_p-&gt;clear_port;</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">r = msg_send(imsg, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">if (r != SEND_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">mach_error(&#34;msg_send to old_exc_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=217 height=1><font face="Courier" size="-1">exit(4);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">* catch_exception_raise() is called by exc_server().&nbsp; The only</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">* exception it can handle is EXC_SOFTWARE.</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t catch_exception_raise(port_t exception_port,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">port_t thread, port_t task, int exception, int code, int subcode)</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if ((exception == EXC_SOFTWARE) &amp;&amp; (code == 0x20000)) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* Handle the exception so that the program can continue. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf(&#34;Handling the exception\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">return KERN_SUCCESS;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">else { /* Pass the exception on to the old port. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">pass_on = TRUE;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_NeXT_exception(&#34;Forwarding exception&#34;, exception,</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">code, subcode);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">return KERN_FAILURE;&nbsp; /* Couldn't handle this exception. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; r;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">ports_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ports;</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Save the old exception port for this task. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">r = task_get_exception_port(task_self(), &amp;(ports.old_exc_port));</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;task_get_exception_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Create a new exception port for this task. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">r = port_allocate(task_self(), &amp;(ports.exc_port));</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate 0&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">r = task_set_exception_port(task_self(), (ports.exc_port));</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;task_set_exception_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Fork the thread that listens to the exception port. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">cthread_detach(cthread_fork((cthread_fn_t)exc_thread,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">(any_t)&amp;ports));</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Raise the exception. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">ports.clear_port = thread_self();</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">r = exception_raise(ports.exc_port, thread_reply(),</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">ports.clear_port, task_self(), EXC_SOFTWARE, 0x20000, 6);</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;catch_exception_raise didn't handle exception&#34;,</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf(&#34;Successfully called exception_raise\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>exception_raise()</b>, <b>mach_NeXT_exception()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>exception_raise()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Cause an exception to occur</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;mach/exception.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>exception_raise(</b>port_t <i>exception_port</i>, port_t <i>clear_port</i>, port_t <i>thread</i>, port_t <i>task</i>, int <i>exception</i>, int <i>code</i>, int <i>subcode</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>exception_port</i>:&nbsp; The exception port of the affected thread.&nbsp; (If the thread doesn't have its own exception port, then this should be the exception port of the task.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>clear_port</i>:&nbsp; The port to which a reply message should be sent from the exception handler.&nbsp; If you don't care to see the reply, you can use <b>thread_reply()</b>.</font>

<p><font face="Times"><i>thread</i>:&nbsp; The thread in which the exception condition occurred.&nbsp; If the exception isn't thread-specific, then specify THREAD_NULL.</font>

<p><font face="Times"><i>task</i>:&nbsp; The task in which the exception condition occurred.</font>

<p><font face="Times"><i>exception</i>:&nbsp; The type of exception that occurred; for example, EXC_SOFTWARE.&nbsp; Values for this variable are defined in the header file <b>mach/exception.h</b>.</font>

<p><font face="Times"><i>code</i>:&nbsp; The exception code.&nbsp; The meaning of this code depends on the value of <i>exception</i>.</font>

<p><font face="Times"><i>subcode</i>:&nbsp; The exception subcode.&nbsp; The meaning of this subcode depends on the values of <i>exception</i> and <i>code</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function causes an exception message to be sent to <i>exception_port</i>, which results in a call to the exception handler. Usually this function is used along with a user-defined exception handler.&nbsp; (See <b>exc_server()</b> and <b>mach_NeXT_exception()</b> for more information on user-defined exception handlers.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You can obtain <i>exception_port</i> by calling <b>thread_get_exception_port()</b> or (if no thread exception port exists or the exception affects the whole task) <b>task_get_exception_port()</b>.</font>

<p><font face="Times">If you're defining your own type of exception, you must have <i>exception</i> equal to EXC_SOFTWARE and <i>code</i> equal to or greater than 0x20000.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Raise the exception. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = exception_raise(ports.exc_port, thread_reply(), thread_self(),</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">task_self(), EXC_SOFTWARE, 0x20000, 6);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;catch_exception_raise didn't handle exception&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Use mutex so only one thread at a time can call printf. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Successfully called exception_raise\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_FAILURE:&nbsp; The exception handler didn't successfully deal with the exception.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; One of the arguments wasn't valid.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>exc_server()</b>, <b>mach_NeXT_exception()</b>, <b>task_get_exception_port()</b>, <b>thread_get_exception_port()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>host_info()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about a host</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>host_info(</b>host_t <i>host</i>, int <i>flavor</i>, host_info_t <i>host_info</i>, unsigned int *<i>host_info_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>host</i>:&nbsp; The host for which information is to be obtained.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>flavor</i>:&nbsp; The type of statistics to be returned.&nbsp; Currently HOST_BASIC_INFO, HOST_PROCESSOR_SLOTS, and HOST_SCHED_INFO are implemented.</font>

<p><font face="Times"><i>host_info</i>:&nbsp; Returns statistics about <i>host</i>.</font>

<p><font face="Times"><i>host_info_count</i>:&nbsp; The number of integers in the info structure; returns the number of integers that Mach tried to fill the info structure with.&nbsp; For HOST_BASIC_INFO, you should set <i>host_info_count</i> to HOST_BASIC_INFO_COUNT.&nbsp; For HOST_PROCESSOR_SLOTS, you should set it to the maximum number of CPUs (returned by HOST_BASIC_INFO).&nbsp; For HOST_SCHED_INFO, set it to HOST_SCHED_INFO_COUNT.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns the selected information array for a host, as specified by <i>flavor</i>.&nbsp; The <i>host_info</i> argument is an array of integers that's supplied by the caller and returned filled with specified information.&nbsp; The <i>host_info_count</i> argument is supplied by the caller as the maximum number of integers in <i>host_info</i> (which can be larger than the space required for the information).&nbsp; On return, it contains the actual number of integers in <i>host_info</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">This replaces the old <b>host_info()</b> call.&nbsp; It isn't backwards compatible.</font>

<p><font face="Times">Basic information is defined by HOST_BASIC_INFO.&nbsp; Its size is defined by HOST_BASIC_INFO_COUNT.&nbsp; Possible values of the <b>cpu_type</b> and <b>cpu_subtype</b> fields are defined in the header file <b>mach/machine.h</b>, which is included in <b>mach/mach.h</b>.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct host_basic_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_cpus;&nbsp;&nbsp;&nbsp;&nbsp; /* maximum possible cpus for</font><br>
<img src="../../../Images/sp.gif" width=355 height=1><font face="Courier" size="-1">* which kernel is configured */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; avail_cpus;&nbsp;&nbsp; /* number of cpus now available */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">vm_size_t&nbsp;&nbsp;&nbsp;&nbsp; memory_size;&nbsp; /* size of memory in bytes */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">cpu_type_t&nbsp;&nbsp;&nbsp; cpu_type;&nbsp;&nbsp;&nbsp;&nbsp; /* cpu type */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">cpu_subtype_t cpu_subtype;&nbsp; /* cpu subtype */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct host_basic_info *host_basic_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Processor slots of the active (available) processors are defined by HOST_PROCESSOR_SLOTS.&nbsp; The size of this information should be obtained from the <b>max_cpus</b> field of the structure returned by HOST_BASIC_INFO.&nbsp; HOST_PROCESSOR_SLOTS returns an array of integers, each of which is the slot number of a CPU.</font>

<p><font face="Times">Additional information of interest to schedulers is defined by HOST_SCHED_INFO.&nbsp; The size of this information is defined by HOST_SCHED_INFO_COUNT.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct host_sched_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; min_timeout;&nbsp; /* minimum timeout in milliseconds */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; min_quantum;&nbsp; /* minimum quantum in milliseconds */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct host_sched_info *host_sched_info_t</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Times">An example of using HOST_BASIC_INFO:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct host_basic_info&nbsp; basic_info;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count=HOST_BASIC_INFO_COUNT;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">ret=host_info(host_self(), HOST_BASIC_INFO,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">(host_info_t)&amp;basic_info, &amp;count);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (ret != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mach_error(&#34;host_info() call failed&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">else printf(&#34;This system has %d bytes of RAM.\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">basic_info.memory_size);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An example of using HOST_PROCESSOR_SLOTS (you also need to include the HOST_BASIC_INFO code above so you can get <b>max_cpus</b>):</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">host_info_t&nbsp; slots;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned int cpu_count, i;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">cpu_count=basic_info.max_cpus;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">slots=(host_info_t)malloc(cpu_count*sizeof(int));</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">ret=host_info(host_self(), HOST_PROCESSOR_SLOTS, slots,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">&amp;cpu_count);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (ret!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mach_error(&#34;PROCESSOR host_info() call failed&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">else for (i=0; i&lt;cpu_count; i++)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;CPU %d is in slot %d.\n&#34;, i, *slots++);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">An example of using HOST_SCHED_INFO:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct host_sched_info&nbsp; sched_info;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sched_count=HOST_SCHED_INFO_COUNT;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">ret=host_info(host_self(), HOST_SCHED_INFO,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">(host_info_t)&amp;sched_info, &amp;sched_count);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (ret != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mach_error(&#34;SCHED host_info() call failed&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;The minimum quantum is %d milliseconds.\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">sched_info.min_quantum);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>host</i> is not a host, <i>flavor</i> is not recognized, or (for HOST_PROCESSOR_SLOTS) *<i>count</i> is less than <b>max_cpus</b>.</font>

<p><font face="Times">KERN_FAILURE:&nbsp; *<i>count</i> is less than HOST_BASIC_INFO_COUNT (when <i>flavor</i> is HOST_BASIC_INFO) or HOST_SCHED_INFO_COUNT (for HOST_SCHED_INFO).</font>

<p><font face="Times">MIG_ARRAY_TOO_LARGE:&nbsp; Returned info array is too large for <i>host_info</i>.&nbsp; The <i>host_info</i> argument is filled as much as possible, and <i>host_info_count</i> is set to the number of elements that would be returned if there were enough room.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>host_kernel_version()</b>, <b>host_processors()</b>, <b>processor_info()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>host_kernel_version()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get kernel version information</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>host_kernel_version(</b>host_t <i>host</i>, kernel_version_t <i>version</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>host</i>:&nbsp; The host for which information is being requested.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>version</i>:&nbsp; Returns a character string describing the kernel version executing on <i>host</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function returns the version string compiled into <i>host</i>'s kernel at the time it was built.&nbsp; If you don't use the <b>kernel_version_t</b> declaration, then you should allocate KERNEL_VERSION_MAX bytes for the version string.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kernel_version_t&nbsp;&nbsp;&nbsp; string;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">ret=host_kernel_version(host_self(), string);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (ret != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;host_kernel_version() call failed&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Version string:&nbsp; %s\n&#34;, string);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>host</i> was not a host.</font>

<p><font face="Times">KERN_INVALID_ADDRESS:&nbsp; <i>version</i> points to inaccessible memory.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>host_info()</b>, <b>host_processors()</b>, <b>processor_info()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>host_processor_set_priv()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the privileged port of a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>host_processor_set_priv(</b>host_priv_t <i>host_priv</i>, processor_set_t <i>processor_set_name</i>, processor_set_t *<i>processor_set</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>host_priv</i>:&nbsp; The privileged host port for the desired host.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>processor_set_name</i>:&nbsp; The name port of the processor set.</font>

<p><font face="Times"><i>processor_set</i>:&nbsp; Returns the privileged port of the processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function returns send rights to the privileged port for the specified processor set.&nbsp; This port is used in calls that can affect other threads or tasks.&nbsp; For example, <b>processor_set_tasks()</b> requires the privileged port because it returns the port of every task on the system.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t&nbsp; processor_set;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t&nbsp; default_set;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to processor_set_default failed&#34;, error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;processor_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv failed; make sure</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">you're superuser&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>host_priv</i> was not a privileged host port, or <i>processor_set_name</i> didn't name a valid processor set.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>host_processor_sets()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the name ports of all processor sets on a host</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>host_processor_sets(</b>host_t <i>host</i>, processor_set_name_array_t *<i>processor_set_list</i>, unsigned int *<i>processor_set_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>host</i>:&nbsp; The host port for the desired host.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>processor_set_list</i>:&nbsp; Returns an array of processor sets currently existing on <i>host</i>; no particular ordering is guaranteed.</font>

<p><font face="Times"><i>processor_set_ count</i>:&nbsp; Returns the number of processor sets in the <i>processor_set_list</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function returns send rights to the name port for each processor set currently assigned to <i>host</i>.&nbsp; The <b>host_processor_set_priv()</b> function can be used to obtain the privileged ports from these if desired.&nbsp; The <i>processor_set_list </i>argument is an array that is created as a result of this call.&nbsp; You should call <b>vm_deallocate()</b> on this array when the data is no longer needed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">In single-processor systems, you can get the same information by calling <b>processor_set_default()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_name_array_t&nbsp; list;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">ret=host_processor_sets(host_self(), &amp;list, &amp;count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (ret!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;error calling host_processor_sets&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">ret=vm_deallocate(task_self(), (vm_address_t)list,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">sizeof(list)*count);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (ret!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;error calling vm_deallocate&#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>host</i> is not a host.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>host_processor_set_priv()</b>, <b>processor_set_create()</b>, <b>processor_set_tasks()</b>, <b>processor_set_threads()</b>, <b>processor_set_default()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>host_processors()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the processor ports for a host</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>host_processors(</b>host_priv_t <i>host_priv</i>, processor_array_t *<i>processor_list</i>, unsigned int *<i>processor_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>host_priv</i>:&nbsp; Privileged host port for the desired host.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>processor_list</i>:&nbsp; Returns the processors existing on <i>host_priv</i>; no particular ordering is guaranteed.</font>

<p><font face="Times"><i>processor_count</i>:&nbsp; Returns the number of processors in <i>processor_list</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>host_processors()</b> gets send rights to the processor port for each processor existing on <i>host_priv</i>.&nbsp; The <i>processor_list</i> argument is an array that is created as a result of this call.&nbsp; The caller may wish to call <b>vm_deallocate()</b> on this array when the data is no longer needed.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_array_t&nbsp; list;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processors(host_priv_self(), &amp;list, &amp;count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS){</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;error calling host_processors&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_deallocate(task_self(), (vm_address_t)list, sizeof(list)*count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing list&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>host_priv</i> is not a privileged host port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>processor_info()</b>, <b>processor_start()</b>, <b>processor_exit()</b>, <b>processor_control()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>host_self(), host_priv_self()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the host port for this host</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">host_t <b>host_self(</b>void<b>)</b></font><br>
<font face="Times">host_priv_t <b>host_priv_self(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The <b>host_self()</b> function returns send rights to the host port for the host on which the call is executed.&nbsp; This port can be used only to obtain information about the host, not to control the host.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>host_priv_self()</b> function returns send rights to the privileged host port for the host on which the call is executed.&nbsp; This port is used to control physical resources on that host and is only available to privileged tasks.&nbsp; PORT_NULL is returned if the invoker is not the UNIX superuser.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Get the privileged port for the default processor set. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>host_processors()</b>, <b>host_info()</b>, <b>host_kernel_version()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>mach_error(), mach_error_string()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Display or get a Mach error string</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;mach/mach_error.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>mach_error(</b>char *<i>string</i>, kern_return_t <i>error</i><b>)</b></font><br>
<font face="Times">char *<b>mach_error_string(</b>kern_return_t <i>error</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>string</i>:&nbsp; The string you want displayed before the Mach error string.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>error</i>:&nbsp; The error value for which you want an error string.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>mach_error()</b> displays a message on <b>stderr</b>.&nbsp; The message contains the string specified by <i>string</i>, the string returned by <b>mach_error_string()</b>, and the actual error value (<i>error</i>).&nbsp; Since <b>mach_error()</b> isn't thread-safe, you might want to protect it with a mutex if you call it in a multiple-thread task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function <b>mach_error_string()</b> returns the string associated with <i>error</i>.</font>

<p><font face="Times">Note that because the error value specified by <i>error</i> is of type <b>kern_return_t</b>, these functions work only with Mach functions.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">mutex_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printing;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">main()</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">kern_return_t&nbsp; error;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result;</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printing = mutex_alloc();</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if ((error=port_allocate(task_self(), &amp;result)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling port_allocate&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>mach_NeXT_exception(), mach_NeXT_exception_string()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Display or get a Mach exception string</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">void <b>mach_NeXT_exception(</b>char *<i>string</i>, int <i>exception</i>, int <i>code</i>, int <i>subcode</i><b>)</b></font><br>
<font face="Times">char *<b>mach_NeXT_exception_string(</b>int <i>exception</i>, int <i>code</i>, int <i>subcode</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>string</i>:&nbsp; The string you want displayed before the Mach exception string.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>exception</i>:&nbsp; The exception value for which you want a string.</font>

<p><font face="Times"><i>code</i>:&nbsp; The exception code.&nbsp; How this is used depends on the value of <i>exception</i>.</font>

<p><font face="Times"><i>subcode</i>:&nbsp; The exception subcode.&nbsp; How this is used depends on the value of <i>exception</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>mach_NeXT_exception()</b> displays a message on <b>stderr</b>.&nbsp; The message contains the string specified by <i>string</i>, then the string returned by <b>mach_NeXT_exception_string()</b>, and then the values of <i>exception</i>, <i>code</i>, and <i>subcode</i>.&nbsp; Since <b>mach_NeXT_exception()</b> isn't thread-safe, you might want to protect it with a mutex if you call it in a multiple-thread task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function <b>mach_NeXT_exception_string()</b> returns the string associated with <i>exception</i>, <i>code</i>, and <i>subcode</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/*</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">* catch_exception_raise() is called by exc_server().&nbsp; The only</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">* exception it can handle is EXC_SOFTWARE.</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t catch_exception_raise(port_t exception_port,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">port_t thread, port_t task, int exception, int code, int subcode)</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if ((exception == EXC_SOFTWARE) &amp;&amp; (code == 0x20000)) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* Handle the exception so that the program can continue. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_lock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf(&#34;Handling the exception\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mutex_unlock(printing);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">return KERN_SUCCESS;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">else { /* Pass the exception on to the old port. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">pass_on = TRUE;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_NeXT_exception(&#34;Forwarding exception&#34;, exception,</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">code, subcode);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">return KERN_FAILURE;&nbsp; /* Couldn't handle this exception. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>exception_raise()</b>, <b>exc_server()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>map_fd()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Map a file into virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>map_fd(</b>int <i>fd</i>, vm_offset_t <i>offset</i>, vm_offset_t *<i>address</i>, boolean_t <i>find_space</i>, vm_size_t <i>size</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>fd</i>:&nbsp; An open UNIX file descriptor for the file that's to be mapped.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>offset</i>:&nbsp; The byte offset within the file, at which mapping is to begin.</font>

<p><font face="Times"><i>address</i>:&nbsp; A pointer to an address in the calling process at which the mapped file should start.&nbsp; This address, unlike the offset, must be page-aligned.</font>

<p><font face="Times"><i>find_space</i>:&nbsp; If true, the kernel will select an unused address range at which to map the file and return its value in <i>address</i>.</font>

<p><font face="Times"><i>size</i>:&nbsp; The number of bytes to be mapped.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>map_fd()</b> is a UNIX extension that's technically not part of Mach.&nbsp; This function causes <i>size</i> bytes of data starting at <i>offset</i> in the file specified by <i>fd</i> to be mapped into the virtual memory at the address specified by <i>address.</i>&nbsp; If <i>find_space</i> is true, the input value of <i>address</i> can be null, and the kernel will find an unused piece of virtual memory to use.&nbsp; (You should free this space with <b>vm_deallocate()</b> when you no longer need it.)&nbsp; If you provide a value for <i>address</i>, it must be page-aligned and at least <i>size</i> bytes long.&nbsp; The sum of <i>offset</i> and <i>size</i> must not exceed the length of the file.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Memory mapping doesn't cause I/O to take place.&nbsp; When specific pages are first referenced, they cause page faults that bring in the data.&nbsp; The mapped memory is copy-on-write.&nbsp; Modified data is returned to the file only by a <b>write()</b> call.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t r;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *memfile, *filename = &#34;/tmp/myfile&#34;;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Open the file. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">fd = open(filename, O_RDONLY);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Map part of it into memory. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = map_fd(fd, (vm_offset_t)0, &amp;(vm_offset_t)memfile, TRUE,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(vm_size_t)5);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling map_fd()&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Second character in %s is:&nbsp; %c\n&#34;, filename, memfile[1]);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The data was mapped successfully.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ADDRESS:&nbsp; <i>address</i> wasn't valid.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; An invalid argument was passed.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>msg_receive()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Receive a message</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;mach/message.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">msg_return_t <b>msg_receive(</b>msg_header_t *<i>header</i>, msg_option_t <i>option</i>, msg_timeout_t <i>timeout</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>header</i>:&nbsp; The address of a buffer in which the message is to be received.&nbsp; Two fields of the message header must be set before the call is made:&nbsp; <b>msg_local_port</b> must be set to the value of the port from which the message is to be received, and <b>msg_size </b>must be set to the maximum size of the message that may be received.&nbsp; This maximum size must be less than or equal to the size of the buffer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>option</i>:&nbsp; The failure conditions under which <b>msg_receive()</b> should terminate.&nbsp; The value of this argument is a combination (using the bitwise OR operator) of the following options.&nbsp; Unless one of these values is explicitly specified, <b>msg_receive()</b> does not return until a message has been received.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">RCV_TIMEOUT:&nbsp; Specifies that <b>msg_receive()</b> should return when the specified timeout elapses if a message has not arrived by that time; if not specified, the timeout will be ignored (that is, it will be infinite).</font>

<p><font face="Times">RCV_INTERRUPT:&nbsp; Specifies that <b>msg_receive()</b> should return when a software interrupt occurs in this thread.</font>

<p><font face="Times">RCV_LARGE:&nbsp; Specifies that <b>msg_receive()</b> should return without dequeuing a message if the next message in the queue is larger than <i>header</i><b>.msg_size</b>.&nbsp; (Normally, a message that is too large is dequeued and lost.)&nbsp; You can use this option to dynamically determine how large your message buffer must be.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Use MSG_OPTION_NONE to specify that none of the above options is desired.</font>

<p><font face="Times"><i>timeout</i>:&nbsp; If RCV_TIMEOUT is specified in <i>option</i>, then <i>timeout</i> is the maximum time in milliseconds to wait for a message before giving up.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>msg_receive()</b> retrieves the next message from the port or port set specified in the <b>msg_local_port</b> field of <i>header</i>.&nbsp; If a port is specified, the port must not be a member of a port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If a port set is specified, then <b>msg_receive()</b> will retrieve messages sent to any of the set's member ports.&nbsp; Mach sets the <b>msg_local_port</b> field to the specific port on which the message was found.&nbsp; It's not an error for the port set to have no members, or for members to be added and removed from a port set while a <b>msg_receive()</b> on the port set is in progress.</font>

<p><font face="Times">The message consists of its header, followed by a variable amount of data; the message header supplied to <b>msg_receive()</b> must specify (in <b>msg_size</b>) the maximum size of the message that can be received into the buffer provided.</font>

<p><font face="Times">If no messages are present on the port(s) in question, <b>msg_receive()</b> will wait until a message arrives, or until one of the specified termination conditions is met (see the description of the <i>option</i> argument for this function).</font>

<p><font face="Times">If the message is successfully received, then <b>msg_receive()</b> sets the <b>msg_size</b> field of the header to the size of the received message.&nbsp; If the RCV_LARGE option was set and <b>msg_receive()</b> returned RCV_TOO_LARGE, then the <b>msg_size</b> field is set to the size of the message that was too large.</font>

<p><font face="Times">If the received message contains out-of-line data (that is, data for which the <b>msg_type_inline</b> attribute was specified as false), the data will be returned in a newly allocated region of memory; the message body will contain a pointer to that new region. You should deallocate this memory when the data is no longer needed.&nbsp; See the <b>vm_allocate()</b> call for a description of the state of newly allocated memory.</font>

<p><font face="Times">See Chapter 2, &quot;Using Mach Messages,&quot; for information on setting up messages and on writing Mach servers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">msg_header_t&nbsp;&nbsp; *imsg, header;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Wait for messages. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">while (1) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Set up the message structure. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">header.msg_size = sizeof header;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">header.msg_local_port = receive_port;</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Get the next message on the queue. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">r = msg_receive(&amp;header, RCV_LARGE, 0);</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* If the message is too big ... */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r==RCV_TOO_LARGE) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* ... allocate a structure for it ... */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">imsg = (msg_header_t *)malloc(header.msg_size);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* ... initialize the structure ... */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">imsg-&gt;msg_size = header.msg_size;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">imsg-&gt;msg_local_port = receive_port;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* ... and get the message. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">r = msg_receive(imsg, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r==RCV_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">/* Handle the message. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">else { /* msg_receive() returned an error. */</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;msg_receive&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">exit(3);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">RCV_SUCCESS:&nbsp; The message has been received.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">RCV_INVALID_MEMORY:&nbsp; The message specified was not writable by the calling task.</font>

<p><font face="Times">RCV_INVALID_PORT:&nbsp; An attempt was made to receive on a port to which the calling task does not have the proper access, or which was deallocated (see <b>port_deallocate()</b>) while waiting for a message.</font>

<p><font face="Times">RCV_TOO_LARGE:&nbsp; The message header and body combined are larger than the size specified by <b>msg_size</b>.&nbsp; Unless the RCV_LARGE option was set, the message has been dequeued and lost.&nbsp; If the RCV_LARGE option was specified, then Mach sets <b>msg_size</b> to the size of the message that was too large and leaves the message at the head of the queue.</font>

<p><font face="Times">RCV_NOT_ENOUGH_MEMORY:&nbsp; The message to be received contains more out-of-line data than can be allocated in the receiving task.</font>

<p><font face="Times">RCV_TIMED_OUT:&nbsp; The message was not received after <i>timeout</i> milliseconds.</font>

<p><font face="Times">RCV_INTERRUPTED:&nbsp; A software interrupt occurred and the RCV_INTERRUPT option was specified.</font>

<p><font face="Times">RCV_PORT_CHANGE:&nbsp; The port specified was added to a port set during the duration of the <b>msg_receive()</b> call.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>msg_rpc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Send and receive a message</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;mach/message.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">msg_return_t <b>msg_rpc(</b>msg_header_t *<i>header</i>, msg_option_t <i>option</i>, msg_size_t <i>rcv_size</i>, msg_timeout_t <i>send_timeout</i>, msg_timeout_t <i>rcv_timeout</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>header</i>:&nbsp; Address of a message buffer that will be used for both <b>msg_send()</b> and <b>msg_receive()</b>.&nbsp; This buffer contains a message header followed by the data for the message to be sent.&nbsp; The <b>msg_remote_port</b> field specifies the port to which the message is to be sent.&nbsp; The <b>msg_local_port</b> field specifies the port on which a message is then to be received; if this port is the special value PORT_DEFAULT, it gets replaced by the value PORT_NULL for the purposes of the <b>msg_send()</b> operation.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>option</i>:&nbsp; A union of the <i>option</i> arguments for the send and receive (see <b>msg_send()</b> and <b>msg_receive()</b>).</font>

<p><font face="Times"><i>rcv_size</i>:&nbsp; The maximum size allowed for the received message; this must be less than or equal to the size of the message buffer. The <b>msg_size</b> field in the header specifies the size of the message to be sent.</font>

<p><font face="Times"><i>send_timeout</i>, <i>rcv_timeout</i>:&nbsp; The timeout values to be applied to the component operations.&nbsp; These are used only if the option SEND_TIMEOUT or RCV_TIMEOUT is specified.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>msg_rpc()</b> is a hybrid call that performs a <b>msg_send()</b> followed by a <b>msg_receive()</b>, using the same message buffer.&nbsp; Because of the order of the send and receive, this function is appropriate for clients of Mach servers.&nbsp; However, the <b>msg_rpc()</b> call to a Mach server is usually performed by MiG-generated code, not by handwritten code.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">See Chapter 2, &quot;Using Mach Messages,&quot; for information on setting up messages and on writing Mach servers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">RPC_SUCCESS:&nbsp; The message was successfully sent and a reply was received.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Other possible values are the same as those for <b>msg_send()</b> and <b>msg_receive()</b>; any error during the <b>msg_send()</b> portion will terminate the call.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>msg_send()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Send a message</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;mach/message.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">msg_return_t <b>msg_send(</b>msg_header_t *<i>header</i>, msg_option_t <i>option</i>, msg_timeout_t <i>timeout</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>header</i>:&nbsp; The address of the message to be sent.&nbsp; A message consists of a fixed-size header followed by a variable number of data descriptors and data items.&nbsp; See the header file <b>mach/message.h</b> for a definition of the message structure.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>option</i>:&nbsp; The failure conditions under which <b>msg_send()</b> should terminate.&nbsp; The value of this argument is a combination (using the bitwise OR operator) of the following options.&nbsp; Unless one of these values is explicitly specified, <b>msg_send()</b> does not return until the message is successfully queued for the intended receiver.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">SEND_TIMEOUT:&nbsp; Specifies that the <b>msg_send()</b> request should terminate after the timeout period has elapsed, even if the kernel has been unable to queue the message.</font>

<p><font face="Times">SEND_NOTIFY:&nbsp; Allows the sender to send exactly one message without being suspended even if the destination port is full.&nbsp; When that message can be posted to the receiving port queue, this task receives a message that notifies it that another message can be sent.&nbsp; If the sender tries to send a second message with this option to the same port before the first notification arrives, the result is an error.&nbsp; If both SEND_NOTIFY and SEND_TIMEOUT are specified, <b>msg_send()</b> will wait until the specified timeout has elapsed before invoking the SEND_NOTIFY option.</font>

<p><font face="Times">SEND_INTERRUPT:&nbsp; Specifies that <b>msg_send()</b> should return if a software interrupt occurs in this thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Use MSG_OPTION_NONE to specify that none of the above options is wanted.</font>

<p><font face="Times"><i>timeout</i>:&nbsp; If the destination port is full and the SEND_TIMEOUT option has been specified, this value specifies the maximum wait time (in milliseconds).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>msg_send()</b> transmits a message from the current task to the port specified in the message header field.&nbsp; The message consists of its header, followed by a variable number of data descriptors and data items.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If the <b>msg_local_port</b> field isn't set to PORT_NULL, send rights to that port will be passed to the receiver of this message.&nbsp; The receiver task can use that port to send a reply to this message.</font>

<p><font face="Times">If the SEND_NOTIFY option is used and this call returns a SEND_WILL_NOTIFY code, you can expect to receive a notify message from the kernel.&nbsp; This message will be either a NOTIFY_MSG_ACCEPTED or a NOTIFY_PORT_DELETED message, depending on what happened to the queued message.&nbsp; The <b>notify_port</b> field in these messages is the port to which the original message was sent.&nbsp; The formats for these messages are defined in the header file <b>sys/notify.h</b>.</font>

<p><font face="Times">See Chapter 2, &quot;Using Mach Messages,&quot; for information on setting up messages and on writing Mach servers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* From the handwritten part of a Mach server... */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">while (TRUE)</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">{</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Receive a request from a client. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">msg.head.msg_local_port = port;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">msg.head.msg_size = sizeof(struct message);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">ret = msg_receive(&amp;msg.head, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (ret != RCV_SUCCESS) /* ignore errors */;</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Feed the request into the server. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(void)add_server(&amp;msg, &amp;reply);</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Send a reply to the client. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">reply.head.msg_local_port = port;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">ret = msg_send(&amp;reply.head, MSG_OPTION_NONE, 0);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (ret != SEND_SUCCESS) /* ignore errors */;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">SEND_SUCCESS:&nbsp; The message has been queued for the destination port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">SEND_INVALID_MEMORY:&nbsp; The message header or body was not readable by the calling task, or the message body specified out-of-line data that was not readable.</font>

<p><font face="Times">SEND_INVALID_PORT:&nbsp; The message refers either to a port for which the current task does not have access, or to which access was explicitly removed from the current task (see <b>port_deallocate()</b>) while waiting for the message to be posted, or a <b>msg_type_name</b> field in the message specifies rights that the name doesn't denote in the task (for example, specifying MSG_TYPE_SEND and supplying a port set name).</font>

<p><font face="Times">SEND_TIMED_OUT:&nbsp; The message was not sent since the destination port was still full after <i>timeout</i> milliseconds.</font>

<p><font face="Times">SEND_WILL_NOTIFY:&nbsp; The destination port was full but the SEND_NOTIFY option was specified.&nbsp; A notification message will be sent when the message can be posted.</font>

<p><font face="Times">SEND_NOTIFY_IN_PROGRESS:&nbsp; The SEND_NOTIFY option was specified but a notification request is already outstanding for this thread and given destination port.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>port_allocate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_allocate(</b>task_t <i>task</i>, port_name_t *<i>port_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task in which the new port is created (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; Returns the name used by <i>task</i> for the new port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_allocate()</b> causes a port to be created for the specified task; the resulting port is returned in <i>port_name.</i>&nbsp; The target task initially has both send and receive rights to the port.&nbsp; The new port isn't a member of any port set.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myport;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t&nbsp; error;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((error=port_allocate(task_self(), &amp;myport)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; A port has been allocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid.</font>

<p><font face="Times">KERN_RESOURCE_SHORTAGE:&nbsp; No more port slots are available for this task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_deallocate()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_deallocate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Deallocate a port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_deallocate(</b>task_t <i>task</i>, port_name_t <i>port_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that wants to relinquish rights to the port (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>: The name that <i>task</i> uses for the port to be deallocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_deallocate()</b> requests that the target task's access to a port be relinquished.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If <i>task</i> has receive rights for the port and the port doesn't have a backup port, these things happen:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">The port is destroyed.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">All other tasks with send access to the port are notified of its destruction.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the port is a member of a port set, it's removed from the port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If <i>task</i> has receive rights for the port and the port <i>does</i> have a backup port, then the following things happen:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">If the port is a member of a port set, it's removed from the port set.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Send and receive rights for the port are sent to the backup port in a notification message (see <b>port_set_backup()</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_port;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t&nbsp; error;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_deallocate(task_self(), my_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_deallocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The port has been deallocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>port_name</i> doesn't name a valid port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_allocate()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_extract_receive()</b>, <b>port_extract_send()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Remove access rights to a port and return them to the caller</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_extract_receive(</b>task_t <i>task</i>, port_name_t <i>its_name</i>, port_t *<i>its_port</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>port_extract_send(</b>task_t <i>task</i>, port_name_t <i>its_name</i>, port_t *<i>its_port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task whose rights the caller takes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>its_name</i>:&nbsp; The name by which <i>task</i> knows the port.</font>

<p><font face="Times"><i>its_port</i>:&nbsp; Returns the receive or send rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The functions <b>port_extract_receive()</b> and <b>port_extract_send()</b> remove the port access rights that <i>task</i> has for a port and return the rights to the caller.&nbsp; This leaves <i>task</i> with no rights for the port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>port_extract_send()</b> function extracts send rights; <i>task</i> can't have receive rights for the named port.&nbsp; The <b>port_extract_receive()</b> function extracts receive rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>its_name</i> doesn't name a port for which <i>task</i> has the required rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_insert_send()</b>, <b>port_insert_receive()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_insert_receive()</b>, <b>port_insert_send()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Give a task rights with a specific name</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_insert_receive(</b>task_t <i>task</i>, port_t <i>my_port</i>, port_name_t <i>its_name</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>port_insert_send(</b>task_t <i>task</i>, port_t <i>my_port</i>, port_name_t <i>its_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task getting the new rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>my_port</i>:&nbsp; Rights supplied by the caller.</font>

<p><font face="Times"><i>its_name</i>:&nbsp; The name by which <i>task</i> will know the new rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The functions <b>port_insert_receive()</b> and <b>port_insert_send()</b> give a task rights with a specific name.&nbsp; If <i>task</i> already has rights named <i>its_name</i>, or has some other name for <i>my_port</i>, the operation will fail.&nbsp; The <i>its_name</i> argument can't be a predefined port, such as PORT_NULL.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>port_insert_send()</b> function inserts send rights, and <b>port_insert_receive()</b> inserts receive rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_NAME_EXISTS:&nbsp; <i>task</i> already has a right named <i>its_name</i>.</font>

<p><font face="Times">KERN_FAILURE:&nbsp; <i>task</i> already has rights to <i>my_port</i>.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>its_name</i> was an invalid name.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_extract_send()</b>, <b>port_extract_receive()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_names()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about the port name space of a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_names(</b>task_t <i>task</i>, port_name_array_t *<i>port_names</i>, unsigned int *<i>port_names_count</i>, port_type_array_t *<i>port_types</i>, unsigned int *<i>port_types_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task whose port name space is queried.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_names</i>:&nbsp; Returns the names of the ports and port sets in the port name space of <i>task</i>, in no particular order.</font>

<p><font face="Times"><i>port_names_count</i>:&nbsp; Returns the number of names returned.</font>

<p><font face="Times"><i>port_types</i>:&nbsp; Returns the type of each corresponding name.&nbsp; This indicates what kind of rights the task holds for the port, or whether the name refers to a port set.&nbsp; The type is one of the following:&nbsp; PORT_TYPE_SEND (send rights only), PORT_TYPE_RECEIVE_OWN (send and receive rights), PORT_TYPE_SET (the port is a port set).</font>

<p><font face="Times"><i>port_types_count</i>:&nbsp; Returns the same value as <i>port_names_count</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_names()</b> returns information about the port name space of <i>task</i>.&nbsp; It returns the port and port set names that are currently valid for <i>task</i>.&nbsp; For each name, it also returns what type of rights <i>task</i> holds.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <i>port_names</i> and <i>port_types</i> arguments are arrays that are automatically allocated when the reply message is received.&nbsp; You should use <b>vm_deallocate()</b> on them when the data is no longer needed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_name_array_t&nbsp; names;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; names_count, types_count;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_type_array_t&nbsp; types;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_names(task_self(), &amp;names, &amp;names_count, &amp;types,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;types_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_rename returned value of &#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=vm_deallocate(task_self(), (vm_address_t)names,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(names)*names_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing names&#34;, error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=vm_deallocate(task_self(), (vm_address_t)types,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(names)*types_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing types&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_type()</b>, <b>port_status()</b>, <b>port_set_status()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_rename()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Change the name by which a port or port set is known to a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_rename(</b>task_t <i>task</i>, port_name_t <i>old_name</i>, port_name_t <i>new_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task whose port name space is changed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>old_name</i>:&nbsp; The current name of the port or port set.</font>

<p><font face="Times"><i>new_name</i>:&nbsp; The new name for the port or port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_rename()</b> changes the name by which a port or port set is known to <i>task.</i>&nbsp; The port name specified in <i>new_name</i> must not already be in use, and it can't be a predefined port, such as PORT_NULL.&nbsp; Currently, a name is a small integer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">One way to guarantee that a name isn't already in use is to deallocate a port and then use its name as <i>new_name</i>.&nbsp; Another way is to check all the existing names, using <b>port_names()</b>, before you call <b>port_rename()</b>.&nbsp; If you choose another naming scheme, you should be prepared to try another name if <b>port_rename()</b> returns a KERN_NAME_EXISTS error.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">#define MY_PORT&nbsp; (port_name_t)99</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_name_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_port;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp; error;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_allocate(task_self(),&amp;my_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_rename(task_self(), my_port, MY_PORT);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error == KERN_NAME_EXISTS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* try again with a different name */;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;port_rename failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_NAME_EXISTS:&nbsp; <i>task</i> already has a port or port set named <i>new_name.</i></font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid, or <i>task</i> didn't know any ports or port sets named <i>old_name</i>, or <i>new_name </i>was an invalid name.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_names()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_set_add()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Move the named port into the named port set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_add(</b>task_t <i>task</i>, port_set_name_t <i>set_name</i>, port_name_t <i>port_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that has receive rights for the port set and port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>set_name</i>:&nbsp; <i>task</i>'s name for the port set.</font>

<p><font face="Times"><i>port_name</i>:&nbsp; <i>task</i>'s name for the port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_set_add()</b> moves the named port into the named port set.&nbsp; The <i>task</i> must have receive rights for the port.&nbsp; If the port is already a member of another port set, it's removed from that set first.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_set_name_t&nbsp; set_name;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_port;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_set_allocate(task_self(),&amp;set_name);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_set_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_allocate(task_self(),&amp;my_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_set_add(task_self(), set_name, my_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_NOT_RECEIVER:&nbsp; <i>task</i> doesn't have receive rights for the port<i>.</i></font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid, or <i>set_name</i> doesn't name a valid port set, or <i>port_name</i> doesn't name a valid port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_set_remove()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_set_allocate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a port set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_allocate(</b>task_t <i>task</i>, port_set_name_t *<i>set_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task in which the new port set is created.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>set_name</i>:&nbsp; Returns <i>task</i>'s name for the new port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_set_allocate()</b> causes a port set to be created for the specified task; the resulting set's name is returned in <i>set_name.</i>&nbsp; The new port set is empty.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_set_name_t&nbsp; set_name;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_set_allocate(task_self(),&amp;set_name);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_set_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid.</font>

<p><font face="Times">KERN_RESOURCE_SHORTAGE:&nbsp; The kernel ran out of memory.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_set_deallocate()</b>, <b>port_set_add()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_set_backlog()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the size of the port queue</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_backlog(</b>task_t <i>task</i>, port_name_t <i>port_name</i>, int <i>backlog</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that has receive rights for the named port (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; <i>task</i>'s name for the port.</font>

<p><font face="Times"><i>backlog</i>:&nbsp; The new backlog to be set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_set_backlog()</b> changes the backlog value on the specified port (the port's backlog value is the number of unreceived messages that are allowed in its message queue before the kernel will refuse to accept any more sends to that port).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The task specified by <i>task</i> must have receive rights for the named port.</font>

<p><font face="Times">The maximum backlog value is the constant PORT_BACKLOG_MAX.&nbsp; You can get a port's current backlog value by calling <b>port_status()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">#define MY_BACKLOG&nbsp; 10</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; error;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_port;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_allocate(task_self(),&amp;my_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_set_backlog(task_self(), my_port, MY_BACKLOG);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to port_set_backlog failed&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The backlog value has been changed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_NOT_RECEIVER:&nbsp; <i>task</i> doesn't have receive rights for the port.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid, or <i>port_name</i> doesn't name a valid port, or the desired backlog wasn't greater than 0, or the desired backlog was greater than PORT_BACKLOG_MAX.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>msg_send()</b>, <b>port_status()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_set_backup()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the backup port for a port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_backup(</b>task_t <i>task</i>, port_name_t <i>port_name</i>, port_t <i>backup</i>, port_t *<i>previous</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that has receive rights for the named port (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; <i>task</i>'s name for the port right.</font>

<p><font face="Times"><i>backup</i>:&nbsp; The new backup port.&nbsp; If you want to disable the current backup port without setting a new one, set this to PORT_NULL.</font>

<p><font face="Times"><i>previous</i>:&nbsp; Returns the previous backup port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Use this function to keep a port alive despite its being deallocated by its receiver.&nbsp; If the call to <b>port_set_backup()</b> is successful, then whenever <i>port_name</i> is deallocated by its receiver, <i>backup</i> will receive a notification message with receive and send rights for <i>port_name</i>.&nbsp; As far as <i>task</i> is concerned, the port will be deleted; however, as far as senders to the port are concerned, the port will continue to exist.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">To let a port die naturally after its backup port has been set, call <b>port_set_backup()</b> on it with <i>backup</i> set to PORT_NULL.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_port, backup_port, previous_port;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_allocate(task_self(),&amp;my_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_allocate(task_self(),&amp;backup_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_set_backup(task_self(), my_port, backup_port,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;previous_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to port_set_backlog failed&#34;, error);</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid, or <i>port_name</i> doesn't name a valid port.</font>

<p><font face="Times">KERN_NOT_RECEIVER:&nbsp; <i>task</i> doesn't have receive rights for <i>port_name</i>.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>port_set_deallocate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Destroy a port set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_deallocate(</b>task_t <i>task</i>, port_set_name_t <i>set_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that has receive rights for the port set to be destroyed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>set_name</i>:&nbsp; <i>task</i>'s name for the doomed port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_set_deallocate()</b> requests that the port set of <i>task</i> be destroyed.&nbsp; If the port set isn't empty, any members are first removed.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_set_name_t set_name;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=port_set_deallocate(task_self(),set_name);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_set_deallocate failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>set_name</i> doesn't name a valid port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_set_allocate()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_set_remove()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Remove the named port from a port set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_remove(</b>task_t <i>task</i>, port_name_t <i>port_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that has receive rights for the port and port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; <i>task</i>'s name for the receive rights to be removed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_set_remove()</b> removes the named port from a port set.&nbsp; The <i>task</i> must have receive rights for the port, and the port must be a member of a port set.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">error=port_set_remove(task_self(), my_port);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_set_remove failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_NOT_RECEIVER:&nbsp; <i>task</i> doesn't have receive rights for the port.</font>

<p><font face="Times">KERN_NOT_IN_SET:&nbsp; The port isn't a member of a set.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>port_name</i> doesn't name a valid port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_set_add()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_set_status()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the members of a port set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_set_status(</b>task_t <i>task</i>, port_set_name_t <i>set_name</i>, port_name_array_t *<i>members</i>, unsigned int *<i>members_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task whose port set is queried.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>set_name</i>:&nbsp; <i>task's</i> name for the port set.</font>

<p><font face="Times"><i>members</i>:&nbsp; Returns <i>task</i>'s names for the members of its port set.</font>

<p><font face="Times"><i>members_count</i>:&nbsp; Returns the number of port names in <i>members</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_set_status()</b> returns a list of the ports in a port set.&nbsp; The <i>members</i> argument is an array that's automatically allocated when the reply message is received.&nbsp; You should use <b>vm_deallocate()</b> on it when the data is no longer needed.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">error=port_set_status(task_self(), set_name, &amp;members,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=126 height=1><font face="Courier" size="-1">&amp;members_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_set_status failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=vm_deallocate(task_self(), (vm_address_t)members,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(members)*members_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing members&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>set_name</i> doesn't name a valid port set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_status()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_status()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Examine a port's current status</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_status(</b>task_t <i>task</i>, port_name_t <i>port_name</i>, port_set_name_t *<i>port_set_name</i>, int *<i>num_msgs</i>, int *<i>backlog</i>, boolean_t *<i>owner</i>, boolean_t *<i>receiver</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task that has receive rights for the port in question (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; <i>task</i>'s name for the port right.</font>

<p><font face="Times"><i>port_set_name</i>:&nbsp; Returns <i>task</i>'s name for the port set that the named port belongs to, or PORT_NULL if it isn't in a set.</font>

<p><font face="Times"><i>num_msgs</i>:&nbsp; Returns the number of messages queued on this port.&nbsp; If <i>task</i> isn't the port's receiver, the number of messages will be returned as negative.</font>

<p><font face="Times"><i>backlog</i>:&nbsp; Returns the number of messages that can be queued to this port without causing the sender to block.</font>

<p><font face="Times"><i>owner</i>:&nbsp; Returns the same value as <i>receiver</i>, since ownership rights and receive rights aren't separable.</font>

<p><font face="Times"><i>receiver</i>:&nbsp; Returns true if <i>task</i> has receive rights to <i>port_name</i>; otherwise, returns false.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_status()</b> returns the current port status associated with <i>port_name</i>.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">error=port_status(task_self(), my_port, &amp;port_set_name, &amp;num_msgs,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;backlog, &amp;owner, &amp;receiver);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to port_status failed&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The data has been retrieved.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>port_name</i> doesn't name a valid port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_set_backlog()</b>, <b>port_set_status()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>port_type()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Determine the access rights of a task for a specific port name</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>port_type(</b>task_t <i>task</i>, port_name_t <i>port_name</i>, port_type_t *<i>port_type</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task whose port name space is queried.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; The name being queried.</font>

<p><font face="Times"><i>port_type</i>:&nbsp; Returns a value that indicates what kind of rights the task holds for the port, or whether the name refers to a port set. This value is one of the following:&nbsp; PORT_TYPE_SEND (send rights only), PORT_TYPE_RECEIVE_OWN (send and receive rights), PORT_TYPE_SET (the port is a port set).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>port_type()</b> returns information about <i>task'</i>s rights for a specific name in its port name space.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">error=port_type(task_self(), port, &amp;type);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Couldn't get type of port&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> was invalid or <i>task</i> didn't have any rights named <i>port_name</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>port_names()</b>, <b>port_status()</b>, <b>port_set_status()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>processor_assign(), processor_control(), processor_exit(), processor_get_assignment(), processor_start()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Control a processor</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_assign(</b>processor_t <i>processor</i>, processor_set_t <i>new_processor_set</i>, boolean_t <i>wait</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>processor_control(</b>processor_t <i>processor</i>, processor_info_t <i>info</i>, long *<i>count</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>processor_exit(</b>processor_t <i>processor</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>processor_get_assignment(</b>processor_t <i>processor</i>, processor_set_t *<i>processor_set</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>processor_start(</b>processor_t <i>processor</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>processor_assign()</b> changes the processor set to which <i>processor</i> is assigned.&nbsp; <b>processor_control()</b> returns information about <i>processor</i>.&nbsp; <b>processor_exit()</b> shuts down <i>processor</i>.&nbsp; <b>processor_get_assignment()</b> returns the processor set to which <i>processor </i>is assigned.&nbsp; <b>processor_start()</b> starts up <i>processor</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">These functions are useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>processor_info()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about a processor</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_info(</b>processor_t <i>processor</i>, int <i>flavor</i>, host_t *<i>host</i>, processor_info_t <i>processor_info</i>, unsigned int *<i>processor_info_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>processor</i>:&nbsp; The processor for which information is to be obtained.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>flavor</i>:&nbsp; The type of information that is wanted.&nbsp; Currently only PROCESSOR_BASIC_INFO is implemented.</font>

<p><font face="Times"><i>host</i>:&nbsp; Returns the non-privileged host port for the host on which the processor resides.</font>

<p><font face="Times"><i>processor_info</i>:&nbsp; Returns information about the processor specified by <i>processor</i>.</font>

<p><font face="Times"><i>processor_info_count</i>:&nbsp; Size of the info structure.&nbsp; Should be PROCESSOR_BASIC_INFO_COUNT when <i>flavor</i> is PROCESSOR_BASIC_INFO.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns the selected information array for a processor, as specified by <i>flavor</i>.&nbsp; The <i>processor_info</i> argument is an array of integers that is supplied by the caller and filled with specified information.&nbsp; The <i>processor_info_count</i> argument is supplied as the maximum number of integers in <i>processor_info</i>.&nbsp; On return, it contains the actual number of integers in <i>processor_info</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Basic information is defined by PROCESSOR_BASIC_INFO.&nbsp; The size of this information is defined by PROCESSOR_BASIC_INFO_COUNT.&nbsp; The data structures used by PROCESSOR_BASIC_INFO are defined in the header file <b>mach/processor_info.h</b>.&nbsp; Possible values of the <b>cpu_type</b> and <b>cpu_subtype</b> fields are defined in the header file <b>mach/machine.h</b>.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef int *processor_info_t;&nbsp; /* variable length array of int */</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">/* one interpretation of info is */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct processor_basic_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">cpu_type_t&nbsp;&nbsp;&nbsp;&nbsp; cpu_type;&nbsp;&nbsp;&nbsp; /* cpu type */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">cpu_subtype_t&nbsp; cpu_subtype; /* cpu subtype */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">boolean_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; running;&nbsp;&nbsp;&nbsp;&nbsp; /* is processor running? */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slot_num;&nbsp;&nbsp;&nbsp; /* slot number */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">boolean_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_master;&nbsp;&nbsp; /* is this the master processor */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct processor_basic_info *processor_basic_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">host_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_size, info_count;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct processor_basic_info&nbsp;&nbsp;&nbsp; info;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_array_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Get the processor port. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processors(host_priv_self(), &amp;list, &amp;list_size);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((error!=KERN_SUCCESS) || (list_size &lt; 1)){</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling host_processors (are you root?)&#34;,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Get information about the processor. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">info_count=PROCESSOR_BASIC_INFO_COUNT;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_info(list[0], PROCESSOR_BASIC_INFO, &amp;host,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(processor_info_t)&amp;info, &amp;info_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_info&#34;, error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Now that we're done with the processor port, free it. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_deallocate(task_self(), (vm_address_t)list,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(list)*list_size);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing list&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>processor</i> isn't a known processor.</font>

<p><font face="Times">MIG_ARRAY_TOO_LARGE:&nbsp; Returned info array is too large for <i>processor_info</i>.&nbsp; The <i>processor_info</i> argument is filled as much as possible, and <i>processor_info_count</i> is set to the number of elements that would be returned if there were enough room.</font>

<p><font face="Times">KERN_FAILURE:&nbsp; <i>flavor</i> isn't recognized or <i>processor_info_count</i> is too small.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>processor_start()</b>, <b>processor_exit()</b>, <b>processor_control()</b>, <b>host_processors()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>processor_set_create()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a new processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_create(</b>host_t <i>host</i>, port_t *<i>new_set</i>, port_t *<i>new_name</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function creates a new processor set on <i>host</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">This function is useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>processor_set_default()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the port of the default processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_default(</b>host_t <i>host</i>, processor_set_t *<i>default_set</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>host</i>:&nbsp; The host whose default processor set is requested.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>default_set</i>:&nbsp; Returns the name (nonprivileged) port for the default processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The default processor set is used by all threads, tasks, and processors that aren't explicitly assigned to other sets.&nbsp; This function returns a port that can be used to obtain information about this set (for example, how many threads are assigned to it).&nbsp; This port isn't privileged and thus can't be used to perform operations on that set; call <b>host_processor_set_priv()</b> after <b>processor_set_default()</b> to get the privileged port.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS){</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>host</i> is not a host.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>processor_set_info()</b>, <b>task_assign()</b>, <b>thread_assign()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>processor_set_destroy()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Delete a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_destroy(</b>processor_set_t <i>processor_set</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function destroys <i>processor_set</i>, reassigning all of its tasks, threads, and processors to the default processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">This function is useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>processor_set_info()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_info(</b>processor_set_t <i>processor_set</i>, int <i>flavor</i>, host_t *<i>host</i>, processor_set_info_t <i>processor_set_info</i>, unsigned int *<i>processor_set_info_count</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>processor_set</i>:&nbsp; The processor set for which information is to be obtained.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>flavor</i>:&nbsp; The type of information that is wanted.&nbsp; Should be PROCESSOR_SET_BASIC_INFO or PROCESSOR_SET_SCHED_INFO.</font>

<p><font face="Times"><i>host</i>:&nbsp; Returns the nonprivileged host port for the host on which the processor set resides.</font>

<p><font face="Times"><i>processor_set_info</i>:&nbsp; Returns information about the processor set specified by <i>processor_set</i>.</font>

<p><font face="Times"><i>processor_set_info_count</i>:&nbsp; Size of the info structure.&nbsp; Should be PROCESSOR_SET_BASIC_INFO_COUNT when <i>flavor</i> is PROCESSOR_SET_BASIC_INFO, and PROCESSOR_SET_SCHED_INFO_COUNT when <i>flavor</i> is PROCESSOR_SET_SCHED_INFO.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns the selected information array for a processor set, as specified by <i>flavor</i>.&nbsp; The <i>processor_set_info</i> argument is an array of integers that is supplied by the caller, and filled with specified information.&nbsp; The <i>processor_set_info_count</i> argument is supplied as the maximum number of integers in <i>processor_set_info</i>.&nbsp; On return, it contains the actual number of integers in <i>processor_set_info</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Basic information is defined by PROCESSOR_SET_BASIC_INFO.&nbsp; The size of this information is defined by PROCESSOR_SET_BASIC_INFO_COUNT.&nbsp; The <b>load_average</b> and <b>mach_factor</b> fields are scaled by the constant LOAD_SCALE (that is, the integer value returned is the load average or Mach factor multiplied by LOAD_SCALE).</font>

<p><font face="Times">The <i>Mach factor</i>, like the UNIX load average, is a measurement of how busy the system is.&nbsp; Unlike the load average, higher Mach factors mean that the system is less busy.&nbsp; The Mach factor tells you how much of a CPU you have available for running an application.&nbsp; For example, on a single-processor system with one job running, the Mach factor is 0.5; this means if another job starts running it will get half of the CPU.&nbsp; (Two jobs will be running, each getting half the CPU.)&nbsp; On a single-processor system, the Mach factor is between zero and one.&nbsp; On a multiprocessor system, the Mach factor can go over one.&nbsp; For example, a three-processor system with one job running has a Mach factor of 2.0, since two processors are available to new jobs.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct processor_set_basic_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; processor_count;&nbsp;&nbsp; /* number of processors */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; task_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of tasks */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; thread_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of threads */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; load_average;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* scaled load average */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; mach_factor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* scaled mach factor */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct processor_set_basic_info *processor_set_basic_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Scheduling information is defined by PROCESSOR_SET_SCHED_INFO.&nbsp; The size of this information is given by PROCESSOR_SET_SCHED_INFO_COUNT.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct processor_set_sched_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; policies;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* allowed policies */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp; max_priority;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* max priority for new threads */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct processor_set_sched_info *processor_set_sched_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">host_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_count;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct processor_set_basic_info&nbsp; info;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default_set;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS){</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">info_count=PROCESSOR_SET_BASIC_INFO_COUNT;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_info(default_set, PROCESSOR_SET_BASIC_INFO,</font><br>
<img src="../../../Images/sp.gif" width=126 height=1><font face="Courier" size="-1">&amp;host, (processor_set_info_t)&amp;info, &amp;info_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_info&#34;, error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;The UNIX load average is %f\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(float)info.load_average/LOAD_SCALE);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;The Mach factor is %f\n&#34;, (float)info.mach_factor/LOAD_SCALE);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>processor_set</i> is not a processor set, or <i>flavor</i> is not recognized.</font>

<p><font face="Times">KERN_FAILURE:&nbsp; <i>processor_set_info_count</i> is less than what it should be.</font>

<p><font face="Times">MIG_ARRAY_TOO_LARGE:&nbsp; Returned info array is too large for <i>processor_set_info</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>processor_set_create()</b>, <b>processor_set_default()</b>, <b>processor_assign()</b>, <b>task_assign()</b>, <b>thread_assign()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>processor_set_max_priority()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the maximum priority permitted on a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_max_priority(</b>processor_set_t <i>processor_set</i>, int <i>max_priority</i>, boolean_t <i>change_threads</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function affects only newly created or newly assigned threads unless you specify <i>change_threads</i> as true.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">This function is useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>processor_set_policy_enable(), processor_set_policy_disable()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Enable or disable a scheduling policy on a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_policy_enable(</b>processor_set_t <i>processor_set</i>, int <i>policy</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>processor_set_policy_disable(</b>processor_set_t <i>processor_set</i>, int <i>policy</i>, boolean_t <i>change_threads</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>processor_set</i>:&nbsp; The processor set whose allowed policies are to be changed.&nbsp; This must be the privileged processor set port, which is returned by <b>host_processor_set_priv()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>policy</i>:&nbsp; The policy to enable or disable.&nbsp; Currently, the only valid policies are POLICY_TIMESHARE, POLICY_INTERACTIVE, and POLICY_FIXEDPRI.&nbsp; You can't disable timesharing.</font>

<p><font face="Times"><i>change_threads</i>:&nbsp; Specify true if you want to reset to timesharing the policies of any threads with the newly disallowed policy. Otherwise, specify false.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Processor sets may restrict the scheduling policies to be used for threads assigned to them.&nbsp; These two calls provide the mechanism for designating permitted and forbidden policies.&nbsp; The current set of permitted policies can be obtained from <b>processor_set_info()</b>.&nbsp; Timesharing can't be forbidden by any processor set.&nbsp; This is a compromise to reduce the complexity of the assign operation; any thread whose policy is forbidden by the target processor set has its policy reset to timesharing.&nbsp; If the <i>change_threads</i> argument to <b>processor_set_policy_disable()</b> is true, threads currently assigned to this processor set and using the newly disabled policy will have their policy reset to timesharing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">Don't use POLICY_FIXEDPRI unless you're familiar with the consequences of fixed-priority scheduling.&nbsp; Using fixed-priority scheduling in a process can keep other processes from getting any CPU time.&nbsp; If processes that are essential to the functioning of the system don't get CPU time, you might have to reboot your system to make it work normally.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t&nbsp; default_set, default_set_priv;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_policy_enable(default_set_priv, POLICY_FIXEDPRI);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_policy_enable&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Operation completed successfully.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>processor_set</i> isn't the privileged port of a processor set, <i>policy</i> isn't a valid policy, or an attempt was made to disable timesharing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_policy()</b>, <b>thread_switch()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>processor_set_tasks()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get kernel ports for tasks assigned to a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_tasks(</b>processor_set_t <i>processor_set</i>, task_array_t *<i>task_list</i>, unsigned int *<i>task_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>processor_set</i>:&nbsp; The processor set to be affected.&nbsp; This must be the privileged processor set port, which is returned by <b>host_processor_set_priv()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>task_list</i>:&nbsp; Returns the set of tasks currently assigned to <i>processor_set</i>; no particular ordering is guaranteed.</font>

<p><font face="Times"><i>task_count</i>:&nbsp; Returns the number of tasks in <i>task_list</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function gets send rights to the kernel port for each task currently assigned to <i>processor_set</i>.&nbsp; The <i>task_list</i> argument is an array that is created as a result of this call.&nbsp; You should call <b>vm_deallocate()</b> on this array when you no longer need the data.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">task_array_t&nbsp;&nbsp;&nbsp; task_list;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp; task_count;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t default_set, default_set_priv;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; error;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_tasks(default_set_priv, &amp;task_list, &amp;task_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to processor_set_tasks() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=vm_deallocate(task_self(), (vm_address_t)task_list,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(task_list)*task_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing task_list&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>processor_set</i> isn't a privileged processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_assign()</b>, <b>thread_assign()</b>, <b>processor_set_threads()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>processor_set_threads()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get kernel ports for threads assigned to a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>processor_set_threads(</b>processor_set_t <i>processor_set</i>, thread_array_t *<i>thread_list</i>, unsigned int *<i>thread_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>processor_set</i>:&nbsp; The processor set to be affected.&nbsp; This must be the privileged processor set port, which is returned by <b>host_processor_set_priv()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>thread_list</i>:&nbsp; Returns the set of threads currently assigned to <i>processor_set</i>; no particular ordering is guaranteed.</font>

<p><font face="Times"><i>thread_count</i>:&nbsp; Returns the number of threads in <i>thread_list</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function gets send rights to the kernel port for each thread currently assigned to <i>processor_set</i>.&nbsp; The <i>thread_list</i> argument is an array that is created as a result of this call.&nbsp; You should call <b>vm_deallocate()</b> on <i>thread_list</i> when you no longer need the data.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">thread_array_t&nbsp; thread_list;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp; thread_count;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t default_set, default_set_priv;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; error;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_threads(default_set_priv, &amp;thread_list, &amp;thread_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to processor_set_threads() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=vm_deallocate(task_self(), (vm_address_t)thread_list,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(thread_list)*thread_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing thread_list&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>processor_set</i> isn't a privileged processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_assign()</b>, <b>thread_assign()</b>, <b>processor_set_tasks()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_assign(), task_assign_default()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Assign a task to a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_assign(</b>task_t <i>task</i>, processor_set_t <i>new_processor_set</i>, boolean_t <i>assign_threads</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>task_assign_default(</b>task_t <i>task</i>, boolean_t <i>assign_threads</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The <b>task_assign()</b> function assigns <i>task</i> to <i>new_processor_set</i>; <b>task_assign_default()</b> assigns <i>task</i> to the default processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">These functions are useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>task_by_unix_pid()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the task port for a UNIX process on the same host</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_by_unix_pid(</b>task_t <i>task</i>, int <i>pid</i>, task_t *<i>result_task</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; A task that is used to check permission (usually <b>task_self()</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>pid</i>:&nbsp; The process ID of the desired process.</font>

<p><font face="Times"><i>result_task</i>:&nbsp; Returns send rights to the task port of the process specified by <i>pid</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns the task port for another process, named by its process ID, on the same host as <i>task</i>.&nbsp; This call succeeds only if the caller is the superuser or <i>task</i> has the same user ID as the process specified by <i>pid</i>.&nbsp; If the call fails, <i>result_task</i> is set to TASK_NULL.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">pid=fork();</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (pid==0) /* We're in the child. */ {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* do childish things */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else /* We're in the parent */ {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">result=task_by_unix_pid(task_self(), pid, &amp;child_task);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (result != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;task_by_unix_pid&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_FAILURE:&nbsp; <i>target_task</i> has a different user ID from the process corresponding to <i>pid,</i> and the caller isn't the superuser; or <i>pid</i> didn't refer to a valid process; or <i>target_task</i> wasn't a valid task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>unix_pid()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_create()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_create(</b>task_t <i>parent_task</i>, boolean_t <i>inherit_memory</i>, task_t *<i>child_task</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>parent_task</i>:&nbsp; The task from which the child's capabilities are drawn.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>inherit_memory</i>:&nbsp; If set, the address space of the child task is built from the parent task according to its memory inheritance values; otherwise, the child task is given an empty address space.</font>

<p><font face="Times"><i>child_task</i>:&nbsp; Returns the new task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_create()</b> creates a new task from <i>parent_task</i>; the resulting task (<i>child_task</i>) acquires shared or copied parts of the parent's address space (see <b>vm_inherit()</b>).&nbsp; The child task initially has no threads; you put threads in it using <b>thread_create()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Important:</b></font>&nbsp; <font face="Times">Normally, you should use the UNIX <b>fork()</b> system call instead of <b>task_create()</b>.</font>

<p><font face="Times">The child task gets the four special ports initialized for it at task creation.&nbsp; The kernel port (task port) is created, and send rights for it are given to the child and returned to the caller in <i>child_task</i>.&nbsp; The notify port is initialized to null.&nbsp; The child inherits its bootstrap and exception ports from the parent task.&nbsp; The new task can get send rights to these ports with the call <b>task_get_special_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">error=task_create(task_self(), TRUE, &amp;child_task);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if(error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to task_create() failed&#34;, error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; A new task has been created.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>parent_task</i> is not a valid task port.</font>

<p><font face="Times">KERN_RESOURCE_SHORTAGE:&nbsp; Some critical kernel resource is unavailable.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_terminate()</b>, <b>task_suspend()</b>, <b>task_resume()</b>, <b>task_get_special_port()</b>, <b>task_set_special_port()</b>, <b>task_self()</b>, <b>task_threads()</b>, <b>thread_create()</b>, <b>thread_resume()</b>, <b>vm_inherit()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_get_assignment()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the name of the processor set that a task is assigned to</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_get_assignment(</b>task_t <i>task</i>, processor_set_t *<i>processor_set</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">This function is useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>task_get_special_port(), task_set_special_port(), task_self(), task_notify()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get or set a task's special ports</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_get_special_port(</b>task_t <i>task</i>, int <i>which_port</i>, port_t *<i>special_port</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>task_set_special_port(</b>task_t <i>task</i>, int <i>which_port</i>, port_t <i>special_port</i><b>)</b></font><br>
<font face="Times">task_t <b>task_self(</b>void<b>)</b></font><br>
<font face="Times">port_t <b>task_notify(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; The task to get the port for.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>which_port</i>:&nbsp; The port that's requested.&nbsp; This is one of:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">TASK_NOTIFY_PORT</font><br>
<font face="Times">TASK_BOOTSTRAP_PORT</font><br>
<font face="Times">TASK_EXCEPTION_PORT</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>special_port</i>:&nbsp; The value of the port that's being requested or set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_get_special_port()</b> returns send rights to one of a set of special ports for the task specified by <i>task.</i>&nbsp; In the case of the task's own notify port, the task also gets receive rights.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function <b>task_set_special_port()</b> sets one of a set of special ports for the task specified by <i>task</i>.</font>

<p><font face="Times">The function <b>task_self()</b> returns the port to which kernel calls for the currently executing thread should be directed.&nbsp; Currently, <b>task_self()</b> returns the task kernel port, which is a port for which the kernel has receive rights and which it uses to identify a task.&nbsp; In the future it may be possible for one task to interpose a port as another task's kernel port.&nbsp; At that time <b>task_self()</b> will still return the port to which the executing thread should direct kernel calls, but it may no longer be a port for which the kernel has receive rights.</font>

<p><font face="Times">If a controller task has send access to the kernel port of a subject task, then the controller task can perform kernel operations for the subject task.&nbsp; Normally, only the task itself and the task that created it will have access to the task kernel port, but any task may pass rights to its kernel port to any other task.</font>

<p><font face="Times">The function <b>task_notify()</b> returns receive and send rights to the notify port associated with the task to which the executing thread belongs.&nbsp; The notify port is a port on which the task should receive notification of such kernel events as the destruction of a port to which it has send rights.</font>

<p><font face="Times">The other special ports associated with a task are the bootstrap port and the exception port.&nbsp; The bootstrap port is a port to which a thread may send a message requesting other system service ports.&nbsp; This port isn't used by the kernel.&nbsp; The task's exception port is the port to which messages are sent by the kernel when an exception occurs and the thread causing the exception has no exception port of its own.</font>

<p><font face="Helvetica"><b>Important:</b></font>&nbsp; <font face="Times">If you set your task's bootstrap port, you should also set the global variable <b>bootstrap_port</b> to <i>special_port</i>.&nbsp; The <b>bootstrap_port</b> variable is task-wide and is used by <b>mach_init</b> and other processes to determine your task's bootstrap port. Since you can't change the value of the <b>bootstrap_port</b> variable in another task, you should use care when changing the bootstrap port of another task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>MACRO

<p><br><br>

<p></b></font><font face="Helvetica" size="-1"><b>EQUIVALENTS </b></font><font face="Times">The following macros are defined in the header file <b>mach/task_special_ports.h</b>:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times"><b>task_get_notify_port(</b><i>task</i>, <i>port</i><b>)</b></font><br>
<font face="Times"><b>task_set_notify_port(</b><i>task</i>, <i>port</i><b>)</b></font>

<p><font face="Times"><b>task_get_exception_port(</b><i>task</i>, <i>port</i><b>)</b></font><br>
<font face="Times"><b>task_set_exception_port(</b><i>task</i>, <i>port</i><b>)</b></font>

<p><font face="Times"><b>task_get_bootstrap_port(</b><i>task</i>, <i>port</i><b>)</b></font><br>
<font face="Times"><b>task_set_bootstrap_port(</b><i>task</i>, <i>port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Save the old exception port for this task. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = task_get_exception_port(task_self(), &amp;(ports.old_exc_port));</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;task_get_exception_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Create a new exception port for this task. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = port_allocate(task_self(), &amp;(ports.exc_port));</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;port_allocate 0&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = task_set_exception_port(task_self(), (ports.exc_port));</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;task_set_exception_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The port was returned or set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; Either <i>task</i> is not a task or <i>which_port</i> is an invalid port selector.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_special_ports()</b>, <b>task_create()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_info()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_info(</b>task_t <i>target_task</i>, int <i>flavor</i>, task_info_t <i>task_info</i>, unsigned int *<i>task_info_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task to be affected (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>flavor</i>:&nbsp; The type of statistics that are wanted.&nbsp; Currently only TASK_BASIC_INFO is implemented.</font>

<p><font face="Times"><i>task_info</i>:&nbsp; Returns statistics about <i>target_task</i>.</font>

<p><font face="Times"><i>task_info_count</i>:&nbsp; Size of the info structure.&nbsp; Currently this must be TASK_BASIC_INFO_COUNT.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_info()</b> returns the information specified by <i>flavor</i> about a task<i>.</i>&nbsp; The <i>task_info</i> argument is an array of integers that's supplied by the caller and returned filled with information.&nbsp; The <i>task_info_count</i> argument is supplied as the maximum number of integers in <i>task_info.</i>&nbsp; On return, it contains the actual number of integers in <i>task_info</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Currently there's only one flavor of information, defined by TASK_BASIC_INFO.&nbsp; Its size is defined by TASK_BASIC_INFO_COUNT.&nbsp; The definition of the information structure returned by TASK_BASIC_INFO is:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct task_basic_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspend_count;&nbsp; /* suspend count for task */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_priority;&nbsp; /* base scheduling priority */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">vm_size_t&nbsp;&nbsp;&nbsp;&nbsp; virtual_size;&nbsp;&nbsp; /* number of virtual pages */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">vm_size_t&nbsp;&nbsp;&nbsp;&nbsp; resident_size;&nbsp; /* number of resident pages */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">time_value_t&nbsp; user_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* total user run time for</font><br>
<img src="../../../Images/sp.gif" width=383 height=1><font face="Courier" size="-1">terminated threads */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">time_value_t&nbsp; system_time;&nbsp;&nbsp;&nbsp; /* total system run time for</font><br>
<img src="../../../Images/sp.gif" width=383 height=1><font face="Courier" size="-1">terminated threads */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct task_basic_info&nbsp; *task_basic_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct task_basic_info&nbsp;&nbsp;&nbsp; info;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_count=TASK_BASIC_INFO_COUNT;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=task_info(task_self(), TASK_BASIC_INFO,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(task_info_t)&amp;info, &amp;info_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling task_info()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Base priority is %d\n&#34;, info.base_priority);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_task</i> isn't a task, or <i>flavor</i> isn't recognized.</font>

<p><font face="Times">MIG_ARRAY_TOO_LARGE:&nbsp; The returned info array is too large for <i>task_info</i>.&nbsp; The <i>task_info</i> argument is filled as much as possible, and <i>task_info_count</i> is set to the number of elements that would be returned if there were enough room.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_threads()</b>, <b>thread_info()</b>, <b>thread_get_state()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_priority()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the scheduling priority for a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_priority(</b>task_t <i>task</i>, int <i>priority</i>, boolean_t <i>change_threads</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>task</i>:&nbsp; Task to set priority for.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>priority</i>:&nbsp; New priority.</font>

<p><font face="Times"><i>change_threads</i>:&nbsp; Change priority of existing threads if true.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The priority of a task is used only for creation of new threads; the priority of a new thread priority is set to that of its task.&nbsp; The <b>task_priority()</b> function changes this task priority.&nbsp; It also sets the priorities of all threads in the task to this new priority if <i>change_threads</i> is true.&nbsp; Existing threads are not affected otherwise.&nbsp; If this priority change violates the maximum priority of some threads, as many threads as possible will be changed and an error code will be returned.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Priorities range from 0 to 31, where higher numbers denote higher priorities.&nbsp; You can retrieve the current scheduling priority using <b>thread_info()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct task_basic_info&nbsp;&nbsp;&nbsp; info;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_count=TASK_BASIC_INFO_COUNT;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=task_info(task_self(), TASK_BASIC_INFO,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(task_info_t)&amp;info, &amp;info_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling task_info()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Set this task's base priority to be much lower than normal */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">error = task_priority(task_self(), info.base_priority - 4, TRUE);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;Call to task_priority() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>task</i> is not a task, or <i>priority</i> is not a valid priority.</font>

<p><font face="Times">KERN_FAILURE:&nbsp; <i>change_threads</i> was true and the attempt to change the priority of at least one existing thread failed because the new priority would have exceeded that thread's maximum priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_priority()</b>, <b>processor_set_max_priority()</b>, <b>thread_switch()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_resume()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Resume a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_resume(</b>task_t <i>target_task</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task to be resumed.</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_resume()</b> decrements the task's suspend count.&nbsp; If the suspend count becomes 0, all threads with 0 suspend counts in the task are resumed.&nbsp; If the suspend count is already 0, it's not decremented (it never becomes negative).</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The task has been resumed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_FAILURE:&nbsp; The suspend count is already 0.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_task</i> isn't a task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_create()</b>, <b>task_terminate()</b>, <b>task_suspend()</b>, <b>task_info()</b>, <b>thread_suspend()</b>, <b>thread_resume()</b>, <b>thread_info()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_suspend()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Suspend a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_suspend(</b>task_t <i>target_task</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task to be suspended (for example, use <b>task_self()</b> to specify the caller's task).</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_suspend()</b> increments the task's suspend count and stops all threads in the task.&nbsp; As long as the suspend count is positive, newly created threads will not run.&nbsp; This call doesn't return until all threads are suspended.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If the count becomes greater than 1, it will take more than one <b>task_resume()</b> call to restart the task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The task has been suspended.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_task</i> isn't a task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_create()</b>, <b>task_terminate()</b>, <b>task_resume()</b>, <b>task_info()</b>, <b>thread_suspend()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_terminate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Terminate a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_terminate(</b>task_t <i>target_task</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task to be destroyed (for example, use <b>task_self()</b> to specify the caller's task).</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_terminate()</b> destroys the task specified by <i>target_task</i> and all its threads.&nbsp; All resources that are used only by this task are freed.&nbsp; Any port to which this task has receive rights is destroyed.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The task has been destroyed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_task</i> isn't a task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_create()</b>, <b>task_suspend()</b>, <b>task_resume()</b>, <b>thread_terminate()</b>, <b>thread_suspend()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>task_threads()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get a task's threads</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>task_threads(</b>task_t <i>target_task</i>, thread_array_t *<i>thread_list</i>, unsigned int *<i>thread_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task to be affected (for example, use <b>task_self()</b> to specify the caller's task).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>thread_list</i>:&nbsp; Returns the set of threads contained within <i>target_task</i>; no particular ordering is guaranteed.</font>

<p><font face="Times"><i>thread_count</i>:&nbsp; Returns the number of threads in <i>thread_list</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>task_threads()</b> gets send rights to the kernel port for each thread contained in <i>target_task</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The array <i>thread_list</i> is created as a result of this call.&nbsp; You should call <b>vm_deallocate()</b> on this array when the data is no longer needed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">r = task_threads(task_self(), &amp;thread_list, &amp;thread_count);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling task_threads&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (thread_count == 1)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf (&#34;There's 1 thread in this task\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf(&#34;There are %d threads in this task\n&#34;, thread_count);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Deallocate the list of threads. */</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">r = vm_deallocate(task_self(), (vm_address_t)thread_list,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">sizeof(thread_list)*thread_count);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing thread_list&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_task</i> isn't a task.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_create()</b>, <b>thread_terminate()</b>, <b>thread_suspend()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_abort()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Interrupt a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_abort(</b>thread_t <i>target_thread</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_thread</i>:&nbsp; The thread to be interrupted.</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_abort()</b> aborts page faults and the kernel functions <b>msg_send()</b>, <b>msg_receive()</b>, and <b>msg_rpc()</b>, making the call return a code indicating that it was interrupted.&nbsp; The call is interrupted whether or not the thread (or task containing it) is currently suspended.&nbsp; If it's suspended, the thread receives the interrupt when it resumes.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A thread will retry an aborted page fault if its state isn't modified before it resumes.&nbsp; The function <b>msg_send()</b> returns SEND_INTERRUPTED; <b>msg_receive()</b> returns RCV_INTERRUPTED; and <b>msg_rpc()</b> returns either SEND_INTERRUPTED or RCV_INTERRUPTED, depending on which half of the RPC was interrupted.</font>

<p><font face="Times">This function lets one thread stop another thread cleanly, thereby allowing the future execution of the target thread to be controlled in a predictable way.&nbsp; The <b>thread_suspend()</b> function keeps the target thread from executing any further instructions at the user level, including the return from a system call.&nbsp; The <b>thread_get_state()</b> and <b>thread_set_state()</b> functions let you examine or modify the user state of a target thread.&nbsp; However, if a suspended thread was executing within a system call, it also has associated with it a kernel state.&nbsp; This kernel state can't be modified by <b>thread_set_state()</b>; therefore, when the thread is resumed the system call may return, changing the user state and possibly user memory.</font>

<p><font face="Times">The <b>thread_abort()</b> function aborts the kernel call from the target thread's point of view by resetting the kernel state so that the thread will resume execution just after the system call.&nbsp; The system call will return one of the interrupted codes described previously.&nbsp; The system call will either be entirely completed or entirely aborted, depending on the precise moment at which the abort was received.&nbsp; Thus if the thread's user state has been changed by <b>thread_set_state()</b>, it won't be modified by any unexpected system call side effects.</font>

<p><font face="Times">For example, to simulate a UNIX signal, the following sequence of calls may be used:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">1.</font></td>

<td><font face="Times"><b>thread_suspend()</b>--Stops the thread.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">2.</font></td>

<td><font face="Times"><b>thread_abort()</b>--Interrupts any system call in progress, setting the return value to &quot;interrupted.&quot;&nbsp; Since the thread is stopped, it won't return to user code.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">3.</font></td>

<td><font face="Times"><b>thread_set_state()</b>--Alters the thread's state to simulate a procedure call to the signal handler.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica">4.</font></td>

<td><font face="Times"><b>thread_resume()</b>--Resumes execution at the signal handler.&nbsp; If the thread's stack has been correctly set up, the thread can return to the interrupted system call.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Calling <b>thread_abort()</b> on a thread that's not suspended is risky, since it's difficult to know exactly what system trap, if any, the thread might be executing and whether an interrupt return would cause the thread to do something useful.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The thread received an interrupt.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_thread</i> isn't a thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_get_state()</b>, <b>thread_info()</b>, <b>thread_terminate()</b>, <b>thread_suspend()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_assign(), thread_assign_default()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Assign a thread to a processor set</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_assign(</b>thread_t <i>thread</i>, processor_set_t <i>new_processor_set</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>thread_assign_default(</b>thread_t <i>thread</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times"><b>thread_assign()</b> assigns <i>thread</i> to <i>new_processor_set</i>; <b>thread_assign_default()</b> assigns <i>thread</i> to the default processor set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">These functions are useful only on multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>thread_create()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_create(</b>task_t <i>parent_task</i>, thread_t *<i>child_thread</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>parent_task</i>:&nbsp; The task that should contain the new thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>child_thread</i>:&nbsp; Returns the new thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_create()</b> creates a new thread within <i>parent_task.</i>&nbsp; The new thread has no processor state, and has a suspend count of 1.&nbsp; To get a new thread to run, first call <b>thread_create()</b> to get the new thread's identifier, <i>child_thread.</i>&nbsp; Then call <b>thread_set_state()</b> to set a processor state.&nbsp; Finally, call <b>thread_resume()</b> to schedule the thread to execute.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Important:</b></font>&nbsp; <font face="Times">Don't use this function unless you're writing a loadable kernel server or implementing a new thread package, such as the C-thread functions.&nbsp; For normal, user-level programming, use <b>cthread_fork()</b> instead.&nbsp; You can then use <b>cthread_thread()</b> if you need to get the Mach thread that corresponds to the new C-thread.</font>

<p><font face="Times">When the thread is created, send rights to its thread kernel port are given to it and returned to the caller in <i>child_thread.</i>&nbsp; The new thread's exception port is set to PORT_NULL.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; A new thread has been created.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>parent_task</i> isn't a valid task.</font>

<p><font face="Times">KERN_RESOURCE_SHORTAGE:&nbsp; Some critical kernel resource isn't available.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_create()</b>, <b>task_threads()</b>, <b>thread_terminate()</b>, <b>thread_suspend()</b>, <b>thread_resume()</b>, <b>thread_special_ports()</b>, <b>thread_set_state()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_get_assignment()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the name of the processor set to which a thread is assigned</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_get_assignment(</b>thread_t <i>thread</i>, processor_set_t *<i>processor_set</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">This function is useful only in multiprocessor systems.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>thread_get_special_port(), thread_set_special_port(), thread_self(), thread_reply()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get or set a thread's special ports</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_get_special_port(</b>thread_t <i>thread</i>, int <i>which_port</i>, port_t *<i>special_port</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>thread_set_special_port(</b>thread_t <i>thread</i>, int <i>which_port</i>, port_t <i>special_port</i><b>)</b></font><br>
<font face="Times">thread_t <b>thread_self(</b>void<b>)</b></font><br>
<font face="Times">port_t <b>thread_reply(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>thread</i>:&nbsp; The thread to get the port for.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>which_port</i>:&nbsp; The port that's requested.&nbsp; This is one of:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">THREAD_REPLY_PORT</font><br>
<font face="Times">THREAD_EXCEPTION_PORT</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>special_port</i>:&nbsp; The value of the port that's being requested or set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_get_special_port()</b> returns send rights to one of a set of special ports for the thread specified by <i>thread.</i>&nbsp; In the case of getting the thread's own reply port, receive rights are also given to the thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function <b>thread_set_special_port()</b> sets one of a set of special ports for the thread specified by <i>thread</i>.</font>

<p><font face="Times">The function <b>thread_self()</b> returns the port to which kernel calls for the currently executing thread should be directed. Currently <b>thread_self()</b> returns the thread kernel port, which is a port for which the kernel has receive rights and which it uses to identify a thread.&nbsp; In the future it may be possible for one thread to interpose a port as another thread's kernel port.&nbsp; At that time <b>thread_self()</b> will still return the port to which the executing thread should direct kernel calls, but it may no longer be a port for which the kernel has receive rights.</font>

<p><font face="Times">If a controller thread has send access to the kernel port of a subject thread, the controller thread can perform kernel operations for the subject thread.&nbsp; Normally only the thread itself and its parent task will have access to the thread kernel port, but any thread may pass rights to its kernel port to any other thread.</font>

<p><font face="Times">The function <b>thread_reply()</b> returns receive and send rights to the reply port of the calling thread.&nbsp; The reply port is a port to which the thread has receive rights.&nbsp; It's used to receive any initialization messages and as a reply port for early remote procedure calls.</font>

<p><font face="Times">A thread also has access to its task's special ports.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>MACRO

<p><br><br>

<p></b></font><font face="Helvetica" size="-1"><b>EQUIVALENTS </b></font><font face="Times">The following macros are defined in the header file <b>mach/thread_special_ports.h</b>:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times"><b>thread_get_reply_port(</b><i>thread</i>, <i>port</i><b>)</b></font><br>
<font face="Times"><b>thread_set_reply_port(</b><i>thread</i>, <i>port</i><b>)</b></font>

<p><font face="Times"><b>thread_get_exception_port(</b><i>thread</i>, <i>port</i><b>)</b></font><br>
<font face="Times"><b>thread_set_exception_port(</b><i>thread</i>, <i>port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The port was returned or set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>thread</i> isn't a thread, or <i>which_port</i> is an invalid port selector.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_get_special_port()</b>, <b>task_set_special_port()</b>, <b>task_self()</b>, <b>thread_create()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_get_state()</b>, <b>thread_set_state()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get or set a thread's state</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_get_state(</b>thread_t <i>target_thread</i>, int <i>flavor</i>, thread_state_data_t <i>old_state</i>, unsigned int *<i>old_state_count</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>thread_set_state(</b>thread_t <i>target_thread</i>, int <i>flavor</i>, thread_state_data_t <i>new_state</i>, unsigned int <i>new_state_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_thread</i>:&nbsp; The thread whose state is affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>flavor</i>:&nbsp; The type of state that's to be manipulated.&nbsp; This may be any one of the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">NeXT_THREAD_STATE_REGS</font><br>
<font face="Times">NeXT_THREAD_STATE_68882</font><br>
<font face="Times">NeXT_THREAD_STATE_USER_REG</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>old_state</i>:&nbsp; Returns an array of state information.</font>

<p><font face="Times"><i>new_state</i>:&nbsp; An array of state information.</font>

<p><font face="Times"><i>old_state_count</i>:&nbsp; The size of the state information array.&nbsp; This may be any one of the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">NeXT_THREAD_STATE_REGS_COUNT</font><br>
<font face="Times">NeXT_THREAD_STATE_68882_COUNT</font><br>
<font face="Times">NeXT_THREAD_STATE_USER_REG_COUNT</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>new_state_count</i>:&nbsp; Same as <i>old_state_count</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_get_state()</b> returns the state component (that is, the machine registers) of <i>target_thread</i> as specified by <i>flavor.</i>&nbsp; The <i>old_state</i> is an array of integers that's provided by the caller and returned filled with the specified information.&nbsp; You should set <i>old_state_count</i> to the maximum number of integers in <i>old_state</i>.&nbsp; On return, <i>old_state_count</i> is equal to the actual number of integers in <i>old_state</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The function <b>thread_set_state()</b> sets the state component of <i>target_thread</i> as specified by <i>flavor.</i>&nbsp; The <i>new_state</i> is an array of integers that the caller fills.&nbsp; You should set <i>new_state_count</i> to the number of elements in <i>new_state.</i>&nbsp; The entire set of registers is reset.</font>

<p><font face="Times"><i>target_thread</i> must not be <b>thread_self()</b> for either of these calls.</font>

<p><font face="Times">The state structures are defined in the header file <b>mach/machine/thread_status.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The state has been set or returned.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">MIG_ARRAY_TOO_LARGE:&nbsp; The returned state is too large for the <i>new_state.</i>&nbsp; The <i>new_state</i> argument is filled in as much as possible, and <i>new_state_count</i> is set to the number of elements that would be returned if there were enough room.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_thread</i> isn't a thread, <i>target_thread</i> is <b>thread_self()</b>, or <i>flavor</i> is unrecognized for this machine.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_info()</b>, <b>thread_info()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_info()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_info(</b>thread_t <i>target_thread</i>, int <i>flavor</i>, thread_info_t <i>thread_info</i>, unsigned int *<i>thread_info_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_thread</i>:&nbsp; The thread to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>flavor</i>:&nbsp; The type of statistics wanted.&nbsp; This can be THREAD_BASIC_INFO or THREAD_SCHED_INFO.</font>

<p><font face="Times"><i>thread_info</i>:&nbsp; Returns statistics about <i>target_thread</i>.</font>

<p><font face="Times"><i>thread_info_count</i>:&nbsp; Size of the info structure.&nbsp; This can be THREAD_BASIC_INFO_COUNT or THREAD_SCHED_INFO_COUNT.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_info()</b> returns the selected information array for a thread, as specified by <i>flavor.</i>&nbsp; The <i>thread_info </i>argument is an array of integers that's supplied by the caller and returned filled with specified information.&nbsp; The <i>thread_info_count</i> argument is supplied as the maximum number of integers in <i>thread_info.</i>&nbsp; On return, it contains the actual number of integers in <i>thread_info</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The size of the information returned by THREAD_BASIC_INFO is defined by THREAD_BASIC_INFO_COUNT.&nbsp; The definition of the information structure returned by THREAD_BASIC_INFO is:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct thread_basic_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">time_value_t&nbsp; user_time;&nbsp;&nbsp;&nbsp;&nbsp; /* user run time */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">time_value_t&nbsp; system_time;&nbsp;&nbsp; /* system run time */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_usage;&nbsp;&nbsp;&nbsp;&nbsp; /* scaled cpu usage percentage */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_priority; /* base scheduling priority */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_priority;&nbsp; /* current scheduling priority */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; run_state;&nbsp;&nbsp;&nbsp;&nbsp; /* run state */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* various flags */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspend_count; /* suspend count for thread */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep_time;&nbsp;&nbsp;&nbsp; /* number of seconds that thread</font><br>
<img src="../../../Images/sp.gif" width=376 height=1><font face="Courier" size="-1">has been sleeping */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct thread_basic_info *thread_basic_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>run_state</b> field has one of the following values:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">TH_STATE_RUNNING:&nbsp; The thread is running normally.</font>

<p><font face="Times">TH_STATE_STOPPED:&nbsp; The thread is suspended.&nbsp; This happens when the thread or task suspend count is greater than zero.</font>

<p><font face="Times">TH_STATE_WAITING:&nbsp; The thread is sleeping normally.</font>

<p><font face="Times">TH_STATE_UNINTERRUPTIBLE:&nbsp; The thread is in an uninterruptible sleep.&nbsp; This should happen only for very short times during some system calls.</font>

<p><font face="Times">TH_STATE_HALTED:&nbsp; The thread is halted at a clean point.&nbsp; This state happens only after a call to <b>thread_abort()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Possible values of the <b>flags</b> field are:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">TH_FLAGS_SWAPPED:&nbsp; The thread is swapped out.&nbsp; This happens when the thread hasn't run in a long time, and the kernel stack for the thread has been swapped out.</font>

<p><font face="Times">TH_FLAGS_IDLE:&nbsp; The thread is the idle thread for the CPU.&nbsp; This means that the CPU runs this thread whenever it has no other threads to run.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>sleep_time</b> field is useful only when <b>run_state</b> is TH_STATE_STOPPED.&nbsp; (Currently <b>sleep_time</b> is always set to zero, no matter how long the thread has been sleeping.)</font>

<p><font face="Times">The size of the information returned by THREAD_SCHED_INFO is defined by THREAD_SCHED_INFO_COUNT.&nbsp; The definition of the information structure returned by THREAD_SCHED_INFO is:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct thread_sched_info {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; policy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* scheduling policy */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* associated data */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base_priority;&nbsp;&nbsp;&nbsp; /* base priority */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_priority;&nbsp;&nbsp;&nbsp;&nbsp; /* max priority */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_priority;&nbsp;&nbsp;&nbsp;&nbsp; /* current priority */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">boolean_t depressed;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* depressed ? */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depress_priority; /* priority depressed from */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct thread_sched_info&nbsp;&nbsp;&nbsp; *thread_sched_info_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>policy</b> field has one of the following values:&nbsp; POLICY_FIXEDPRI, POLICY_TIMESHARE, or POLICY_INTERACTIVE. If <b>policy</b> is POLICY_FIXEDPRI, then <b>data</b> is the quantum (in milliseconds).&nbsp; Otherwise, <b>data</b> is meaningless.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Times">Example of using THREAD_BASIC_INFO:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct thread_basic_info&nbsp; info;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_count=THREAD_BASIC_INFO_COUNT;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">error=thread_info(thread_self(), THREAD_BASIC_INFO,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">(thread_info_t)&amp;info, &amp;info_count);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling thread_info()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;User time is %d seconds, %d microseconds\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">info.user_time.seconds, info.user_time.microseconds);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;System time is %d seconds, %d microseconds\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=180 height=1><font face="Courier" size="-1">info.system_time.seconds, info.system_time.microseconds);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Example of using THREAD_SCHED_INFO:</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct thread_sched_info&nbsp; info;</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_count=THREAD_SCHED_INFO_COUNT;</font>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">error=thread_info(thread_self(), THREAD_SCHED_INFO,</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">(thread_info_t)&amp;info, &amp;info_count);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling thread_info()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Base priority is %d\n&#34;, info.base_priority);</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">printf(&#34;Max priority is %d\n&#34;, info.max_priority);</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_thread</i> isn't a thread, or <i>flavor</i> isn't recognized, or <i>thread_info_count</i> is smaller than it's supposed to be.</font>

<p><font face="Times">MIG_ARRAY_TOO_LARGE:&nbsp; The returned info array is too large for <i>thread_info.</i>&nbsp; The <i>thread_info</i> argument is filled as much as possible, and <i>thread_info_count</i> is set to the number of elements that would have been returned if there were enough room.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_get_special_port()</b>, <b>task_threads()</b>, <b>task_info()</b>, <b>thread_get_state()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_policy()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set scheduling policy for a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_policy(</b>thread_t <i>thread</i>, int <i>policy</i>, int <i>data</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>thread</i>:&nbsp; Thread to set policy for.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>policy</i>:&nbsp; Policy to set.&nbsp; This must be POLICY_TIMESHARE, POLICY_INTERACTIVE, or POLICY_FIXEDPRI.</font>

<p><font face="Times"><i>data</i>:&nbsp; Policy-specific data.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function changes the scheduling policy for <i>thread</i> to <i>policy</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <i>data</i> argument is meaningless for the timesharing and interactive policies; for the fixed-priority policy, it's the quantum to be used (in milliseconds).&nbsp; The system will always round the quantum up to the next multiple of the basic system quantum (<b>min_quantum</b>, which can be obtained from <b>host_info()</b>).&nbsp; You can find the current quantum using <b>thread_info()</b>.</font>

<p><font face="Times">Processor sets can restrict the allowed policies, so this call will fail if the processor set to which <i>thread</i> is currently assigned doesn't permit <i>policy</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">struct host_sched_info&nbsp; sched_info;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sched_count=HOST_SCHED_INFO_COUNT;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quantum;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">processor_set_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default_set, default_set_priv;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Set quantum to a reasonable value. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_info(host_self(), HOST_SCHED_INFO,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">(host_info_t)&amp;sched_info, &amp;sched_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;SCHED host_info() call failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">quantum = sched_info.min_quantum;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">* Fix the default processor set to take a fixed priority thread.</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_policy_enable(default_set_priv, POLICY_FIXEDPRI);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_policy_enable&#34;, error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/*</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">* Change the thread's scheduling policy to fixed priority.</font><br>
<img src="../../../Images/sp.gif" width=112 height=1><font face="Courier" size="-1">*/</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=thread_policy(thread_self(), POLICY_FIXEDPRI, quantum);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;thread_policy() call failed&#34;, error);</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>thread</i> is not a thread, or <i>policy</i> is not a recognized policy.</font>

<p><font face="Times">KERN_FAILURE:&nbsp; The processor set to which <i>thread</i> is currently assigned doesn't permit <i>policy</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>processor_set_policy()</b>, <b>thread_switch()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_priority(), thread_max_priority()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set scheduling priority for thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_priority(</b>thread_t <i>thread</i>, int <i>priority</i>, boolean_t <i>set_max</i><b>)</b></font><br>
<font face="Times">kern_return_t <b>thread_max_priority(</b>thread_t <i>thread</i>, processor_set_t <i>processor_set</i>, int <i>priority</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>thread</i>:&nbsp; The thread whose priority is to be changed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>priority</i>:&nbsp; The new priority to change it to.</font>

<p><font face="Times"><i>set_max</i>:&nbsp; Also set <i>thread</i>'s maximum priority if true.</font>

<p><font face="Times"><i>processor_set</i>:&nbsp; The privileged port for the processor set to which <i>thread</i> is currently assigned.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Threads have three priorities associated with them by the system:&nbsp; a <i>base priority</i>, a <i>maximum priority</i>, and a <i>scheduled priority</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The scheduled priority is used to make scheduling decisions about the thread.&nbsp; It's determined from the base priority by the policy.&nbsp; (For the timesharing and interactive policies, this means adding an increment derived from CPU usage).&nbsp; The base priority can be set under user control, but can never exceed the maximum priority.&nbsp; Raising the maximum priority requires presentation of the privileged port for the thread's processor set; since the privileged port for the default processor set is available only to the superuser, users cannot raise their maximum priority to unfairly compete with other users on that set. Newly created threads obtain their base priority from the task and their maximum priority from the thread.</font>

<p><font face="Times">Priorities range from 0 to 31, where higher numbers denote higher priorities.&nbsp; You can obtain the base, scheduled, and maximum priorities using <b>thread_info()</b>.</font>

<p><font face="Times">The <b>thread_priority()</b> function changes the base priority and optionally the maximum priority of <i>thread</i>.&nbsp; If the new base priority is higher than the scheduled priority of the currently executing thread, preemption may occur as a result of this call.&nbsp; The maximum priority of the thread is also set if <i>set_max</i> is true.&nbsp; This call fails if <i>priority</i> is greater than the current maximum priority of the thread.&nbsp; As a result, <b>thread_priority()</b> can lower--but never raise--the value of a thread's maximum priority.</font>

<p><font face="Times">The <b>thread_max_priority()</b> function changes the maximum priority of the thread.&nbsp; Because it requires the privileged port for the processor set, this call can reset the maximum priority to any legal value.&nbsp; If the new maximum priority is less than the thread's base priority, then the thread's base priority is set to the new maximum priority.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Get the privileged port for the default processor set. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=processor_set_default(host_self(), &amp;default_set);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling processor_set_default()&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=host_processor_set_priv(host_priv_self(), default_set,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;default_set_priv);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to host_processor_set_priv() failed&#34;, error);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Set the max priority. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=thread_max_priority(thread_self(), default_set_priv, priority);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to thread_max_priority() failed&#34;,error);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Set the thread's priority. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">error=thread_priority(thread_self(), priority, FALSE);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (error!=KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to thread_priority() failed&#34;,error);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Operation completed successfully.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>thread</i> is not a thread, <i>processor_set</i> is not a privileged port for a processor set, or <i>priority</i> is out of range (not in 0-31).</font>

<p><font face="Times">KERN_FAILURE:&nbsp; The requested operation would violate the thread's maximum (only for <b>thread_priority()</b>), or the thread is not assigned to the processor set whose privileged port was presented.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>thread_policy()</b>, <b>task_priority()</b>, <b>processor_set_priority()</b>, <b>thread_switch()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_resume()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Resume a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_resume(</b>thread_t <i>target_thread</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_thread</i>:&nbsp; The thread to be resumed.</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_resume()</b> decrements the thread's suspend count.&nbsp; If the count becomes 0, the thread is resumed.&nbsp; If it's still positive, the thread is left suspended.&nbsp; The suspend count never becomes negative.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The thread has been resumed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_FAILURE:&nbsp; The suspend count is already 0.</font>

<p><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_thread</i> isn't a thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_suspend()</b>, <b>task_resume()</b>, <b>thread_info()</b>, <b>thread_create()</b>, <b>thread_terminate()</b>, <b>thread_suspend()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_suspend()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Suspend a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_suspend(</b>thread_t <i>target_thread</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_thread</i>:&nbsp; The thread to be suspended.</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_suspend()</b> increments the thread's suspend count and prevents the thread from executing any more user-level instructions.&nbsp; In this context, a user-level instruction is either a machine instruction executed in user mode or a system trap instruction (including page faults).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If a thread is currently executing within a system trap, the kernel code may continue to execute until it reaches the system return code, or it may suspend within the kernel code.&nbsp; In either case, when the thread is resumed the system trap will return.&nbsp; This could cause unpredictable results if you did a suspend and then altered the user state of the thread in order to change its direction upon a resume.&nbsp; The function <b>thread_abort()</b> lets you abort any currently executing system call in a predictable way.</font>

<p><font face="Times">If the suspend count becomes greater than 1, it will take more than one <b>thread_resume()</b> call to restart the thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The thread has been suspended.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_thread</i> isn't a thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_suspend()</b>, <b>task_resume()</b>, <b>thread_get_state()</b>, <b>thread_info()</b>, <b>thread_resume()</b>, <b>thread_terminate()</b>, <b>thread_abort()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>thread_switch()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Cause a context switch</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_switch(</b>thread_t <i>new_thread</i>, int <i>option</i>, int <i>time</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>new_thread</i>:&nbsp; Thread to switch to.&nbsp; If you specify THREAD_NULL, be sure to specify the <i>option</i> argument to be either SWITCH_OPTION_WAIT or SWITCH_OPTION_DEPRESS.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>option</i>:&nbsp; Specifies options associated with context switch.&nbsp; Three options are recognized:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">SWITCH_OPTION_NONE:&nbsp; No options; the <i>time</i> argument is ignored.&nbsp; (You must set <i>new_thread</i> to a valid thread.)</font>

<p><font face="Times">SWITCH_OPTION_WAIT:&nbsp; This thread is blocked for the specified time.&nbsp; The block can be aborted by <b>thread_abort()</b>.</font>

<p><font face="Times">SWITCH_OPTION_DEPRESS:&nbsp; This thread's priority is depressed to the lowest possible value until one of the following happens:&nbsp; <i>time</i> milliseconds pass, this thread is scheduled again, or <b>thread_abort()</b> is called on this thread (whichever happens first).&nbsp; Priority depression is independent of operations that change this thread's priority; for example, <b>thread_priority()</b> will not abort the depression.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>time</i>:&nbsp; Time duration (in milliseconds<i>)</i> for options.&nbsp; The minimum time can be obtained as the <b>min_timeout</b> value from <b>host_info()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function provides low-level access to the scheduler's context switching code.&nbsp; <i>new_thread</i> is a hint that implements handoff scheduling.&nbsp; The operating system will attempt to switch directly to <i>new_thread</i> (bypassing the normal logic that selects the next thread to run) if possible.&nbsp; If <i>new_thread</i> isn't valid or THREAD_NULL, <b>thread_switch()</b> returns an error.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <b>thread_switch()</b> function is often called when the current thread can proceed no farther for some reason; the various options and arguments allow information about this reason to be transmitted to the kernel.&nbsp; The <i>new_thread</i> argument (handoff scheduling) is useful when the identity of the thread that must make progress before the current thread runs again is known.&nbsp; The SWITCH_OPTION_WAIT option is used when the amount of time that the current thread must wait before it can do anything useful can be estimated and is fairly long.&nbsp; The SWITCH_OPTION_DEPRESS option is used when the required waiting time is fairly short, especially when the identity of the thread that is being waited for is not known.</font>

<p><font face="Times">Users should beware of calling <b>thread_switch()</b> with an invalid <i>new_thread</i> (for example, THREAD_NULL) and no <i>option</i>. Because the timesharing and interactive schedulers vary the priority of threads based on usage, this may result in a waste of CPU time if the thread that must be run is of lower priority.&nbsp; The use of the SWITCH_OPTION_DEPRESS option in this situation is highly recommended.</font>

<p><font face="Times">When a thread that's depressed is scheduled, it regains its old priority.&nbsp; The code should recheck the conditions to see if it wants to depress again.&nbsp; If <b>thread_abort()</b> is called on a depressed thread, the priority of the thread is restored.</font>

<p><font face="Times">Users relying on the preemption semantics of a fixed-priority policy should be aware that <b>thread_switch()</b> ignores these semantics; it will run the specified <i>new_thread</i> independent of its priority and the priority of any other threads that could be run instead.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>new_thread</i> is not a thread, or <i>option</i> is not a recognized option.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>thread_terminate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Terminate a thread</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>thread_terminate(</b>thread_t <i>target_thread</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_thread</i>:&nbsp; The thread to be destroyed.</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>thread_terminate()</b> destroys the thread specified by <i>target_thread</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Warning:</b></font>&nbsp; <font face="Times">Don't use this function on threads that were created using the C-thread functions.&nbsp; Each C thread must terminate itself either explicitly, by calling <b>cthread_exit()</b>, or implicitly, by returning from its top-level function.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The thread has been destroyed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; <i>target_thread</i> isn't a thread.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_terminate()</b>, <b>task_threads()</b>, <b>thread_create()</b>, <b>thread_resume()</b>, <b>thread_suspend()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>unix_pid()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the process ID of a task</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>unix_pid(</b>task_t <i>target_task</i>, int *<i>pid</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task for which you want the process ID.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>pid</i>:&nbsp; Returns the process ID of <i>target_task</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns the process ID of <i>target_task</i>.&nbsp; If the call doesn't succeed, <i>pid</i> is set to -1.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">result=unix_pid(task_self(), &amp;my_pid);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result!=KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Call to unix_pid failed&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;My process ID is %d\n&#34;, my_pid);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_FAILURE:&nbsp; <i>target_task</i> isn't a valid task.&nbsp; This might be because <i>target_task</i> is a pure Mach task (one created using <b>task_create()</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_by_unix_pid()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_allocate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Allocate virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_allocate(</b>vm_task_t <i>target_task</i>, vm_address_t *<i>address</i>, vm_size_t <i>size</i>, boolean_t <i>anywhere</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose virtual memory is to be affected.&nbsp; Use <b>task_self()</b> to allocate memory in the caller's address space.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address.&nbsp; If <i>anywhere</i> is true, the input value of this address will be ignored, and the space will be allocated wherever it's available.&nbsp; If <i>anywhere</i> is false, an attempt is made to allocate virtual memory starting at this virtual address.&nbsp; If this address isn't at the beginning of a virtual page, it gets rounded down so that it is.&nbsp; If there isn't enough space at this address, no memory will be allocated.&nbsp; No matter what the value of <i>anywhere</i> is, the address at which memory is actually allocated is returned in <i>address</i>.</font>

<p><font face="Times"><i>size</i>:&nbsp; Number of bytes to allocate (rounded up by the system to an integral number of virtual pages).</font>

<p><font face="Times"><i>anywhere</i>:&nbsp; If true, the kernel should find and allocate any region of the specified size.&nbsp; If false, virtual memory is allocated starting at <i>address</i> (rounded down to a virtual page boundary) if sufficient space exists.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_allocate()</b> allocates a region of virtual memory, placing it in the address space of the specified task.&nbsp; The physical memory isn't actually allocated until the new virtual memory is referenced.&nbsp; By default, the kernel rounds all addresses down to the nearest page boundary and all memory sizes up to the nearest page size.&nbsp; The global variable <b>vm_page_size </b>contains the page size.&nbsp; For languages other than C, the value of <b>vm_page_size</b> can be obtained by calling <b>vm_statistics()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Initially, the pages of allocated memory are protected to allow all forms of access, and are inherited in child tasks as a copy. Subsequent calls to <b>vm_protect()</b> and <b>vm_inherit()</b> may be used to change these properties.&nbsp; The allocated region is always zero-filled.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">Unless you have a special reason for calling <b>vm_allocate()</b> (such as a need for page-aligned memory), you should usually call <b>malloc()</b> or a similar C library function instead.&nbsp; The C library functions don't necessarily make UNIX or Mach system calls, so they're generally faster than using a Mach function such as <b>vm_allocate()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">if ((ret = vm_allocate(task_self(), (vm_address_t *)&amp;lock,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(int), TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate returned value of &#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((ret = vm_inherit(task_self(), (vm_address_t)lock, sizeof(int),</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">VM_INHERIT_SHARE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_inherit returned value of &#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Memory allocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ADDRESS:&nbsp; Illegal address specified.</font>

<p><font face="Times">KERN_NO_SPACE:&nbsp; Not enough space left to satisfy this request.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_deallocate()</b>, <b>vm_inherit()</b>, <b>vm_protect()</b>, <b>vm_region()</b>, <b>vm_statistics()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_copy()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Copy virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_copy(</b>vm_task_t <i>target_task</i>, vm_address_t <i>source_address</i>, vm_size_t <i>size</i>, vm_address_t <i>dest_address</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task whose virtual memory is to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>source_address</i>:&nbsp; The address in <i>target_task</i> of the start of the source range (must be a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; The number of bytes to copy (must be a multiple of <b>vm_page_size</b>).</font>

<p><font face="Times"><i>dest_address</i>:&nbsp; The address in <i>target_task</i> of the start of the destination range (must be a page boundary).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_copy()</b> causes the source memory range to be copied to the destination address; the destination region must not overlap the source region.&nbsp; The destination address range must already be allocated and writable; the source range must be readable.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For languages other than C, the value of <b>vm_page_size</b> can be obtained by calling <b>vm_statistics()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">if ((rtn = vm_allocate(task_self(), (vm_address_t *)&amp;data1,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">vm_page_size, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate returned value of &#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">temp = data1;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">for (i = 0; (i &lt; vm_page_size / sizeof(int)); i++)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">temp[i] = i;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: set data\n&#34;);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((rtn = vm_allocate(task_self(), (vm_address_t *)&amp;data2,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">vm_page_size, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate returned value of &#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((rtn = vm_copy(task_self(), (vm_address_t)data1, vm_page_size,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">(vm_address_t)data2)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_copy returned value of &#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;vm_copy: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Memory copied.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; The address doesn't start on a page boundary or the size isn't a multiple of <b>vm_page_size</b>.</font>

<p><font face="Times">KERN_PROTECTION_FAILURE:&nbsp; The destination region isn't writable, or the source region isn't readable.</font>

<p><font face="Times">KERN_INVALID_ADDRESS:&nbsp; An illegal or nonallocated address was specified, or insufficient memory was allocated at one of the addresses.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_allocate()</b>, <b>vm_protect()</b>, <b>vm_write()</b>, <b>vm_statistics()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_deactivate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Mark virtual memory as unlikely to be used soon</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_deactivate(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, vm_size_t <i>size</i>, int <i>when</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose virtual memory is to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address (must be on a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; The number of bytes to deactivate (must be a multiple of <b>vm_page_size</b>).&nbsp; Specifying 0 deactivates all of the task's memory at or above <i>address</i>.</font>

<p><font face="Times"><i>when</i>:&nbsp; A mask specifying how aggressively the system should deactivate the memory, and whether the memory should be deactivated if it's shared.&nbsp; Values for <i>when</i> are defined in the header file <b>mach/vm_policy.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function lets you tell the operating system that a region of memory won't be used for a long time. It differs from <b>vm_deallocate()</b> in that the task's mapping to the memory is retained; only the physical memory associated with the region is affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">A <i>when</i> value of VM_DEACTIVATE_NOW is the most extreme--the system will immediately place clean pages at the front of the free list, and dirty pages at the front of the inactive list.&nbsp; A <i>when</i> value of VM_DEACTIVATE_SOON specifies that the system should place all pages on the tail of the inactive list.&nbsp; You can add the mask VM_DEACTIVATE_SHARED to indicate that only shared memory should be affected.</font>

<p><font face="Times">This call is used in the window server to deactivate the backing stores of windows in hidden applications, and is used in the Application Kit to deactivate the text, data, and stack of hidden applications.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_set_policy()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_deallocate()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Deallocate virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_deallocate(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, vm_size_t <i>size</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose virtual memory is to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address (this gets rounded down to a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; Number of bytes to deallocate (this gets rounded up to a page boundary).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_deallocate()</b> relinquishes access to a region of a task's address space, causing further access to that memory to fail.&nbsp; This address range will be available for reallocation.&nbsp; Note that because of the rounding to virtual page boundaries, more than <i>size</i> bytes may be deallocated.&nbsp; Use <b>vm_statistics()</b> or the global variable <b>vm_page_size</b> to get the current virtual page size.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This function may be used to deallocate memory that was passed to a task in a message (using out-of-line data).&nbsp; In that case, the rounding should cause no trouble, since the region of memory was allocated as a set of pages.</font>

<p><font face="Times">The function <b>vm_deallocate()</b> affects only the task specified by <i>target_task.</i>&nbsp; Other tasks that may have access to this memory can continue to reference it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">r = vm_deallocate(task_self(), (vm_address_t)thread_list,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(thread_list)*thread_count);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing thread_list&#34;, r);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Memory deallocated.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ADDRESS:&nbsp; Illegal or nonallocated address specified.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_allocate()</b>, <b>vm_statistics()</b>, <b>msg_receive()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_inherit()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Inherit virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_inherit(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, vm_size_t <i>size</i>, vm_inherit_t <i>new_inheritance</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose virtual memory is to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address (this gets rounded down to a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; Size in bytes of the region for which inheritance is to change (this gets rounded up to a page boundary).</font>

<p><font face="Times"><i>new_inheritance</i>:&nbsp; How this memory is to be inherited in child tasks.&nbsp; Inheritance is specified by using one of these following three values:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times">VM_INHERIT_SHARE:&nbsp; Child tasks will share this memory with this task.</font><br>
<font face="Times">VM_INHERIT_COPY:&nbsp; Child tasks will receive a copy of this region.</font><br>
<font face="Times">VM_INHERIT_NONE:&nbsp; This region will be absent from child tasks.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_inherit()</b> specifies how a region of a task's address space is to be passed to child tasks at the time of task creation.&nbsp; Inheritance is an attribute of virtual pages; thus the addresses and size of memory to be set will be rounded to refer to whole pages.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Setting <b>vm_inherit()</b> to VM_INHERIT_SHARE and forking a child task is the only way two Mach tasks can share physical memory.&nbsp; However, all the threads of a given task share all the same memory.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">if ((ret = vm_allocate(task_self(), (vm_address_t *)&amp;lock, sizeof(int),</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate returned value of &#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((ret = vm_inherit(task_self(), (vm_address_t)lock, sizeof(int),</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">VM_INHERIT_SHARE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_inherit returned value of &#34;, ret);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Exiting with error.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The inheritance has been set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ADDRESS:&nbsp; Illegal address specified.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>task_create()</b>, <b>vm_region()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_protect()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Protect virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_protect(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, vm_size_t <i>size</i>, boolean_t <i>set_maximum</i>, vm_prot_t <i>new_protection</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose virtual memory is to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address (this gets rounded down to a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; Size in bytes of the region for which protection is to change (this gets rounded up to a page boundary).</font>

<p><font face="Times"><i>set_maximum</i>:&nbsp; If set, make the protection change apply to the maximum protection associated with this address range; otherwise, change the current protection on this range.&nbsp; If the maximum protection is reduced below the current protection, both will be changed to reflect the new maximum.</font>

<p><font face="Times"><i>new_protection</i>:&nbsp; A new protection value for this region; either VM_PROT_NONE or some combination of VM_PROT_READ, VM_PROT_WRITE, and VM_PROT_EXECUTE.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_protect()</b> changes the protection of some pages of allocated memory in a task's address space.&nbsp; In general, a protection value permits the named operation.&nbsp; When memory is first allocated it has all protection bits on.&nbsp; The exact interpretation of a protection value is machine-dependent.&nbsp; In the NeXT Mach operating system, three levels of memory protection are provided:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">No access</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read and execute access</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">Read, execute, and write access</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">VM_PROT_NONE permits no access.&nbsp; VM_PROT_WRITE permits read, execute, and write access; VM_PROT_READ or VM_PROT_EXECUTE permits read and execute access, but not write access.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">vm_address_t&nbsp;&nbsp;&nbsp; addr = (vm_address_t)mlock;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = vm_protect(task_self(), addr, vm_page_size, FALSE, 0);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_protect 0&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;protect on\n&#34;);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The memory has been protected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_PROTECTION_FAILURE:&nbsp; An attempt was made to increase the current or maximum protection beyond the existing maximum protection value.</font>

<p><font face="Times">KERN_INVALID_ADDRESS:&nbsp; An illegal or nonallocated address was specified.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>vm_read()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Read virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_read(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, vm_size_t <i>size</i>, pointer_t *<i>data</i>, unsigned int *<i>data_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose memory is to be read.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; The first address to be read (must be on a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; The number of bytes of data to be read (must be a multiple of <b>vm_page_size</b>).</font>

<p><font face="Times"><i>data</i>:&nbsp; The array of data copied from the given task.</font>

<p><font face="Times"><i>data_count</i>:&nbsp; Returns the size of the data array in bytes (will be an integral number of pages).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_read()</b> allows one task's virtual memory to be read by another task.&nbsp; The data array is returned in a newly allocated region; the task reading the data should call <b>vm_deallocate()</b> on this region when it's done with the data.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">For languages other than C, the value of <b>vm_page_size</b> can be obtained by calling <b>vm_statistics()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">if ((rtn = vm_allocate(task_self(), (vm_address_t *)&amp;data1,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">vm_page_size, TRUE)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_allocate returned value of &#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">temp = data1;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">for (i = 0; (i &lt; vm_page_size); i++)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">temp[i] = i;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;Filled space allocated with some data.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;Doing vm_read....\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if ((rtn = vm_read(task_self(), (vm_address_t)data1, vm_page_size,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">(pointer_t *)&amp;data2, &amp;data_cnt)) != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;vm_read returned value of &#34;, rtn);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;vmread: Exiting.\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(-1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">printf(&#34;Successful vm_read.\n&#34;);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The memory has been read.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; Either <i>address</i> does not start on a page boundary or <i>size</i> isn't an integral number of pages.</font>

<p><font face="Times">KERN_NO_SPACE:&nbsp; There isn't enough room in the caller's virtual memory to allocate space for the data to be returned.</font>

<p><font face="Times">KERN_PROTECTION_FAILURE:&nbsp; The address region in the target task is protected against reading.</font>

<p><font face="Times">KERN_INVALID_ADDRESS:&nbsp; An illegal or nonallocated address was specified, or there were not <i>size</i> bytes of data following that address.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_write()</b>, <b>vm_copy()</b>, <b>vm_deallocate()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_region()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about virtual memory regions</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_region(</b>vm_task_t <i>target_task</i>, vm_address_t *<i>address</i>, vm_size_t *<i>size</i>, vm_prot_t *<i>protection</i>, vm_prot_t *<i>max_protection</i>, vm_inherit_t *<i>inheritance</i>, boolean_t *<i>shared</i>, port_t *<i>object_name</i>, vm_offset_t *<i>offset</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task for which an address space description is requested.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; The address at which to start looking for a region.&nbsp; On return, <i>address</i> will contain the start of the region (therefore, the value returned will be different from the value that was passed in if the specified region is part of a larger region).</font>

<p><font face="Times"><i>size</i>:&nbsp; Returns the size (in bytes) of the located region.</font>

<p><font face="Times"><i>protection</i>:&nbsp; Returns the current protection of the region.</font>

<p><font face="Times"><i>max_protection</i>:&nbsp; Returns the maximum allowable protection for this region.</font>

<p><font face="Times"><i>inheritance</i>:&nbsp; Returns the inheritance attribute for this region.</font>

<p><font face="Times"><i>shared</i>:&nbsp; Returns true if this region is shared, false if it isn't.</font>

<p><font face="Times"><i>object_name</i>:&nbsp; Returns the port identifying the region's memory object.</font>

<p><font face="Times"><i>offset</i>:&nbsp; Returns the offset into the pager object at which this region begins.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The <b>vm_region()</b> function returns a description of the specified region of the target task's virtual address space.&nbsp; This function begins at <i>address</i>, looking forward through memory until it comes to an allocated region.&nbsp; (If <i>address</i> is in a region, that region is used.)&nbsp; If <i>address</i> isn't in a region, it's set to the start of the first region that follows the incoming value.&nbsp; In this way an entire address space can be scanned.&nbsp; You can set <i>address</i> to the constant VM_MIN_ADDRESS (defined in the header file <b>mach/machine/vm_param.h</b>) to specify the first address in the address space.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *data;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">kern_return_t r;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_size_t&nbsp;&nbsp;&nbsp;&nbsp; size;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_prot_t&nbsp;&nbsp;&nbsp;&nbsp; protection, max_protection;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_inherit_t&nbsp; inheritance;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">boolean_t&nbsp;&nbsp;&nbsp;&nbsp; shared;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_name;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_offset_t&nbsp;&nbsp; offset;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">vm_address_t&nbsp; address;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Check the inheritance of &#34;data&#34;. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">address = (vm_address_t)&amp;data;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = vm_region(task_self(), &amp;address, &amp;size, &amp;protection,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;max_protection, &amp;inheritance, &amp;shared, &amp;object_name, &amp;offset);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Error calling vm_region&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Inheritance is:&nbsp; &#34;);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">switch (inheritance) {</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">case VM_INHERIT_SHARE:</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">printf(&#34;Share with child\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">case VM_INHERIT_COPY:</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">printf(&#34;Copy into child\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">case VM_INHERIT_NONE:</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">printf(&#34;Absent from child\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">case VM_INHERIT_DONATE_COPY:</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">printf(&#34;Copy and delete\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">break;</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The region was located and information has been returned.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_NO_SPACE:&nbsp; The task contains no region at or above <i>address</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_allocate()</b>, <b>vm_deallocate()</b>, <b>vm_protect()</b>, <b>vm_inherit()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_set_policy()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Set the paging policy for a region of memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_set_policy(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, vm_size_t <i>size</i>, int <i>policy</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose virtual memory is to be affected.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address (must be on a page boundary).</font>

<p><font face="Times"><i>size</i>:&nbsp; Number of bytes (must be a multiple of <b>vm_page_size</b>).</font>

<p><font face="Times"><i>policy</i>:&nbsp; Mask specifying the paging policy.&nbsp; Values for <i>policy</i> are defined in the header file <b>mach/vm_policy.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function lets you control the paging policy for a region of memory.&nbsp; In addition to its normal paging policy, the system can control the placement of pages under certain patterns of access.&nbsp; These patterns are currently limited to strictly sequential access in either direction.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The <i>policy</i> mask can have the following values, which can be combined:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">VM_POLICY_PAGE_AHEAD (page ahead)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">VM_POLICY_SEQ_DEACTIVATE (deactivate behind)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">VM_POLICY_SEQ_FREE (free behind)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times"><img src="../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">VM_POLICY_RANDOM (don't use a special paging policy)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">The page-ahead policy isn't currently implemented.</font>

<p><font face="Times">Calls to <b>vm_policy()</b> affect memory at the backing store level, not the mapping level.&nbsp; For example, calling <b>vm_policy()</b> on a memory-mapped file affects the underlying file, and consequently all uses of that file.&nbsp; It is currently impossible for different users of the same file to have different policies for that file.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_deactivate()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_statistics()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Examine virtual memory statistics</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_statistics(</b>vm_task_t <i>target_task</i>, vm_statistics_data_t *<i>vm_stats</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; The task that's requesting the statistics.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>vm_stats</i>:&nbsp; Returns the statistics.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_statistics()</b> returns statistics about the kernel's use of virtual memory since the kernel was booted.&nbsp; The system page size is contained in both the <b>pagesize</b> field of the <i>vm_status</i> and the global variable <b>vm_page_size</b>, which is set at task initialization and remains constant for the life of the task.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">struct vm_statistics {</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; pagesize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* page size in bytes */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; free_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of pages free */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; active_count;&nbsp;&nbsp;&nbsp; /* number of pages active */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; inactive_count;&nbsp; /* number of pages inactive */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; wire_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of pages wired down */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; zero_fill_count; /* number of zero-fill pages */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; reactivations;&nbsp;&nbsp; /* number of pages reactivated */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; pageins;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of pageins */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; pageouts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of pageouts */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; faults;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of faults */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; cow_faults;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of copy-on-writes */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; lookups;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* object cache lookups */</font><br>
<img src="../../../Images/sp.gif" width=152 height=1><font face="Courier" size="-1">long&nbsp; hits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* object cache hits */</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">};</font><br>
<img src="../../../Images/sp.gif" width=124 height=1><font face="Courier" size="-1">typedef struct vm_statistics&nbsp;&nbsp; vm_statistics_data_t;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">result=vm_statistics(task_self(), &amp;vm_stats);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;An error calling vm_statistics()!&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;%d bytes of RAM are free\n&#34;,</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">vm_stats.free_count * vm_stats.pagesize);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; The operation was successful.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>vm_write()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Write virtual memory</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>vm_write(</b>vm_task_t <i>target_task</i>, vm_address_t <i>address</i>, pointer_t <i>data</i>, unsigned int <i>data_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>target_task</i>:&nbsp; Task whose memory is to be written.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>address</i>:&nbsp; Starting address in task to be affected (must be a page boundary).</font>

<p><font face="Times"><i>data</i>:&nbsp; An array of bytes to be written.</font>

<p><font face="Times"><i>data_count</i>:&nbsp; The size in bytes of the data array (must be a multiple of <b>vm_page_size</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>vm_write()</b> allows a task's virtual memory to be written by another task.&nbsp; For languages other than C, the value of <b>vm_page_size</b> can be obtained by calling <b>vm_statistics()</b>.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">KERN_SUCCESS:&nbsp; Memory written.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">KERN_INVALID_ARGUMENT:&nbsp; The address doesn't start on a page boundary, or the size isn't an integral number of pages.</font>

<p><font face="Times">KERN_PROTECTION_FAILURE:&nbsp; The address region in the target task is protected against writing.</font>

<p><font face="Times">KERN_INVALID_ADDRESS:&nbsp; An illegal or nonallocated address was specified or the amount of allocated memory starting at <i>address</i> was less than <i>data_count</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>vm_copy()</b>, <b>vm_protect()</b>, <b>vm_read()</b>, <b>vm_statistics()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>Bootstrap Server Functions</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">The Bootstrap Server, like the Network Name Server, lets tasks publish ports that other tasks can send messages to.&nbsp; Unlike the Network Name Server, the Bootstrap Server is designed so that each server and its clients must be on the same host.&nbsp; The Bootstrap Server accomplishes this by using each task's bootstrap port (which is inherited from its parent) to ensure that the task is a descendent of a local task.</font>

<p><font face="Times">When a task forks a child task that shouldn't have access to the same set of services as the parent, the parent task must change its own bootstrap port--perhaps only temporarily--so that its child inherits a <i>subset port</i>.&nbsp; The parent should then change the set of services available on the subset port to suit the child's requirements.</font>

<p><font face="Times">The Bootstrap Server was created by NeXT, so these functions aren't in other versions of Mach.&nbsp; See <b>/NextDeveloper/Headers/servers/bootstrap.defs</b> for more information of how the Bootstrap Server works.</font>

<p><font face="Helvetica"><b>Note:</b></font>&nbsp; <font face="Times">If possible, you should use Distributed Objects instead of the Bootstrap Server.&nbsp; The Distributed Objects system is described in the <i>NEXTSTEP General Reference</i>.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_check_in()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get receive rights to a service port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_check_in(</b>port_t <i>bootstrap_port</i>, name_t <i>service_name</i>, port_all_t *<i>service_port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_name</i>:&nbsp; The string that names the service.</font>

<p><font face="Times"><i>service_port</i>:&nbsp; Returns receive rights to the service port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Use this function in a server to start providing a service.&nbsp; The service must already be defined, either by the appropriate line in <b>/etc/bootstrap.conf</b> or by a call to <b>bootstrap_create_service()</b>.&nbsp; Calling <b>bootstrap_check_in()</b> makes the service active.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Get receive rights for our service. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result=bootstrap_check_in(bootstrap_port, MYNAME, &amp;my_service_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Couldn't create service&#34;, result);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_NOT_PRIVILEGED:&nbsp; <i>bootstrap_port</i> is an unprivileged bootstrap port.</font>

<p><font face="Times">BOOTSTRAP_UNKNOWN_SERVICE:&nbsp; The service doesn't exist.&nbsp; It might be defined in a subset (see <b>bootstrap_subset()</b>).</font>

<p><font face="Times">BOOTSTRAP_SERVICE_ACTIVE:&nbsp; The service has already been registered or checked in and the server hasn't died.</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_create_service()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Create a service and service port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_create_service(</b>port_t <i>bootstrap_port</i>, name_t <i>service_name</i>, port_t *<i>service_port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_name</i>:&nbsp; The string that specifies the service.</font>

<p><font face="Times"><i>service_port</i>:&nbsp; Returns send rights for the service.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Creates a service named <i>service_name</i> and returns send rights to that port in <i>service_port</i>.&nbsp; The port may later be checked in as if this port were configured in the bootstrap configuration file.&nbsp; (At that time <b>bootstrap_check_in()</b> will return receive rights to <i>service_port</i> and will make the service active.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">This function is often used to create services that are available only to a subset of tasks (see <b>bootstrap_subset()</b>).&nbsp; Any task can call this function--it doesn't have to be the server.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Tell the bootstrap server about a service. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result=bootstrap_create_service(bootstrap_port, SERVICENAME,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;service_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result!=BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Couldn't create service&#34;, result);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_NOT_PRIVILEGED:&nbsp; <i>bootstrap_port</i> is an unprivileged bootstrap port.</font>

<p><font face="Times">BOOTSTRAP_SERVICE_ACTIVE:&nbsp; The service already exists.</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_info()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get information about all known services</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_info(</b>port_t <i>bootstrap_port</i>, name_array_t *<i>service_names</i>, unsigned int *<i>service_names_count</i>, name_array_t *<i>server_names</i>, unsigned int *<i>server_names_count</i>, bool_array_t *<i>service_active</i>, unsigned int *<i>service_active_count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_names</i>:&nbsp; Returns the names of all known services.</font>

<p><font face="Times"><i>service_names_count</i>:&nbsp; Returns the number of service names.</font>

<p><font face="Times"><i>server_names</i>:&nbsp; Returns the name, if known, of the server that provides the corresponding service.&nbsp; Except for the <b>mach_init </b>server, this name isn't known unless the bootstrap configuration file has a <b>server</b> line for this server.</font>

<p><font face="Times"><i>server_names_count</i>:&nbsp; Returns the number of server names.</font>

<p><font face="Times"><i>service_active</i>:&nbsp; Returns an array of booleans that correspond to the <i>service_names</i> array.&nbsp; For each item, the boolean value is true if the service is receiving messages sent to its port; otherwise, it's false.</font>

<p><font face="Times"><i>service_active_count</i>:&nbsp; Returns the number of items in the <i>service_active</i> array.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function returns information about all services that are known.&nbsp; Note that it won't return information on services that are defined only in subsets, unless the subset port is an ancestor of <i>bootstrap_port</i>.&nbsp; (See <b>bootstrap_subset()</b> for information on subsets.)</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">result = bootstrap_info(bootstrap_port, &amp;service_names, &amp;service_cnt,</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=119 height=1><font face="Courier" size="-1">&amp;server_names, &amp;server_cnt, &amp;service_active, &amp;service_active_cnt);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;ERROR:&nbsp; info failed: %d&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">for (i = 0; i &lt; service_cnt; i++)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf(&#34;Name: %-15s&nbsp;&nbsp; Server: %-15s&nbsp;&nbsp;&nbsp; Active: %-4s&#34;,</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">service_names[i],</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">server_names[i][0] == '\0' ? &#34;Unknown&#34; : server_names[i],</font><br>
<img src="../../../Images/sp.gif" width=189 height=1><font face="Courier" size="-1">service_active[i] ? &#34;Yes\n&#34; : &#34;No\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_NO_MEMORY:&nbsp; The Bootstrap Server couldn't allocate enough memory to return the information.</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_look_up()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the service port of a particular service</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_look_up(</b>port_t <i>bootstrap_port</i>, name_t <i>service_name</i>, port_t *<i>service_port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_name</i>:&nbsp; The string that identifies the service.</font>

<p><font face="Times"><i>service_port</i>:&nbsp; Returns send rights for the service port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns send rights for the service port of the specified service.&nbsp; The service isn't guaranteed to be active.&nbsp; (To check whether the service is active, use <b>bootstrap_status()</b>.)</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">result=bootstrap_look_up(bootstrap_port, &#34;FreeService2&#34;, &amp;srvc_port);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result!=BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;lookup failed: %d\n&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">/* Access the service by sending messages to srvc_port. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_UNKNOWN_SERVICE:&nbsp; The service doesn't exist.&nbsp; It might be defined in a subset (see <b>bootstrap_subset()</b>).</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_look_up_array()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get the service ports for an array of services</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_look_up_array(</b>port_t <i>bootstrap_port</i>, name_array_t <i>service_names</i>, unsigned int <i>service_names_count</i>, port_array_t *<i>service_ports</i>, unsigned int *<i>service_ports_count</i>, boolean_t *<i>all_services_known</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp;&nbsp;&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_names</i>:&nbsp; An array of service names.</font>

<p><font face="Times"><i>service_names_count</i>:&nbsp; The number of service names.</font>

<p><font face="Times"><i>service_ports</i>:&nbsp; Returns an array of service ports.</font>

<p><font face="Times"><i>service_ports_count</i>:&nbsp; Returns the number of service ports.&nbsp; This should be equal to <i>service_names_count</i>.</font>

<p><font face="Times"><i>all_services_known</i>:&nbsp; Returns true if every service name was recognized; otherwise returns false.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns port send rights in corresponding entries of the array <i>service_ports</i> for all services named in the array <i>service_names</i>. You should call <b>vm_deallocate()</b> on <i>service_ports</i> when you no longer need it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">Unknown service names have the corresponding service port set to PORT_NULL.&nbsp; Note that these services might be available in a subset (see <b>bootstrap_subset()</b>).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">kern_return_t&nbsp;&nbsp; result;</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_bootstrap_port;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">unsigned int&nbsp;&nbsp;&nbsp; port_cnt;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">boolean_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all_known;</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">name_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name_array[2]={&#34;Service&#34;, &#34;NetMessage&#34;};</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">port_array_t&nbsp;&nbsp;&nbsp; ports;</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result = task_get_bootstrap_port(task_self(), &amp;my_bootstrap_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Couldn't get bootstrap port&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result=bootstrap_look_up_array(my_bootstrap_port, name_array, 2,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">&amp;ports, &amp;port_cnt, &amp;all_known);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result!=BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Lookup array failed&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Port count = %d, all known = %d\n&#34;, port_cnt, all_known);</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* . . . */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result=vm_deallocate(task_self(), (vm_address_t)ports,</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">sizeof(ports)*port_cnt);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != KERN_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Trouble freeing ports&#34;, result);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_BAD_COUNT:&nbsp; <i>service_names_count</i> was too large (greater than BOOTSTRAP_MAX_LOOKUP_COUNT, which is defined in the header file <b>server/bootstrap_defs.h</b>).</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_register()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Register send rights for a service port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_register(</b>port_t <i>bootstrap_port</i>, name_t <i>service_name</i>, port_t <i>service_port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_name</i>:&nbsp; The string that identifies the service.</font>

<p><font face="Times"><i>service_port</i>:&nbsp; The service port for the service.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">You can use this function to create a server that hasn't been defined in the bootstrap configuration file.&nbsp; This function specifies to the Bootstrap Server exactly which port should be the service port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You can't register a service if an active binding already exists.&nbsp; However, you can register a service if the existing binding is inactive (that is, the Bootstrap Server currently holds receive rights for the service port); in this case the previous service port will be deallocated.</font>

<p><font face="Times">A service that is restarting can resume service for previous clients by setting <i>service_port</i> to the previous service port.&nbsp; You can get this port by calling <b>bootstrap_check_in()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">/* Create a port to use as the service port. */</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result=port_allocate(task_self(), &amp;myport);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Couldn't allocate a service port&#34;, result);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Tell the bootstrap server about my service. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">result=bootstrap_register(bootstrap_port, MYNAME, myport);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result != BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;Call to bootstrap_register failed: %d&#34;, result);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_NOT_PRIVILEGED:&nbsp; <i>bootstrap_port</i> is an unprivileged bootstrap port.</font>

<p><font face="Times">BOOTSTRAP_NAME_IN_USE:&nbsp; The service is already active.</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_status()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Check whether a service is available</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_status(</b>port_t <i>bootstrap_port</i>, name_t <i>service_name</i>, boolean_t *<i>service_active</i>&reg;<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>service_name</i>:&nbsp; The string that specifies a particular service.</font>

<p><font face="Times"><i>service_active</i>:&nbsp; Returns true if the service is active; otherwise, returns false.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">This function tells you whether a service is known to users of <i>bootstrap_port</i>, and whether it's active.&nbsp; A service is active if a server is able to receive messages on its service port.&nbsp; If a service isn't active, the Bootstrap Server holds receive rights for the service port.</font>

<p><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier" size="-1">result=bootstrap_status(bootstrap_port, MYNAME, &amp;service_active);</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (result!=BOOTSTRAP_SUCCESS)</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">printf(&#34;status check failed\n&#34;);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">else {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">if (service_active)</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf(&#34;Server %s is active\n&#34;, MYNAME);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">else</font><br>
<img src="../../../Images/sp.gif" width=161 height=1><font face="Courier" size="-1">printf (&#34;Server %s is NOT active\n&#34;, MYNAME);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_UNKNOWN_SERVICE:&nbsp; The service doesn't exist.&nbsp; It might be defined in a subset (see <b>bootstrap_subset()</b>).</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>bootstrap_subset()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Get a new port to use as a bootstrap port</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/bootstrap.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>bootstrap_subset(</b>port_t <i>bootstrap_port</i>, port_t <i>requestor_port</i>, port_t *<i>subset_port</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>bootstrap_port</i>:&nbsp; A bootstrap port.&nbsp; Usually, this should be the task's default bootstrap port, which is returned by <b>task_get_bootstrap_port()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>requestor_port</i>:&nbsp; A port that determines the life span of the subset.</font>

<p><font face="Times"><i>subset_port</i>:&nbsp; Returns the subset port.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">Returns a new port to use as a bootstrap port.&nbsp; This port behaves exactly like the previous <i>bootstrap_port</i>, with one exception: When you register a port by calling <b>bootstrap_register()</b> using <i>subset_port</i> as the bootstrap port, the registered port is available only to users of <i>subset_port</i> and its descendants.&nbsp; Lookups on the <i>subset_port</i> will return ports registered specifically with this port, and will also return ports registered with ancestors of this <i>subset_port</i>.&nbsp; (The ancestors of <i>subset_port</i> are <i>bootstrap_port </i>and, if <i>bootstrap_port</i> is itself a subset port, any ancestors of <i>bootstrap_port</i>.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">You can override a service already registered with an ancestor port by registering it with the subset port.&nbsp; Any thread that looks up the service using the subset port will see only the version of the service that's registered with the subset port.&nbsp; This is one way to transparently provide services such as monitor programs or individualized spelling checkers, while the rest of the system still uses the default service.</font>

<p><font face="Times">When it's detected that <i>requestor_port</i> is destroyed, the subset port and its descendants are destroyed; the services advertised by these ports are destroyed, as well.</font></td></tr>

</table>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Get and save the current bootstrap port for this task. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = task_get_bootstrap_port(task_self(), &amp;old_bs_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;task_get_bootstrap_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Get a subset port. */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = bootstrap_subset(old_bs_port, task_self(), &amp;subset_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != BOOTSTRAP_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;Couldn't get unpriv port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font>

<p><img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">/* Set the bootstrap port */</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">r = task_set_bootstrap_port(task_self(), subset_port);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">if (r != KERN_SUCCESS) {</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">mach_error(&#34;task_set_bootstrap_port&#34;, r);</font><br>
<img src="../../../Images/sp.gif" width=133 height=1><font face="Courier" size="-1">exit(1);</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">}</font><br>
<img src="../../../Images/sp.gif" width=105 height=1><font face="Courier" size="-1">bootstrap_port = subset_port;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">BOOTSTRAP_SUCCESS:&nbsp; The call succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">BOOTSTRAP_NOT_PRIVILEGED:&nbsp; <i>bootstrap_port</i> is an unprivileged bootstrap port.</font>

<p><font face="Times">Returns appropriate kernel errors on RPC failure.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+1"><b>Network Name Server Functions</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">If possible, you should use Distributed Objects instead of the Network Name Server functions.&nbsp; The Distributed Objects system is described in the <i>NEXTSTEP General Reference</i>.</font>

<p><br><br><br>

<p><font face="Helvetica"><b>netname_check_in()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Check a name into the local name space</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/netname.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>netname_check_in(</b>port_t <i>server_port</i>, netname_name_t <i>port_name</i>, port_t <i>signature</i>, port_t <i>port_id</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>server_port</i>:&nbsp; The task's port to the Network Name Server.&nbsp; To use the system Network Name Server, this should be set to the global variable <b>name_server_port</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; The name of the port to be checked in.</font>

<p><font face="Times"><i>signature</i>:&nbsp; The port used to protect the right to remove a name.</font>

<p><font face="Times"><i>port_id</i>:&nbsp; The port to be checked in.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>netname_check_in()</b> enters a port with the name <i>port_name</i> into the name space of the local network server.&nbsp; The <i>signature</i> argument is a port that's used to protect this name.&nbsp; This same port must be presented on a <b>netname_check_out()</b> call for that call to be able to remove the name from the name space.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">NETNAME_SUCCESS:&nbsp; The operation succeeded.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>netname_check_out()</b>, <b>netname_look_up()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>netname_check_out()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Remove a name from the local name space</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/netname.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>netname_check_out(</b>port_t <i>server_port</i>, netname_name_t <i>port_name</i>, port_t <i>signature</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>server_port</i>:&nbsp; The task's port to the Network Name Server.&nbsp; To use the system Network Name Server, this should be set to <b>name_server_port</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>port_name</i>:&nbsp; The name of the port to be checked out.</font>

<p><font face="Times"><i>signature</i>:&nbsp; The port used to protect the right to remove a name.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>netname_check_out()</b> removes a port with the name <i>port_name</i> from the name space of the local network server. The <i>signature</i> argument must be the same port as the signature port passed to <b>netname_check_in()</b> when this name was checked in.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">NETNAME_SUCCESS:&nbsp; The operation succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">NETNAME_NOT_YOURS:&nbsp; The signature given to <b>netname_check_out()</b> did not match the signature with which the port was checked in.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>netname_check_in()</b>, <b>netname_look_up()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>netname_look_up()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times">Look up a name on a specific host</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times"><b>#import &lt;mach/mach.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><b>#import &lt;servers/netname.h&gt;</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times">kern_return_t <b>netname_look_up(</b>port_t <i>server_port</i>, netname_name_t <i>host_name</i>, netname_name_t <i>port_name</i>, port_t *<i>port_id</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>ARGUMENTS </b></font><font face="Times"><i>server_port</i>:&nbsp; The task's port to the Network Name Server.&nbsp; To use the system Network Name Server, this should be set to <b>name_server_port</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times"><i>host_name</i>:&nbsp; The name of the host to query.&nbsp; This can't be a null pointer.</font>

<p><font face="Times"><i>port_name</i>:&nbsp; The name of port to be looked up.</font>

<p><font face="Times"><i>port_id</i>:&nbsp; The port that was looked up.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times">The function <b>netname_look_up()</b> returns the value of the port named by <i>port_name</i> by questioning the host named by the <i>host_name</i> argument.&nbsp; Thus this call is a directed name lookup.&nbsp; The <i>host_name</i> may be any of the host's official nicknames.&nbsp; If it's an empty string, the local host is assumed.&nbsp; If <i>host_name</i> is &quot;<b>*</b>&quot;, a broadcast lookup is performed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica"><b>Important:</b></font>&nbsp; <font face="Times">Use <b>NXPortNameLookup()</b> instead of <b>netname_look_up()</b> in all NEXTSTEP applications.&nbsp; (In the future, Listener instances might register with a server other than the Network Name Server.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times">NETNAME_SUCCESS:&nbsp; The operation succeeded.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times">NETNAME_NOT_CHECKED_IN:&nbsp; <b>netname_look_up()</b> could not find the name at the given host.</font>

<p><font face="Times">NETNAME_NO_SUCH_HOST:&nbsp; The <i>host_name</i> argument to <b>netname_look_up()</b> does not name a valid host.</font>

<p><font face="Times">NETNAME_HOST_NOT_FOUND:&nbsp; <b>netname_look_up()</b> could not reach the host named by <i>host_name</i> (for instance, because it's down).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times"><b>netname_check_in()</b>, <b>netname_check_out()</b></font></td></tr>

</table>



<p>

</body>
</html>
