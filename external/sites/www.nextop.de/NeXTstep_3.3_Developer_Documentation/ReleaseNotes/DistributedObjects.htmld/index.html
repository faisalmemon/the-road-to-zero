<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /Apps/NextDev/ReleaseNotes/DistributedObjects.rtf -->
<!-- Date: Sun Jun 28 20:13:38 1998 -->
<head>
<title>DistributedObjects</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times" size="-1">Release 3.3 Copyright</font> <font size="-1">&copy;</font><font face="Times" size="-1">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times" size="+1">3.3 Release Notes:</font><br>
<font face="Times" size="+1">Distributed Objects</font>

<p><br><br><br>

<p><font face="Times">This file contains release notes for the 3.2, 3.1, and 3.0 releases of Distributed Objects. Items specific to the 3.3 release are listed first, and the Release 3.2, 3.1 and 3.0 notes follow.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b>Known Problems in Release 3.3</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">These problems exist in Release 3.3:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Reference:</font></td>

<td><font face="Times">43098</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Problem:</font></td>

<td><font face="Times">Reference counting does not work properly in DO.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Description:</font></td>

<td><font face="Times">Reference counting does not work as documented in DO. For instance, references are added each time a server object is passed across a connection (server side) and added to the remote proxy object only when it is created on the client side.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Workaround:</font></td>

<td><font face="Times">None.</font></td></tr>

<tr valign=top>

<td width=90 height=34></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Reference:</font></td>

<td><font face="Times">49064</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Problem:</font></td>

<td><font face="Times">DO can't transfer long doubles.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Description:</font></td>

<td><font face="Times">Transfer of long doubles (by value) doesn't work for any architecture.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Workaround:</font></td>

<td><font face="Times">None.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b>Problems Fixed in Release 3.3</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">This problem has been fixed in Release 3.3:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Reference:</font></td>

<td><font face="Times">20051</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Problem:</font></td>

<td><font face="Times">Distributed Objects don't return doubles or structures.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap><font face="Helvetica" size="-2">Description:</font></td>

<td><font face="Times">This problem has been fixed, with the exception of some structures 4 bytes or less in size. Returning structures by value works with several caveats:</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap></td>

<td><font face="Times">1. On Intel-based systems (client or server), structures cannot be returned by value. If the structure is increased to greater than 8 bytes, the server will dump core; otherwise, an (apparently) zero-initialized structure will be returned.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap></td>

<td><font face="Times">2. On Motorola-based systems, structures can be returned by value, but they must be greater than 8 bytes.</font></td></tr>

<tr valign=top>

<td width=90 height=12></td></tr>

<tr valign=top>

<td width=90></td>

<td nowrap></td>

<td><font face="Times">3. On PA-RISC systems, 8 byte structures can be returned by value.</font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+1"><b>Notes Specific to Release 3.2</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b>Known Problems</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference:</font></td>

<td><font face="Times">21973</font></td></tr>

<tr valign=top>

<td width=97 height=17></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem:</font></td>

<td><font face="Times">Server memory not freed for string arguments.</font></td></tr>

<tr valign=top>

<td width=97 height=17></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Description:</font></td>

<td><font face="Times">When using Distributed Objects, if you pass a string (using <b>char *</b> or <b>const char *</b>) as an argument to a Distributed Objects server, the memory allocated by the server for this argument is not freed.</font></td></tr>

<tr valign=top>

<td width=97 height=29></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Workaround:</font></td>

<td><font face="Times">None.</font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+1"><b>Notes Specific to Release 3.1</b></font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b>New Features</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Although the documentation says that structures can't be returned, as of Release 3.1, they can be.&nbsp; See bug 20051, below, for more information.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=36></td>

<td><font face="Times"><b>Bugs Fixed in Release 3.1</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">These bugs have been fixed in Release 3.1:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">30760</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">Multithreaded servers don't clean up when connections are freed.</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Description</font></td>

<td><font face="Times">The port remained checked in with the Network Name Server, and the server thread didn't exit.</font></td></tr>

<tr valign=top>

<td width=97 height=18></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">30741</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">NXPortPortal's <b>encodeObjectByCopy:</b> method doesn't encode <b>nil </b>correctly.</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Description</font></td>

<td><font face="Times">The result was that any DO routine that returned <b>nil</b> using <b>bycopy </b>rather than a real object crashed with a bus error.</font></td></tr>

<tr valign=top>

<td width=97 height=18></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">30382</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">NXConnection's <b>setOutTimeout:</b> method has no effect.</font></td></tr>

<tr valign=top>

<td width=97 height=18></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">30031</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">Bug using proxies without protocols across architectures.</font></td></tr>

<tr valign=top>

<td width=97 height=18></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">29887</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">Transitive passing of root objects is broken.</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Description</font></td>

<td><font face="Times">Errors occurred if you tried to pass a proxy of a connection's root object to another connection.</font></td></tr>

<tr valign=top>

<td width=97 height=18></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">29873</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">References to a vended object can persist after the object is freed.</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Description</font></td>

<td><font face="Times">NXConnection's <b>removeObject:</b> method should eliminate references to the object passed as the argument to the method. However, if this method was invoked from the object's <b>free</b> method (a method that is given special handling in distributed objects), one dangling reference persisted.</font></td></tr>

<tr valign=top>

<td width=97 height=18></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Reference</font></td>

<td><font face="Times">20051</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Problem</font></td>

<td><font face="Times">Distributed Objects don't return doubles or structures.</font></td></tr>

<tr valign=top>

<td width=97 height=10></td></tr>

<tr valign=top>

<td width=97></td>

<td nowrap><font face="Helvetica" size="-2">Description</font></td>

<td><font face="Times">This bug has been fixed, with the exception of some structures 4 bytes or less in size.</font></td></tr>

</table>

<p><br><br><br>

<p><font face="Times" size="+1"><b>Notes Specific to Release 3.0</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">These notes were included with the Release 3.0 version of Distributed Objects.</font>

<p><font face="Times">A new facility has been made available that allows programmers to create client-server applications without much fuss.&nbsp; It takes the form of two new classes, NXConnection and NXProxy, which are available in the</font> <font face="Ohlfs,Courier" size="-1">libsys</font> <font face="Times">shared library.&nbsp; These classes allow any two programs to share Objective-C objects and send messages to them independent of their true location.</font></td></tr>

</table>

<p><br><br><br>

<p><font face="Times" size="+1"><b>Overview</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">DistributedObjects provides a mechanism for distributed programming.&nbsp; Typically, this takes the form of a server program that offers objects (services) to multiple clients, although configurations of pure peers are also common and useful.</font>

<p><font face="Times">The design objectives for DistributedObjects were to</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td nowrap><font face="Times"><img src="../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">totally subsume the network aspects of typical RPC programming</font></td></tr>

<tr valign=top>

<td width=72></td>

<td nowrap><font face="Times"><img src="../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">provide the exact programming environment for distributed objects as can be found locally</font></td></tr>

<tr valign=top>

<td width=72></td>

<td nowrap><font face="Times"><img src="../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">provide an object-oriented style of RPC programming</font></td></tr>

<tr valign=top>

<td width=72></td>

<td nowrap><font face="Times"><img src="../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">utilize language mechanisms for efficient network support</font></td></tr>

<tr valign=top>

<td width=72></td>

<td nowrap><font face="Times"><img src="../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times">provide support for multithreaded applications</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">The following sections will illustrate how each of these objectives were met.</font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+1"><b>Making a DistributedObjects connection</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Let's assume the simple case of a single client and server.&nbsp; The client wants to send messages to an object that the server owns.&nbsp; The current implementation of DistributedObjects uses MACH ports as its underlying connection vehicle, and we leverage off of a standard MACH facility called the Network Name Server (NetNameServer) to find the object that the server owns:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">#import &lt;remote/NXConnection.h&gt;</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id ro = [NXConnection connectToName:&#34;ServerExample&#34;];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">In this example,</font> <font face="Ohlfs,Courier" size="-1">ro</font> <font face="Times">is assigned an</font> <font face="Ohlfs,Courier" size="-1">NXProxy</font> <font face="Times">object that will stand in locally for the object &#34;vended&#34; by the server, and</font> <font face="Ohlfs,Courier" size="-1">&#34;ServerExample&#34;</font> <font face="Times">is the name used by the server program. The server program has already performed the following code:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">#import &lt;remote/NXConnection.h&gt;</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id vendedObject = [[YourServerObject alloc] init];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id roserver = [NXConnection registerRoot:vendedObject withName:&#34;ServerExample&#34;];</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[roserver run]; // non-appkit style; blocks</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">The server creates an object of its choice known, in this case, as</font> <font face="Ohlfs,Courier" size="-1">vendedObject</font><font face="Times">, and registers it with the DistributedObjects subsystem.&nbsp; DistributedObjects registers the MACH port it is using with the Network Name Server so that the client can establish a connection.&nbsp; The server then tells its RemoteObject server object,</font> <font face="Ohlfs,Courier" size="-1">roserver</font><font face="Times">, to run; that is, to loop awaiting messages from its clients.&nbsp; The messages will be sent to</font> <font face="Ohlfs,Courier" size="-1">vendedObject </font><font face="Times">and be indistinguishable from local messages sent from elsewhere in the server program (if there were any).</font>

<p><font face="Times">We call the vended object the &#34;root&#34; object because through it, many other objects that the server provides can become accessible.&nbsp; All you have to do is write methods that return these other objects!</font>

<p><font face="Times">If you are writing an AppKit program then you should ask it to service messages for your objects by issuing:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[roserver runFromAppKit];</font>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">instead.</font></td></tr>

</table>

<p><br><br><br>

<p><font face="Times" size="+1"><b>What you can (and can't) do with DistributedObjects</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Assuming that the connection discussed in the previous section has been established, what can the client program ask the server program to do with the shared object? Actually, the client can ask it to do anything, since DistributedObjects will <i>forward</i> all requests, but the more reasonable question is, what can servers provide to clients in the way of useful Objective-C messages?&nbsp; Here are some examples:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro aSimpleMessage];&nbsp; // no parameters</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro sendAnInteger: 12]; // simple scalars</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro sendAString:&#34;hello&#34;];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro sendAnId: anObject]; // send an arbitrary object</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro sendAnId: ro];&nbsp; // send back the shared object!</font>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">In the last case, we send the id of something the server owns back to the server.&nbsp; In our example, the server knows that object by the value stored in the</font> <font face="Ohlfs,Courier" size="-1">vendedObject</font> <font face="Times">variable, and, indeed, the parameter to the</font> <font face="Ohlfs,Courier" size="-1">sendAnId:</font> <font face="Times">message will have that same value.&nbsp; In other words, DistributedObjects keeps track of the objects sent to and received from other parties and will make sure that your programs see the &#34;right&#34; object.&nbsp; Jumping ahead a little to more advanced features, the client could have sent an</font> <font face="Ohlfs,Courier" size="-1">NXProxy</font> <font face="Times">object that it obtained from some other server X, in which case our example server would have recieved an</font> <font face="Ohlfs,Courier" size="-1">NXProxy</font> <font face="Times">to something vended by Server X.&nbsp; A new connection will have been automatically created between our example server and Server X.&nbsp; Of course, if our server sends <i>that</i></font> <font face="Ohlfs,Courier" size="-1">NXProxy</font> <font face="Times">object back to X, X will see it as the original object sent to our client. In simple terms, you can send objects anywhere and they will always come back to you correctly.</font>

<p><font face="Times">In the case where the client sent</font> <font face="Ohlfs,Courier" size="-1">anObject</font><font face="Times">, it is possible for the server program to <i>send a message back to the client</i>, <i>in the middle of the server's</i></font> <font face="Ohlfs,Courier" size="-1">sendAnId</font> <font face="Times"><i>implementation</i>.&nbsp; This is an important feature and should be considered carefully.&nbsp; After the client call completes, the server may wish to call the client back (send a message to an object on the client).&nbsp; In general, this won't work, unless the client is in the middle of sending another message to the server.&nbsp; This is because there has to be a thread of execution waiting to serve incoming requests.&nbsp; The thread executing the client request pauses for the reply and will, charitably, honor any new incoming requests during that time.&nbsp; If the client is willing to yield its thread of control, it can send -run or -runWithTimeout: to the connection.</font>

<p><font face="Times">The last important class of parameters that can be passed are structures:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">struct&nbsp; a_struct {</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">char aChar;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">int anInt;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">unsigned int bitfield:3;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">enum { red, green, blue } color;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">id anObject;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">char *aString;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">int array[2];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">} aStruct = { 'a', 1024, blue, 2, nil, &#34;hello world\n&#34;, { 0, 1}};</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">aStruct.anObject = [Object new];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro sendAStruct:aStruct];</font>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Although contrived, the example shows that quite complicated things can be passed as parameters.</font>

<p><font face="Times">Servers wouldn't be too useful if they couldn't return interesting values, so DistributedObjects offers the standard mechanisms for so doing:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">int anInt = [ro getAnInt];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id anId = [ro getAnId];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">char *aString = [ro getAString];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">double d = [ro getADouble]; // new in 3.1</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">struct a_struct aStruct = [ro getAStruct]; // new in 3.1</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">struct a_struct *aStructPointer = [ro getAPtrToStruct];</font>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">and</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro updateAnInt:&amp;anInt]; // this time, via an inout parameter</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro updateAnId:&amp;anId];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro updateAString:&amp;aString];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[ro updateAStruct:&amp;aStruct]; // caller supplies the storage</font>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">A server can return a pointer to a structure and DistributedObjects will allocate storage for the structure on the receiving side and return a pointer to it. In the case of the</font> <font face="Ohlfs,Courier" size="-1">inout </font><font face="Times">parameters, the caller supplies the storage.</font>

<p><font face="Times">It is extremely important to note that we have supplied legal values for the dereferenced parameters (</font><font face="Ohlfs,Courier" size="-1">anId</font> <font face="Times">has a legal value,</font> <font face="Ohlfs,Courier" size="-1">aString</font> <font face="Times">has a legal value, etc. with the exception of </font><font face="Ohlfs,Courier" size="-1">aStruct.anId</font><font face="Times">).&nbsp; This is because DistributedObjects assumes that the server program might want to examine the indirect contents of its passed parameter as part of its function, and will attempt to ship the original contents across.&nbsp; <b>This may not be what you intend! See the section on Protocols for how to specify</b></font> <font face="Ohlfs,Courier" size="-1">in</font> <font face="Times"><b>or</b></font> <font face="Ohlfs,Courier" size="-1">out</font> <font face="Times"><b>direction exclusively.</b></font>

<p><font face="Times">DistributedObjects will allocate memory in order to pass or return strings and structures. It is the responsibility of the recipient to free this memory.&nbsp; Objects passed by copy also must be freed by the recipient.&nbsp; An object passed by reference will be sent</font> <font face="Ohlfs,Courier" size="-1">free</font> <font face="Times">if the connection breaks or the object is</font> <font face="Ohlfs,Courier" size="-1">free</font><font face="Times">'d by its recipient.&nbsp; If the object supports the </font><font face="Ohlfs,Courier" size="-1">NXReference</font> <font face="Times">protocol, however, a reference will be added the first time it is seen on each connection.</font></td></tr>

</table>

<p><font face="Times"><b>Things that won't work</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">DistributedObjects will not support the following:</font>

<p><font face="Times">unions - DistributedObjects cannot know which element to format and ship.</font><br>
<font face="Times">void * - This is a synonym for an anonymous pointer which is known to be valid in only one address space.&nbsp; We keep it that way.</font><br>
<font face="Times">pointers within structures - DistributedObjects cannot know how deep to recurse when passing a referenced structure so it chooses a simple answer: no recursion.</font><br>
<font face="Times">BOOL * - Distributed Objects treats this incorrectly as a</font> <font face="Ohlfs,Courier" size="-1">char *</font><font face="Times">.</font><br>
<font face="Times">tiny structures as return values - some structures less than four bytes in size are not returned properly.</font></td></tr>

</table>

<p><br><br><br>

<p><font face="Times" size="+1"><b>Advanced Features</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Up to this point in the discussion we have seen many examples of how to use DistributedObjects strictly from a client programmer's perspective, and without any real context, such as the declarations of the object interfaces.&nbsp; One can perfom a certain amount of code copying and tweaking with a non-zero chance of success, and, in fact, we hope that DistributedObjects is simple enough to use that the non-zero chance is quite high.</font>

<p><font face="Times">But to do significant programming of any nature one must look at the object interfaces and the documentation.&nbsp; This holds true for any objects that are handled by the DistributedObjects system.&nbsp; NeXT has enriched the Objective-C programming language to support better descriptions of programming interfaces, and DistributedObjects supports these enhancements.</font>

<p><font face="Times">The Objective-C language has been extended to support a new method grouping construct known as Protocols.&nbsp; Within a protocol specification, five new keywords have been added.&nbsp; All of these features are of importance to DistributedObjects, so we will discuss them briefly here.</font></td></tr>

</table>

<p><font face="Times"><b>Protocols</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">A client may specify the expected</font> <font face="Ohlfs,Courier" size="-1">Protocol</font> <font face="Times">that an object will serve upon the completion of a connection.&nbsp; Providing this specification enables more efficient delivery of messages to remote objects by avoiding a &#34;discovery&#34; message per method:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id &lt;foo&gt; aFoo = [NXConnection connectToName:&#34;ServerExample&#34;];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[aFoo setProtocolForProxy:@protocol(foo)];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">A server may restrict the messages served upon a vended object by using the NXProtocolChecker class:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">ReadWriteServer *rw = [ReadWriteServer new];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">NXProtocolChecker *r = [[NXProtocolChecker alloc] initWithObject:rw</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">forProtocol:@protocol(ReadOnly)];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id readServer = [NXConnection registerRoot:r];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">In the last case, presumably the &#34;ReadOnly&#34; protocol is a subset of the methods that the ReadWriteServer object implements.</font></td></tr>

</table>

<p><br><br>

<p><font face="Times"><b>Directionality of parameters: <i>in, out,</i> and <i>inout</i></b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">In the C programming language, all parameters are passed by value.&nbsp; This works fine for scalars, but pointers present problems.&nbsp; The first problem is whether the pointer points at an array or a single instance, and the second problem is whether the pointer references a valid item upon entry.&nbsp; The historical third problem, whether it is legal to alter the contents of a dereferenced pointer, is addressed by the ANSI</font> <font face="Ohlfs,Courier" size="-1">const</font> <font face="Times">declarator.</font>

<p><font face="Times">Objective-C offers three new keywords to address the first and second problems:</font> <font face="Ohlfs,Courier" size="-1">in</font><font face="Times">,</font> <font face="Ohlfs,Courier" size="-1">out </font><font face="Times">and</font> <font face="Ohlfs,Courier" size="-1">inout</font><font face="Times">.&nbsp; An</font> <font face="Ohlfs,Courier" size="-1">in</font> <font face="Times">parameter will be copied across from client to server, an</font> <font face="Ohlfs,Courier" size="-1">out</font> <font face="Times">parameter will only be copied back, and an</font> <font face="Ohlfs,Courier" size="-1">inout</font> <font face="Times">parameter will be copied to and back.</font>

<p><font face="Times">Thus:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@protocol foo</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- anINny:(in int *)anInt;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- anOUTty:(out int *)anInt;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- anINnyOUTty:(inout int*)anInt;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Pointer parameters are treated as</font> <font face="Ohlfs,Courier" size="-1">inout</font> <font face="Times">by default, and</font> <font face="Ohlfs,Courier" size="-1">const *</font> <font face="Times">parameters are treated as </font><font face="Ohlfs,Courier" size="-1">in</font><font face="Times">.</font></td></tr>

</table>

<p><font face="Times"><b>Passing objects on the wire</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">The default behavior for passing objects from one program to another is to establish an </font><font face="Ohlfs,Courier" size="-1">NXProxy</font> <font face="Times">object on the client; when the proxy is used locally on the client the Objective-C message is encoded into a MACH message and sent to the server, which decodes and dispatches to the real object.&nbsp; There will be many times when this policy is not desirable, such as when the object is small and won't change over time, when a complete copy of an object is desired for manipulation, or when a container object is passed.&nbsp; In these cases, one wants to pass the implementation of an object in some manner and instantiate a copy on the client side.&nbsp; We describe this latter process as an Object passing itself across the wire (but don't take us too literally!).</font>

<p><font face="Times">Objects that do wish to pass themselves across in this manner must implement the following Transport protocol (from &lt;remote/transport.h&gt;):</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@protocol Transport</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// override standard (NXProxy) formation</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeRemotelyFor:(NXConnection *)connection freeAfterEncoding:(BOOL *)flagp&nbsp;&nbsp; isBycopy:(BOOL)isBycopy;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// encoding</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeUsing:(id &lt;NXEncoding&gt;)portal;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// decoding</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- decodeUsing:(id &lt;NXDecoding&gt;)portal;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">The method</font>&nbsp; <font face="Ohlfs,Courier" size="-1">encodeUsing</font> <font face="Times">is called when the object should encode itself onto the portal and</font> <font face="Ohlfs,Courier" size="-1">decodeUsing</font> <font face="Times">is called on the other end to reconstruct the object.&nbsp; The</font> <font face="Ohlfs,Courier" size="-1">decodeUsing </font><font face="Times">method should act just like an instance initialization method - storage has been allocated for it but the storage is uninitialized.&nbsp; Another object may be substituted during this reconstruction phase; the substituted object should be returned -- DistributedObjects will free the initially allocated memory.</font>

<p><font face="Times">You will see later that objects don't <i>always</i> have to encode themselves, but if they <i>always </i>do, they should implement the following method in the following manner:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeRemotelyFor:(NXConnection *)connection freeAfterEncoding:(BOOL *)fae</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">isBycopy:(BOOL) ibc {</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">return self;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">The following protocols may be used upon the parameter</font> <font face="Ohlfs,Courier" size="-1">portal</font> <font face="Times">to encode and decode your Object:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@protocol NXEncoding</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// encode an objc (parameter) type</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeData:(void *)data ofType:(const char *)type;</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// encoding methods for transcribing custom objects</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeBytes:(const void *)bytes count:(int)count;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeVM:(const void *)bytes count:(int)count;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeMachPort:(port_t)port;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeObject:anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send a ref to the object across</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeObjectBycopy:anObject;&nbsp; // copy the object across</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@end</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@protocol NXDecoding</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// decode an objc (parameter) type</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- decodeData:(void *)d ofType:(const char *)t;</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">// decoding methods for transcribing custom objects</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- decodeBytes:(void *)bytes count:(int)count;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- decodeVM:(void **)bytes count:(int *)count;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- decodeMachPort:(port_t *)pp;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- (id) decodeObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns decoded object</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">As an example, an</font> <font face="Ohlfs,Courier" size="-1">Integer</font> <font face="Times">object that wanted to pass itself could implement the Transport protocol thus:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@interface Integer : Object&nbsp; &lt;Transport&gt; {</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">int value;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">}</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">...</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@end</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@implementation Integer</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">...</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeRemotelyFor:(NXConnection *)connection freeAfterEncoding:(BOOL *)flagp&nbsp;&nbsp; isBycopy:(BOOL)isBycopy {</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">if (isByCopy)</font><br>
<img src="../Images/sp.gif" width=170 height=1><font face="Ohlfs,Courier" size="-1">return self;</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">else</font><br>
<img src="../Images/sp.gif" width=170 height=1><font face="Ohlfs,Courier" size="-1">return [super encodeRemoteFor:connection freeAfterEncoding:flagp</font><br>
<img src="../Images/sp.gif" width=192 height=1><font face="Ohlfs,Courier" size="-1">isByCopy:NO];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">}</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- encodeUsing:(id &lt;NXEncoding&gt;)portal {</font><br>
<img src="../Images/sp.gif" width=122 height=1><font face="Ohlfs,Courier" size="-1">[portal encodeData:&amp;value ofType:&#34;i&#34;];</font><br>
<img src="../Images/sp.gif" width=122 height=1><font face="Ohlfs,Courier" size="-1">return self;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">}</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- decodeUsing:(id &lt;NXEncoding&gt;)portal {</font><br>
<img src="../Images/sp.gif" width=122 height=1><font face="Ohlfs,Courier" size="-1">[portal decodeData:&amp;value ofType:&#34;i&#34;];</font><br>
<img src="../Images/sp.gif" width=122 height=1><font face="Ohlfs,Courier" size="-1">return self;</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">}</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">The objects that implement the</font> <font face="Ohlfs,Courier" size="-1">NXEncoding</font> <font face="Times">and</font> <font face="Ohlfs,Courier" size="-1">NXDecoding</font> <font face="Times">protocols hide the nasty details of inter process communication and are of no other utility.</font></td></tr>

</table>

<p><font face="Times"><b>The <i>bycopy</i> keyword</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">In the case of objects, such as containers, that sometimes should instantiate a copy and sometimes not, Objective-C provides the</font> <font face="Ohlfs,Courier" size="-1">bycopy</font> <font face="Times">keyword:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- sendAListBycopy:(bycopy id) aList;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">When a parameter is marked</font> <font face="Ohlfs,Courier" size="-1">bycopy</font><font face="Times">, DistributedObjects will call that object's </font><font face="Ohlfs,Courier" size="-1">encodeRemotelyFor:freeAfterEncoding:isBycopy:</font> <font face="Times">method with a</font> <font face="Ohlfs,Courier" size="-1">YES</font> <font face="Times">value for the </font><font face="Ohlfs,Courier" size="-1">isBycopy</font> <font face="Times">parameter.&nbsp;&nbsp; In those cases where the standard NXProxy treatment is desired, the message should be forwarded to the super class and its result returned.</font></td></tr>

</table>

<p><font face="Times"><b>The <i>oneway</i> keyword</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">There are times in distributed programming when it is known in advance that particular methods will not return to the caller, or that there is no need for a client to wait for the completion of a method as in the normal programming case.&nbsp; For these cases, Objective-C provides the oneway keyword:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- (oneway) exit; // implicitly void</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- (oneway) logresult:(in char *) message;</font>

<p><font face="Times"><b>Exceptions</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">DistributedObjects returns exceptions (see NX_RAISE) raised by method implementations.</font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+1"><b>Multi-threaded programming support</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Many servers will wish to be multi-threaded.&nbsp; Some will succeed :-).&nbsp; Servers need to protect any vended objects against shared access, but DistributedObjects is itself thread-safe and a simple method is provided to invoke several threads serving the same object:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">while(xtraservers-- &gt; 0)</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">[roserver runInNewThread];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[roserver run]; // this one blocks</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">An important restriction when using multiple threads on a single connection is that in general, call-back does not work (unless that call-back is a</font> <font face="Ohlfs,Courier" size="-1">oneway</font> <font face="Times">message).&nbsp; The simplest work-around for this is to build a new connection to the originator, and perhaps dedicate a new thread to that connection:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">- multithreaded_server_method:(&lt;SomeProtocol&gt;)proxy_to_client {</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">NXConnection existing = [proxy_to_client connectionForProxy];</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">NXConnection newconn = [NXConnection connectToPort:[existing outPort]];</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">id &lt;SomeProtocol&gt; new_proxy = [newconn newRemote:[proxy_to_client nameForProxy]</font><br>
<img src="../Images/sp.gif" width=192 height=1><font face="Ohlfs,Courier" size="-1">withProtocol:@protocol(SomeProtocol)];</font>

<p><img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">...</font><br>
<img src="../Images/sp.gif" width=144 height=1><font face="Ohlfs,Courier" size="-1">[new_proxy method_from_SomeProtocol];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">}</font>

<p><font face="Times" size="+1"><b>AppKit programming support</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">When writing single threaded application programs using the AppKit, care must be taken to allow the normal AppKit MACH message processing to occur in conjunction with DistributedObjects.&nbsp; A special interface has been designed to allow single threaded clients and servers to easily share objects within an AppKit context:</font>

<p><font face="Times">Typical use for a Application that acts as a server:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id vendedObject = ...; // something to be exported</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">NXConnection *c;</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">c = [NXConnection registerRoot:vendedObject withName:&#34;DOStringServer&#34;];</font><br>
<img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[c runFromAppKit];</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">Typical use for an app that starts as a client, but that passes out objects that need to be served:</font></td></tr>

</table>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">id ss = [NXConnection connectToName:&#34;DOStringServer&#34;];</font>

<p><img src="../Images/sp.gif" width=96 height=1><font face="Ohlfs,Courier" size="-1">[[ss connectionForProxy] runFromAppKit];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=72></td>

<td><font face="Times">DistributedObjects are normally served at the DPS base threshold priority.&nbsp; If this is inappropriate, the</font> <font face="Ohlfs,Courier" size="-1">runFromAppKitWithPriority:(int)priority</font> <font face="Times">method may be used.</font></td></tr>

</table>



<p><br><br>

</body>
</html>
